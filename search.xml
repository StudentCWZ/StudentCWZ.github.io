<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第二章 Golang 概述</title>
      <link href="/post/29c840ec.html"/>
      <url>/post/29c840ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-概述"><a href="#Golang-概述" class="headerlink" title="Golang 概述"></a>Golang 概述</h1><h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><ol><li>程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令集合。</li></ol><h2 id="为什么学习-Go-语言"><a href="#为什么学习-Go-语言" class="headerlink" title="为什么学习 Go 语言"></a>为什么学习 Go 语言</h2><ol><li>Go 语言是区块链最主流的编程语言，同时也是当前最具发展潜力的语言。</li><li>Go 语言是由 Google 公司创造的语言，也是 Google 主推的语言。</li><li>国外如 Google、AWS、Cloudflare、CoreOS 等，国内如阿里、小米已经大规模使用 Golang 开发其云计算相关产品。</li></ol><h2 id="Go-语言的核心开发团队"><a href="#Go-语言的核心开发团队" class="headerlink" title="Go 语言的核心开发团队"></a>Go 语言的核心开发团队</h2><ol><li>Ken Thompson(肯·汤普森)：1983 年图灵奖和 1998 年美国国家技术奖得主。他与 Dennis Ritchie 是 Unix 的原创者。 Thompson 也发明了后来衍生出 C 语言的 B 程序语言，同时也是 C 语言的主要发明人。</li><li>Rob Pike(罗布·派克)：曾是贝尔实验室的 Unix 团队，和 Plan 9 操作系统计划的成员。他与 Thompson 共事多年，并共创出广泛使用的 UTF-8 字元编码。</li><li>Robert Griesemer：曾协助制作 Java 的 HotSpot 编译器，和 Chrome 浏览器的 JavaScript 引擎 V8。</li></ol><h2 id="Google-为什么创造-Go-语言"><a href="#Google-为什么创造-Go-语言" class="headerlink" title="Google 为什么创造 Go 语言"></a>Google 为什么创造 Go 语言</h2><ol><li>计算机硬件技术更新频繁，性能提高很快。目前主流的编程语言发展明显落后于硬件，不能合理利用多核多 CPU 的优势提升软件系统性能。</li><li>软件系统复杂度越来越高，维护成本越来越来高，目前缺乏一个足够简洁高效的编程语言。</li><li>企业运行维护很多 C&#x2F;C++ 的项目， C&#x2F;C++ 程序运行速度虽然很快，但是编译速度确实很慢，同时还存在内存泄露的一系列的困扰需要解决。</li></ol><h2 id="Go-语言发展简史"><a href="#Go-语言发展简史" class="headerlink" title="Go 语言发展简史"></a>Go 语言发展简史</h2><ol><li>2007 年，谷歌工程师 Rob Pike、Ken Thompson 和 Robert Griesemer 开始设计一门全新的语言，这是 Go 语言的最初原型。</li><li>2009 年 11 月 10 日，Google 将 Go 语言以开放源代码的方式向全球发布。</li><li>2015 年 8 月 19 日， Go 1.5 版发布，本次更新中移除了“最后残余的 C 代码”。</li><li>2017 年 2 月 17 日， Go 语言 Go 1.8 版发布。</li><li>2017 年 8 月 24 日， Go 语言 Go 1.9 版发布。</li><li>2018 年 2 月 16 日， Go 语言 Go 1.10 版发布。</li></ol><h2 id="Go-语言的特点"><a href="#Go-语言的特点" class="headerlink" title="Go 语言的特点"></a>Go 语言的特点</h2><ol><li><p>Go 语言保证了既能达到静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容 Go 语言：Go &#x3D; C + Python ，说明 Go 语言既有 C 静态语言程序的运行速度，又能达到 Python 动态语言的快速开发。</p></li><li><p>从 C 语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和 C 语言一样的编译执行方式及弱化指针。</p></li><li><p>引入包的概念，用于组织程序结构，Go 语言的一个文件都要归属一个包，而不能单独存在。</p></li><li><p>垃圾回收机制，内存自动回收，不需开发人员管理。</p></li><li><p>天然并发。</p><ul><li><p>从语言层面支持并发，实现简单</p></li><li><p>goroutine，轻量级线程，可实现大并发处理，高效利用多核</p></li><li><p>基于 CPS 并发模型实现</p></li></ul></li><li><p>吸收了管道通信机制，形成 Go 语言特有的管道 channel ，通过管道 channel ，可以实现不同的 goroute 之间的相互通信。</p></li><li><p>函数返回多个值。</p></li><li><p>新的创新：比如切片、延时执行 defer 等。</p></li></ol><h2 id="Go-语言的开发工具"><a href="#Go-语言的开发工具" class="headerlink" title="Go 语言的开发工具"></a>Go 语言的开发工具</h2><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><ol><li>Visual studio code Microsoft 产品：一个运用于 Mac OS X、Windows 和 Linux 系统上的 IDE ，默认提供 Go 语言语法高亮，能安装 Go 语言插件，还可以支持智能提示，编译运行等功能。</li><li>Sublime Text，可以免费试用，默认也支持 Go 代码语法高亮，只是保存次数达到一定数量之后就会提示是否购买，点击取消继续用，和正式注册版本没有任何区别。</li><li>Vim：Vim 是从 Vi 发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</li><li>Emacs：Emacs 传说中的神器，它不仅仅是一个编辑器，因为功能强大，可称它为集成开发环境。</li><li>Eclipse IDE 工具，开源免费，并提供 GoEclipse 插件。</li><li>LiteIDE ，LiteIDE 是一款专门为 Go 语言开发的跨平台轻量级集成开发环境，是国人开发的。</li><li>JetBrains 公司产品：Phpstrom 、WebStrom 和 PyCharm 等 IDE 工具，其中 Goland IDE 需要安装 GO 插件。</li></ol><h3 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h3><ol><li>我们先选择用 Visual studio code 或者 vim 文本编辑器，到对 Go 语言有一定了解后，再使用 Eclipse 等 IDE 开发工具。</li><li>这样更深刻的理解 Go 语言技术，培养代码感。</li><li>有利于公司面试。</li></ol><h4 id="VSCode-的安装和使用"><a href="#VSCode-的安装和使用" class="headerlink" title="VSCode 的安装和使用"></a>VSCode 的安装和使用</h4><ol><li><a href="!https://code.visualstudio.com/download">官方网址</a>。</li><li>选择适合自己系统的 VSCode 软件。</li></ol><h5 id="Windows-下安装-VSCode"><a href="#Windows-下安装-VSCode" class="headerlink" title="Windows 下安装 VSCode"></a>Windows 下安装 VSCode</h5><ol><li>首先查看自己电脑是 32 位还是 64 位系统，然后选择对应的 VSCode 下载。</li><li>双击安装文件，就可以一步步安装。</li></ol><h5 id="Linux-下安装-VSCode"><a href="#Linux-下安装-VSCode" class="headerlink" title="Linux 下安装 VSCode"></a>Linux 下安装 VSCode</h5><ol><li>先下载 Linux 版本的 VSCode 安装文件。</li><li>这里使用的是虚拟机的 Ubuntu ，因此我需要先将 VSCode 安装文件传输到 Ubuntu 下。</li><li>使用的是 xftp5 软件上传。</li><li>如果你是在 Ubuntu 下做 go 开发，建议将 VSCode 安装到 &#x2F;opt 目录下。</li><li>将 VSCode 安装文件拷贝到 &#x2F;opt 目录下。</li><li>将 VSCode 安装文件解压：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf 安装文件</span><br></pre></td></tr></table></figure><ol start="7"><li>运行 VSCode</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./code</span><br></pre></td></tr></table></figure><h5 id="Mac-下安装-VSCode"><a href="#Mac-下安装-VSCode" class="headerlink" title="Mac 下安装 VSCode"></a>Mac 下安装 VSCode</h5><ol><li>下载 Mac 版本的 VSCode 安装文件。</li><li>把 VSCode 安装文件传输到 Mac 系统。</li><li>在默认情况下，Mac 没有启动 ssh 服务，所以需要我们手动开启，才能远程传输文件。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1) 启动sshd服务：</span><br><span class="line">sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist</span><br><span class="line">(2) 停止sshd服务：</span><br><span class="line">sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist</span><br><span class="line">(3) 查看是否启动：</span><br><span class="line">sudo launchtrl list | grep ssh</span><br><span class="line">(4) 看到下面的输出表示成功启动了</span><br><span class="line">- 0 com.openssh.sshd</span><br></pre></td></tr></table></figure><ol start="4"><li>将 VSCode 安装文件解压后，即可使用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip 安装文件</span><br></pre></td></tr></table></figure><h2 id="Go-语言开发环境搭建"><a href="#Go-语言开发环境搭建" class="headerlink" title="Go 语言开发环境搭建"></a>Go 语言开发环境搭建</h2><h3 id="Windows-下搭建-Go-开发环境-安装和配置"><a href="#Windows-下搭建-Go-开发环境-安装和配置" class="headerlink" title="Windows 下搭建 Go 开发环境-安装和配置"></a>Windows 下搭建 Go 开发环境-安装和配置</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>SDK 的全称(Software Development Kit，软件开发工具包)。</li><li>SDK 是提供给开发人员使用的，其中包含了对应开发语言的工具包。</li></ol><h4 id="SDK-下载"><a href="#SDK-下载" class="headerlink" title="SDK 下载"></a>SDK 下载</h4><ol><li>Go 语言的<a href="!https://golang.org/dl/">官网</a>，因为种种原因，可能无法访问。</li><li><a href="!https://studygolang.com/dl">SDK 下载地址</a>。</li></ol><h4 id="SDK-安装"><a href="#SDK-安装" class="headerlink" title="SDK 安装"></a>SDK 安装</h4><ol><li><p>Windows 下 SDK 的各个版本说明：</p><ul><li><p>Windows 下：根据自己系统是 32 位还是 64 位进行下载。</p></li><li><p>32 位系统：go1.15.2.windows-386.zip</p></li><li><p>64 位系统：go1.15.2.windows-amd64.zip</p></li></ul></li><li><p>请注意：安装路径不要有中文或者特殊符号如空格等。</p></li><li><p>SDK 安装目录建议： Windows 一般安装在 d:&#x2F;programs 。</p></li><li><p>安装时，基本是傻瓜式安装，解压就可以使用。</p></li><li><p>解压后，会得到 d:&#x2F;go 目录，这个是 SDK 。</p></li></ol><h4 id="Windows-下配置-Golang-环境变量"><a href="#Windows-下配置-Golang-环境变量" class="headerlink" title="Windows 下配置 Golang 环境变量"></a>Windows 下配置 Golang 环境变量</h4><h5 id="为什么要配置环境变量"><a href="#为什么要配置环境变量" class="headerlink" title="为什么要配置环境变量"></a>为什么要配置环境变量</h5><ol><li>在 dos 命令行中敲 go ，出现错误提示。</li><li>原因分析：当前执行的程序在当前目录下如果不存在，Windows 系统会在系统中已有的一个名为 path 的环境变量指定的目录中查找。如果仍未找到，会出现以上的错误提示。所以进入到 go 安装路径 \bin 目录下，执行 go，会看到 go 参数提示信息。</li></ol><h5 id="配置环境变量介绍"><a href="#配置环境变量介绍" class="headerlink" title="配置环境变量介绍"></a>配置环境变量介绍</h5><ol><li>根据 Windows 系统在查找可执行程序的原理，可以将 Go 所在路径定义到环境变量中，让系统帮我们去找运行执行的程序，这样在任何目录下都可执行 go 指令。</li></ol><h5 id="配置哪些环境变量"><a href="#配置哪些环境变量" class="headerlink" title="配置哪些环境变量"></a>配置哪些环境变量</h5><table><thead><tr><th>环境变量</th><th>说明</th></tr></thead><tbody><tr><td><strong>GOROOT</strong></td><td>指定 SDK 的安装路径</td></tr><tr><td><strong>Path</strong></td><td>添加 SDK 的 &#x2F;bin 目录</td></tr><tr><td><strong>GOPATH</strong></td><td>工作目录</td></tr></tbody></table><h5 id="Windows-下配置-Golang-环境变量过程"><a href="#Windows-下配置-Golang-环境变量过程" class="headerlink" title="Windows 下配置 Golang 环境变量过程"></a>Windows 下配置 Golang 环境变量过程</h5><ol><li><p>先打开环境变量配置界面：</p><ul><li>计算机 -&gt; 属性 -&gt; 高级系统设置 -&gt; 系统变量</li></ul></li><li><p>配置环境变量</p><ul><li><p>系统变量 -&gt; 新建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GOROOT</span><br><span class="line">D:\programfiles\go</span><br></pre></td></tr></table></figure></li><li><p>系统变量 -&gt; path -&gt; 编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;%GOROOT%\bin</span><br></pre></td></tr></table></figure></li><li><p>系统变量 -&gt; 新建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GOPATH</span><br><span class="line">D:\goproject</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Linux-下搭建-Go-开发环境-安装和配置-SDK"><a href="#Linux-下搭建-Go-开发环境-安装和配置-SDK" class="headerlink" title="Linux 下搭建 Go 开发环境-安装和配置 SDK"></a>Linux 下搭建 Go 开发环境-安装和配置 SDK</h3><h4 id="Linux-下-SDK-安装"><a href="#Linux-下-SDK-安装" class="headerlink" title="Linux 下 SDK 安装"></a>Linux 下 SDK 安装</h4><ol><li><p>Linux 下 SDK 的各个版本说明：</p><ul><li><p>Linux 下：根据系统是 32 位还是 64 位进行下载。</p></li><li><p>32 位系统：go.1.15.2.linux-386.tar.gz</p></li><li><p>64 位系统：go.1.15.2.linux-amd64.tar.gz</p></li></ul></li><li><p>请注意：安装路径不要有中文或者特殊符号如空格等。</p></li><li><p>SDK 安装目录建议：Linux 放在 &#x2F;opt 目录下。</p></li><li><p>安装时，解压即可。</p></li><li><p>详细步骤：</p><ul><li><p>将 SDK 安装文件传输到 ubuntu</p></li><li><p>将 SDK 安装文件拷贝到 &#x2F;opt 目录下</p></li><li><p>解压缩文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf 安装文件</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="Linux-下配置-Golang-环境变量过程"><a href="#Linux-下配置-Golang-环境变量过程" class="headerlink" title="Linux 下配置 Golang 环境变量过程"></a>Linux 下配置 Golang 环境变量过程</h4><ol><li>在 &#x2F;etc&#x2F;profile 文件下添加三条语句</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/opt/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/goproject</span><br></pre></td></tr></table></figure><ol start="2"><li>提示：修改 &#x2F;etc&#x2F;profile 文件，需要 root 权限。</li></ol><h3 id="Mac-下搭建-Go-开发环境-安装和配置-SDK"><a href="#Mac-下搭建-Go-开发环境-安装和配置-SDK" class="headerlink" title="Mac 下搭建 Go 开发环境-安装和配置 SDK"></a>Mac 下搭建 Go 开发环境-安装和配置 SDK</h3><h4 id="Mac-下-SDK-安装"><a href="#Mac-下-SDK-安装" class="headerlink" title="Mac 下 SDK 安装"></a>Mac 下 SDK 安装</h4><ol><li><p>Mac 下 SDK 的各个版本说明：</p><ul><li><p>Mac OS 下：只有 64 位的软件安装包</p></li><li><p>Mac OS 系统的安装包：go1.15.2.darwin-amd64.tar.gz</p></li></ul></li><li><p>请注意：安装路径不要有中文或者特殊符号如空格等。</p></li><li><p>SDK 安装目录建议：Mac 一般放在用户目录下 go_dev&#x2F;go 下</p></li><li><p>安装时，解压即可。</p></li><li><p>详细步骤：</p><ul><li><p>先将安装文件上传到 Mac 系统</p></li><li><p>在用户目录下创建目录 go_dev ，将上传的安装文件移动到 go_dev 下</p></li><li><p>解压安装文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf 安装文件</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="Mac-下配置-Golang-环境变量"><a href="#Mac-下配置-Golang-环境变量" class="headerlink" title="Mac 下配置 Golang 环境变量"></a>Mac 下配置 Golang 环境变量</h4><ol><li>在 &#x2F;etc&#x2F;profile 文件下添加三条语句</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=<span class="variable">$HOME</span>/go_dev/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/goproject</span><br></pre></td></tr></table></figure><ol start="2"><li>提示：修改 &#x2F;etc&#x2F;profile 文件，需要 root 权限。</li></ol><h2 id="Go-语言的开发步骤"><a href="#Go-语言的开发步骤" class="headerlink" title="Go 语言的开发步骤"></a>Go 语言的开发步骤</h2><h3 id="Windows-下开发步骤"><a href="#Windows-下开发步骤" class="headerlink" title="Windows 下开发步骤"></a>Windows 下开发步骤</h3><ol><li>安装 Windows 版本 VSCode 。</li><li>将 Go 代码编写到扩展名为 hello.go 的文件中。</li><li>目录结构：源码一般在工作目录 src&#x2F;go_code 下。</li><li>通过 go build 命令对该 go 文件进行编译，生成 .exe 文件。</li><li>在 dos 命令行下执行 .exe 文件就可以看到运行效果。</li><li>注意：通过 go run 命令可以直接运行 hello.go 程序。[类似执行一个脚本的形式]</li></ol><h3 id="Linux-下开发步骤"><a href="#Linux-下开发步骤" class="headerlink" title="Linux 下开发步骤"></a>Linux 下开发步骤</h3><ol><li>说明：Linux 下开发 go 和 Windows 开发基本是一样的。只是在运行可执行的程序时是以.&#x2F;文件名方式。</li><li>安装 Ubuntu 版本 VSCode ，或者直接使用 Vim 开发。</li><li>将 Go 代码编写到扩展名为 hello.go 的文件中。</li><li>通过 go build 命令对该 go 文件进行编译，生成可执行文件 hello 。</li><li>在终端执行 .&#x2F;hello 就可以看到运行效果。</li><li>注意：通过 go run 命令可以直接运行 hello.go 程序。</li></ol><h3 id="Mac-下开发步骤"><a href="#Mac-下开发步骤" class="headerlink" title="Mac 下开发步骤"></a>Mac 下开发步骤</h3><ol><li>说明：在 Mac 下开发 go 程序和 Windows 基本一样。</li></ol><h2 id="Golang-执行流程分析"><a href="#Golang-执行流程分析" class="headerlink" title="Golang 执行流程分析"></a>Golang 执行流程分析</h2><ol><li><p>.go 文件 -&gt; go build(编译) -&gt; 可执行文件 -&gt; 运行 -&gt; 结果</p></li><li><p>.go 文件 -&gt; go run(编译运行一步) -&gt; 结果</p></li><li><p>两种执行流程的方式区别说明：</p><ul><li><p>如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有 go 开发环境的机器上，仍然可以运行。</p></li><li><p>如果我们是直接 go run 源代码，那么如果在另一个机器上这么运行，也需要 go 开发环境，否则无法执行。</p></li><li><p>在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所有，可执行文件变大了很多。</p></li></ul></li></ol><h3 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h3><ol><li>有了 go 源文件，通过编译器将其编译成机器可以识别的二进码文件。</li><li>在该源文件目录下，通过 go build 对 hello.go 文件进行编译。可以指定生成的可执行文件名，Windows 下，必须是 .exe 后缀。</li><li>如果程序没有错误，没有任何提示，会在当前目录下出现一个可执行文件，该文件是二进码文件，也是可以执行的文件。</li><li>如果程序有错误，编译时，会在错误的那行报错。</li></ol><h3 id="什么是运行"><a href="#什么是运行" class="headerlink" title="什么是运行"></a>什么是运行</h3><ol><li>直接运行的可执行 Go 程序，比如 hello.exe 。</li><li>通过运行工具 go run 对可执行文件进行执行。</li></ol><h2 id="Go-程序开发注意事项"><a href="#Go-程序开发注意事项" class="headerlink" title="Go 程序开发注意事项"></a>Go 程序开发注意事项</h2><ol><li>Go 源文件以 go 为扩展名。</li><li>Go 应用程序的执行入口是 main() 方法</li><li>Go 语言严格区分大小写</li><li>Go 方法由一条条语句构成，每个语句后不需要分号，这体现了 Golang 的简洁性。</li><li>Go 编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，负责报错。</li><li>Go 语言定义的变量或者 import 的包如果没有使用到，代码不能编译通过。</li><li>大括号都是成对出现的，缺一不可。</li></ol><h2 id="Golang-常用的转义字符"><a href="#Golang-常用的转义字符" class="headerlink" title="Golang 常用的转义字符"></a>Golang 常用的转义字符</h2><ol><li>\t: 一个制表位，实现对齐的功能</li><li>\n: 换行符</li><li>\: 一个 \</li><li>\“: 一个 “</li><li>\r: 一个回车</li></ol><h2 id="Golang-开发常见问题和解决方法"><a href="#Golang-开发常见问题和解决方法" class="headerlink" title="Golang 开发常见问题和解决方法"></a>Golang 开发常见问题和解决方法</h2><ol><li><p>找不到文件</p><ul><li>解决方法: 源文件不存在或者写错，或者当前路径错误。</li></ul></li><li><p>小结和提示</p><ul><li><p>学习编程最容易犯的错误是语法错误。Go 要求你必须按照语法规则编写代码。如果你的程序违反了语法规则，例如：忘记了大括号、引号，或者拼错了单词，Go 编译器都会报语法错误。</p></li><li><p>要求：尝试着去看懂编译器会报告的错误信息。</p></li></ul></li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性。</li><li>注释是一个程序员必须要具有的良好编程习惯。</li><li>将自己的思想通过注释先整理出来，再用代码去实现。</li></ol><h3 id="Go-语言中的注释类型"><a href="#Go-语言中的注释类型" class="headerlink" title="Go 语言中的注释类型"></a>Go 语言中的注释类型</h3><ol><li><p>Go 支持 C 语言风格的&#x2F;* *&#x2F;块注释，也支持 C++ 风格的&#x2F;&#x2F;行注释。</p></li><li><p>行注释更通用，块注释主要用于针对包的详细说明或者屏蔽大块的代码。</p><ul><li><p>行注释</p></li><li><p>块注释(多行注释)</p></li></ul></li><li><p>使用细节</p><ul><li><p>对于行注释和块注释，被注释的文字，不会被 Go 编译器执行。</p></li><li><p>块注释里面不允许有块注释嵌套。</p></li></ul></li></ol><h3 id="规范的代码风格"><a href="#规范的代码风格" class="headerlink" title="规范的代码风格"></a>规范的代码风格</h3><h4 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h4><ol><li>Go 官方推荐使用行注释来注释整个方法和语句。</li><li>看源码。</li></ol><h4 id="正确的缩进和空白"><a href="#正确的缩进和空白" class="headerlink" title="正确的缩进和空白"></a>正确的缩进和空白</h4><ol><li>使用一次 tab 操作，实现缩进，默认整体向右边移动，可以用 shift+tab 整体向左移。</li><li>或者使用 gofmt 来进行格式化。</li><li>运算符两边习惯性各加一个空格。</li><li>一行最长不超过 80 个字符，超过的请使用换行展示，尽量保持格式优雅。</li></ol><h2 id="Golang-官方编程指南"><a href="#Golang-官方编程指南" class="headerlink" title="Golang 官方编程指南"></a>Golang 官方编程指南</h2><ol><li><a href="!https://golang.org/">Golang 官方网站</a>。</li><li><a href="!http://golang.org/pkg">Golang 官方标准库 API 文档</a>，可以查看 Golang 所有包下的函数和使用。</li><li>API：Application Program Interface(应用程序编程接口)，就是我们 Go 的各个包下的各个函数</li></ol><h3 id="Golang-标准库-API-文档"><a href="#Golang-标准库-API-文档" class="headerlink" title="Golang 标准库 API 文档"></a>Golang 标准库 API 文档</h3><ol><li>API 是 Golang 提供的基本编程接口。</li><li>Go 语言提供了大量的标准库，因此 Google 公司也为这些标准库提供了相应的 API 文档，用于告诉开发者如何使用这些标准库，以及标准库包含的方法。</li><li><a href="https://studygolang.com/pkgdoc">Golang 中文网的在线标准库文档</a>。</li></ol><h2 id="Dos-常用指令"><a href="#Dos-常用指令" class="headerlink" title="Dos 常用指令"></a>Dos 常用指令</h2><h3 id="Dos-的基本介绍"><a href="#Dos-的基本介绍" class="headerlink" title="Dos 的基本介绍"></a>Dos 的基本介绍</h3><ol><li>Dos：Disk Operating System 磁盘操作系统。</li></ol><h3 id="Dos-操作原理"><a href="#Dos-操作原理" class="headerlink" title="Dos 操作原理"></a>Dos 操作原理</h3><ol><li>cmd 发送指令 -&gt; Dos 操作系统 -&gt; Windows 的目录操作</li></ol><h3 id="目录操作指令"><a href="#目录操作指令" class="headerlink" title="目录操作指令"></a>目录操作指令</h3><ol><li>查看当前目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;<span class="built_in">dir</span></span><br></pre></td></tr></table></figure><ol start="2"><li>切换到其他盘</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;<span class="built_in">cd</span> /d f:</span><br></pre></td></tr></table></figure><ol start="3"><li>切换到当前盘的其他目录下(相对路径和绝对路径的区别)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;<span class="built_in">cd</span> d:\test100     <span class="comment"># 绝对路径切换</span></span><br><span class="line">d:\test100&gt;</span><br><span class="line">d:\test100&gt;<span class="built_in">cd</span> adc100  <span class="comment"># 相对路径切换</span></span><br><span class="line">d:\test100\abc100&gt;</span><br><span class="line">d:\test100\abc100&gt;<span class="built_in">cd</span> d:\test100 <span class="comment"># 绝对路径切换</span></span><br><span class="line">d:\test100&gt;<span class="built_in">cd</span> d:\test100\abc100 <span class="comment"># 绝对路径切换</span></span><br><span class="line">d:\test100\abc100&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>切换到上一级目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\test100\abc100&gt;<span class="built_in">cd</span> ..</span><br><span class="line">d:\test100&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>切换到根目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\test100&gt;<span class="built_in">cd</span> \</span><br><span class="line">d:\&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>新建目录 md</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d:\&gt;<span class="built_in">cd</span> test200</span><br><span class="line">d:\test200&gt;md ok200</span><br><span class="line">d:\test200&gt;md ok300 ok400 <span class="comment"># 新建多个目录</span></span><br></pre></td></tr></table></figure><ol start="7"><li>删除空目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\test200&gt;rd ok100</span><br><span class="line">d:\test200&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>删除目录以及下面的下面的子目录和文件，不带询问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:\test200&gt;rd /q/s ok200</span><br></pre></td></tr></table></figure><ol start="9"><li>删除目录以及下面的子目录和文件，带询问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:\test200&gt;rd /s ok300</span><br></pre></td></tr></table></figure><ol start="10"><li>新建或追加内容到文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d:\test200&gt;<span class="built_in">echo</span> hello &gt; d:\test100\abc.txt</span><br><span class="line">d:\test200&gt;</span><br><span class="line">d:\test200&gt;<span class="built_in">cd</span> d:\test100\abc</span><br><span class="line">d:\test200\abc100&gt;</span><br><span class="line">d:\test200\abc100&gt;<span class="built_in">echo</span> atguigu &gt; abc2.txt</span><br><span class="line">d:\test200\abc100&gt;</span><br></pre></td></tr></table></figure><ol start="11"><li>复制文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\test200\abc100&gt;copy abc.txt d:\test200</span><br><span class="line">d:\test200\abc100&gt;copy abc.txt d:\test200\ok.txt <span class="comment"># 复制并改名</span></span><br></pre></td></tr></table></figure><ol start="12"><li>移动文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:\test100\abc100&gt;move abc.txt f:\</span><br></pre></td></tr></table></figure><ol start="13"><li>删除文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\test100\abc100&gt;del abc2.txt</span><br><span class="line">d:\test100\abc100&gt;del *.txt <span class="comment"># 删除所有带 .txt 后缀文件</span></span><br></pre></td></tr></table></figure><ol start="14"><li>清屏</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure><ol start="15"><li>退出 Dos</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="课程来源"><a href="#课程来源" class="headerlink" title="课程来源"></a>课程来源</h2><ul><li><a href="http://www.atguigu.com/download_detail.shtml?v=232">尚硅谷 Go 核心编程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 Golang 开山篇</title>
      <link href="/post/2db18b60.html"/>
      <url>/post/2db18b60.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-开山篇"><a href="#Golang-开山篇" class="headerlink" title="Golang 开山篇"></a>Golang 开山篇</h1><h2 id="Golang-的学习方向"><a href="#Golang-的学习方向" class="headerlink" title="Golang 的学习方向"></a>Golang 的学习方向</h2><ol><li>Go 语言，可以简单的写成 Golang。</li><li>Golang 语言的学习方向：区块链研发工程师、Go 服务器端游戏软件工程师、Golang 分布式&#x2F;云计算软件工程师。</li></ol><h2 id="Golang-的应用领域"><a href="#Golang-的应用领域" class="headerlink" title="Golang 的应用领域"></a>Golang 的应用领域</h2><h3 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h3><ol><li>区块链技术，简称BT(Blockchain technology)，也被称之为分布式账本技术，是一种互联网数据库技术，其特点是去中心化、公开透明，让每个人均可参与数据库记录。</li></ol><h3 id="后端服务器应用"><a href="#后端服务器应用" class="headerlink" title="后端服务器应用"></a>后端服务器应用</h3><h4 id="美团后台流量支撑程序"><a href="#美团后台流量支撑程序" class="headerlink" title="美团后台流量支撑程序"></a>美团后台流量支撑程序</h4><ol><li>支撑主站后台流量(排序、推荐、搜索等)，提供负载均衡、cache、容错，按条件分流，统计运行指标(qps, latency)等功能。</li></ol><h4 id="仙侠道"><a href="#仙侠道" class="headerlink" title="仙侠道"></a>仙侠道</h4><ol><li>应用范围：游戏服务端(通讯、逻辑、数据存储)。</li></ol><h3 id="云计算-x2F-云服务后台应用"><a href="#云计算-x2F-云服务后台应用" class="headerlink" title="云计算&#x2F;云服务后台应用"></a>云计算&#x2F;云服务后台应用</h3><h4 id="盛大云-CDN"><a href="#盛大云-CDN" class="headerlink" title="盛大云 CDN"></a>盛大云 CDN</h4><ol><li>应用范围：CDN 的调度系统、分发系统、监控系统、短域名服务，CDN 内部开放平台、运营报表系统以及其他一些小工具等。</li></ol><h4 id="京东消息推送云服务-x2F-京东分布式文件系统"><a href="#京东消息推送云服务-x2F-京东分布式文件系统" class="headerlink" title="京东消息推送云服务&#x2F;京东分布式文件系统"></a>京东消息推送云服务&#x2F;京东分布式文件系统</h4><ol><li>应用范围：后台所有服务全部用 Golang 实现。</li></ol><h2 id="Golang-的学习方法"><a href="#Golang-的学习方法" class="headerlink" title="Golang 的学习方法"></a>Golang 的学习方法</h2><ol><li>高效而愉快的学习。</li><li>先建立一个整体框架，然后细节。</li><li>在实际工作中，要培养用到什么，能够快速学习什么能力。</li><li>先 know how ，再 know why 。</li><li>软件编程是一门“做中学”的学科，不是会了再做，而是做了才会。</li><li>适当的囫囵吞枣。</li><li>学习软件编程是在琢磨别人怎么做，而不是我认为应该怎么做的过程。</li></ol><h2 id="学习新技术的方法"><a href="#学习新技术的方法" class="headerlink" title="学习新技术的方法"></a>学习新技术的方法</h2><ol><li>步骤一</li></ol><ul><li><p>有一个需求：项目开发时，我们需要解决某个问题。【页面局部刷新问题】</p></li><li><p>跳槽学习新技术</p></li></ul><ol start="2"><li>步骤二</li></ol><ul><li><p>先看看使用现有的技术能否解决这个问题。【页面局部刷新问题】</p></li><li><p>使用传统的方法解决问题不够好。</p></li><li><p>使用新技术 -&gt; ajax</p></li></ul><ol start="3"><li>步骤三</li></ol><ul><li>学习一下新技术或者知识点的原理和基础语法。</li></ul><ol start="4"><li>步骤四</li></ol><ul><li><p>学习快速入门案例：需要案例简单，了解新技术或者知识点的基本使用。</p></li><li><p>这里不需要涉及技术细节。</p></li></ul><ol start="5"><li>步骤五</li></ol><ul><li><p>讨论这个新技术或者知识点的细节</p></li><li><p>其中包括怎么使用更规范、了解使用的陷阱，需要使用时，注意什么。</p></li><li><p>这最体现一个程序员水平。</p></li></ul><h2 id="课程来源"><a href="#课程来源" class="headerlink" title="课程来源"></a>课程来源</h2><ul><li><a href="http://www.atguigu.com/download_detail.shtml?v=232">尚硅谷 Go 核心编程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十六章 网络</title>
      <link href="/post/2f93ff5d.html"/>
      <url>/post/2f93ff5d.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十六章-网络"><a href="#第十六章-网络" class="headerlink" title="第十六章 网络"></a>第十六章 网络</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在网络连接方面，Linux 可以说是万能的。Linux 工具可以建立各种网络系统及应用，包括防火墙、路由器、域名服务器、NAS (网络附加存储) 盒等。</li><li>由于网络连接涉及的领域很广，所以用于控制、配置网络的命令自然很多。本章只着重讲一些经常用到的命令，涉及网络监测以及文件传输等方面。此外，我们还会探讨一下用于远程登录的 ssh 命令，所涉及的命令如下所示：</li></ol><ul><li>ping: 向网络主机发送 ICMP ECHO_REQUEST 数据包。</li><li>traceroute: 显示数据包到网络主机的路由路径。</li><li>netstat: 显示网络连接、路由表、网络接口数据、伪连接以及多点传送成员等信息。</li><li>ftp: 文件传输命令</li><li>lftp: 改善后的文件传输命令</li><li>wget: 非交互式网络下载器</li><li>ssh: OpenSSH (SSH 协议的免费开源实现) 版的 SSH 客户端 (远程系统登录命令) </li><li>scp: secure copy 的缩写，是远程复制文件命令</li><li>sftp: secure file transfer program 的缩写，安全文件传输程序。</li></ul><ol start="3"><li>便于更好地理解本章内容，首先熟悉下面的术语：</li></ol><ul><li>IP (Internet protocol)  address: 互联网协议地址</li><li>host and domain name: 主机名和域名</li><li>URL (uniform resource identifier) : 统一资源标识符</li></ul><h2 id="检查、监测网络"><a href="#检查、监测网络" class="headerlink" title="检查、监测网络"></a>检查、监测网络</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>即使你不是系统管理员，经常检验网络的性能和运行情况也是有必要的。</li></ol><h3 id="ping-向网络主机发送特殊数据包"><a href="#ping-向网络主机发送特殊数据包" class="headerlink" title="ping - 向网络主机发送特殊数据包"></a>ping - 向网络主机发送特殊数据包</h3><ol><li>基本介绍</li></ol><ul><li>最基本的网络连接命令就是 ping 命令。</li><li>ping 命令会向指定的网络主机发送特殊网络数据包 TMCP ECHO_REQUEST 。</li><li>多数网络设备收到该数据后会做出回应，通过此法即可验证网络连接是否正常。</li><li>有时从安全角度出发，通常会配置部分网络通信设备 (包括 Linux 主机) 以忽略这些数据，因为这样可以降低主机遭受潜在攻击者攻击的可能性。当然，防火墙经常被设置为阻碍 IMCP 通信。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ ping linuxcommand.org</span><br></pre></td></tr></table></figure></li><li>一旦程序启动，ping 命令便以既定的时间间隔 (默认是 1s) 传送数据包直到该命令被中断。</li><li>按 Ctrl-C 键终止 ping 程序，ping 程序会将反映运行情况的数据显示出来。</li><li>数据包丢失 0% 表示网络运行正常，ping 连接成功则表明网络各组成员 (接口卡、电缆、路由和网关) 总体处于良好的工作状态。</li></ul><h3 id="traceroute-跟踪网络数据包的传输路径"><a href="#traceroute-跟踪网络数据包的传输路径" class="headerlink" title="traceroute - 跟踪网络数据包的传输路径"></a>traceroute - 跟踪网络数据包的传输路径</h3><ol><li>traceroute 程序会显示文件通过网络从本地系统传输到指定主机过程中所有停靠点的列表。</li><li>下例列出了数据在连接到网站 <a href="http://www.slashdot.org/">http://www.slashdot.org/</a> 时所经过的站点。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ traceroute slashdot.org</span><br><span class="line">traceroute to slashdot.org (204.68.111.106), 64 hops max</span><br><span class="line">  1   172.28.12.254  32.202ms  2.022ms  4.433ms</span><br><span class="line">  2   172.28.2.1  1.186ms  1.203ms  1.136ms</span><br><span class="line">  3   163.179.126.1  12.905ms  16.726ms  11.037ms</span><br><span class="line">  4   120.80.202.153  25.712ms  53.734ms  92.284ms</span><br><span class="line">  5   120.82.0.185  356.589ms  173.631ms  66.899ms</span><br><span class="line">  6   *  *  *</span><br><span class="line">  7   219.158.24.138  22.680ms  15.104ms  25.731ms</span><br><span class="line">  8   219.158.96.30  307.990ms  409.480ms  188.871ms</span><br><span class="line">  9   173.241.128.49  220.247ms  409.948ms  175.224ms</span><br><span class="line"> 10   89.149.128.174  203.034ms  235.967ms  409.685ms</span><br><span class="line"> 11   69.174.7.78  409.548ms  200.562ms  185.809ms</span><br><span class="line"> 12   108.162.214.200  227.594ms  189.263ms  176.557ms</span><br><span class="line"> 13   172.69.32.222  188.186ms  174.306ms  192.125ms</span><br><span class="line"> 14   *  *  *</span><br><span class="line"> 15   204.68.111.106  175.580ms  181.934ms  177.909ms</span><br><span class="line"> 16   slashdot.org (204.68.111.106), 42.727 ms  42.016 ms  41.437 ms</span><br></pre></td></tr></table></figure></li><li>可以从结果知道从测试系统到 <a href="http://www.slashdot.org/">http://www.slashdot.org/</a> 网站的连接需要经过 16 个路由器。</li><li>对于那些提供身份信息的路由器，结果中列出了他们的主机名、 IP 地址以及运行状态信息，这些信息包含了文件从本地系统到路由器 3 次往返时间。</li><li>而对于那些因为路由器配置、网络堵塞或是防火墙等原因不提供身份信息的路由器，则直接用星号行表示。</li></ol><h3 id="netstat-检查网络设置及相关统计数据"><a href="#netstat-检查网络设置及相关统计数据" class="headerlink" title="netstat - 检查网络设置及相关统计数据"></a>netstat - 检查网络设置及相关统计数据</h3><ol><li>基本介绍</li></ol><ul><li>netstat 程序可以用于查看不同的网络设置及数据。通过使用其丰富的参数选项，我们可以查看网络启动过程的许多特性。</li></ul><ol start="2"><li>案例一</li></ol><ul><li>使用 -ie 选项，我们可以检查系统中的网络接口信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ netstat -ie</span><br><span class="line">eth0    Link encap:Ethernet HWadder 00:1d:09:9b:99:67</span><br><span class="line">        inet addr: 192.168.1.255 Mask:255.255.255.0</span><br><span class="line">        inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link</span><br><span class="line">        UP BROADCAST RUNNING MULTICAST MTU: 1500 Metric:1</span><br><span class="line">        RX Pckets:238488 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">        TX packets:403217 erors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">        collisions;0 txqueuelan:100</span><br><span class="line">        RX bytes:153098921 (146.0MB) TX bytes:261035246 (248.9)</span><br><span class="line">        Memory: fefcoooo -fdfe0000</span><br><span class="line">        </span><br><span class="line">        Link encap:<span class="built_in">local</span> LooPback</span><br><span class="line">        inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line">        inet6 addr: ::1/128 Scope:Host</span><br><span class="line">        UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line">        RX packets:2208 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">        TX packets:2208 errors:0</span><br><span class="line">        dropped:0 overruns:0 carrier:0 collision:0 txqueuelen:0</span><br><span class="line">        RX bytes:111490 (108.8 KB) Tx bytes:111490 (108.8KB)</span><br></pre></td></tr></table></figure></li><li>以上的输出信息显示，测试系统有两个网络端口：第一个称为 eth0 ，是以太网端口；第二个称为 10 ，是系统用来访问自己的回环虚拟接口。</li><li>对网络进行日常诊断，关键是看能否在每个接口信息第四行的开头找到 UP 这个词以及能否在第二行的 inet addr 字段找到有效的 IP 地址。</li><li>第四行的 UP 代表着该网络接口已启用，而对于使用动态主机配置协议的系统 (DHCP) ，inet addr 字段里面的有效 IP 地址则说明了 DHCP 正在工作。</li></ul><ol start="3"><li>案例二</li></ol><ul><li>使用 -r 选项将显示内核的网络路由表，此表显示了网络之间传送数据包时网络的配置情况。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ netstat -r</span><br><span class="line">kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags MSS Window irtt Iface</span><br><span class="line">192.168.1.0 *       255.255.255.0 U 0     0     0  eth0    default</span><br><span class="line">192.168.1.1 0.0.0.0 UG 0 0 0 eth0</span><br></pre></td></tr></table></figure></li><li>此例显示的是运行在防火墙&#x2F;路由器后面的局域网 (LAN) 上一客户端的典型路由表。</li><li>该表的第一行表示接收方式的IP地址为 192.168.1.0 ，IP 以 0 结尾表示接收方是网络而非个人主机，也就是说接收方可以是局域网 (LAN) 上的任何主机。</li><li>下面的 Gateway 参数字段，表示的是建立当前主机与目标网络之间联系的网关 (或路由) 的名称或 IP 地址，此参数值是星号表示无需网关。</li><li>最后一行包含默认的接收方，这意味着所有通信都以该网络为目的地。</li><li>上例中，网关被定义为 IP 地址是 192.168.1.1 的路由器，该路由器对双方通信做出最佳路径判断。</li><li>netstat 程序也有很多参数选项，而以上只列举了其中两个，要了解其整个参数列表可以查看 netstat 的 man 手册页。</li></ul><h2 id="通过网络传输文件"><a href="#通过网络传输文件" class="headerlink" title="通过网络传输文件"></a>通过网络传输文件</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>只有掌握了如何通过网络转移文件，才会明白网络的作用之大。有许多命令可用于传送网络数据，现在我们就介绍其中的两个，后续章节将会介绍更多。</li></ol><h3 id="ftp-采用-FTP-文件传输协议-传输文件"><a href="#ftp-采用-FTP-文件传输协议-传输文件" class="headerlink" title="ftp - 采用 FTP (文件传输协议) 传输文件"></a>ftp - 采用 FTP (文件传输协议) 传输文件</h3><ol><li>基本介绍</li></ol><ul><li>ftp 是 Linux 比较经典的命令之一，由 File Transfer Protocol 协议缩写而来。</li><li>ftp 用作下载文件工具在因特网上使用很广泛，大多数 Web 浏览器都支持 ftp 命令。</li><li>ftp 程序比 Web 浏览器出现得更早，它用来与 FTP 服务器进行通信，所谓 FTP 服务器就是安歇包含供网络上传、下载文件的机器。</li><li>FTP (原来的表示形式) 并不安全，因为它以明文的方式传送账户名以及密码。这意味着这些信息并没有加密，任何一个接触网络的人都能看到它们。</li><li>鉴于此，几乎所有使用 FTP 协议进行的网络文件传输都是由匿名 FTP 服务器处理的。</li><li>匿名服务器允许任何人使用 anonymous 登录名以及无意义的密码登录。</li></ul><ol start="2"><li>ftp 命令实例</li></ol><table><thead><tr><th align="center">命令</th><th align="center">代表的含义</th></tr></thead><tbody><tr><td align="center">ftp fileserver</td><td align="center">启动 ftp 程序，建立与 FTP 服务器 fileserver 的连接</td></tr><tr><td align="center">anonymous</td><td align="center">登录名，登录提示框出现之后就是密码输入有提示框。一些服务器可以接受空白密码，其他的则要求密码以邮件地址的形式。在那样的情况修改，就尝试 <a href="mailto:&#x75;&#x73;&#101;&#x72;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x75;&#x73;&#101;&#x72;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a> 这样的格式</td></tr><tr><td align="center">cd pub&#x2F;cd_images&#x2F;Ubuntu-8.04</td><td align="center">打开远程系统上含有所需文件的目录。注意，对于多数匿名服务器，供公开下载的文件一般存放在 pub 目录下</td></tr><tr><td align="center">ls</td><td align="center">列出远程系统上的目录列表</td></tr><tr><td align="center">lcd Desktop</td><td align="center">切换至本地系统的 Desktop 目录。本例中，ftp 程序是在 home 目录下启动的，此命令行将工作目录切换至 Desktop 下，映像文件也会下载到该目录下</td></tr><tr><td align="center">bye</td><td align="center">注销登录远程服务器并且结束 ftp 程序。也可以使用 quit 或 exit 命令代替</td></tr></tbody></table><ol start="3"><li>ftp 补充说明</li></ol><ul><li>在提示符 ftp&gt; 后面输入 help 会显示 ftp 所支持的命令列表。在已被授予足够权限的服务器上使用 ftp 命令，可以执行许多常见的文件管理任务。</li></ul><h3 id="lftp-更好的-ftp"><a href="#lftp-更好的-ftp" class="headerlink" title="lftp - 更好的 ftp"></a>lftp - 更好的 ftp</h3><ol><li>ftp 并不是唯一的命令行 FTP 客户端。事实上，有很多这样的命令行。</li><li>其中更好用也更受欢迎的一个就是由 ALexander Lukyanov 编写的 lftp 命令，它与传统的 ftp 程序功能类似但却有很多额外的便利功能，包括多协议支持 HTTP、下载失败时自动重新尝试、后台进程支持、Tab 键完成文件名输入等许多其他的功能。</li></ol><h3 id="wget-非交互式网络下载工具"><a href="#wget-非交互式网络下载工具" class="headerlink" title="wget - 非交互式网络下载工具"></a>wget - 非交互式网络下载工具</h3><ol><li>wget 是另一个用于文件下载的命令行程序。该命令既可以用于从网站上下载内容也可以用于从 FTP 站点下载，单个文件、多个文件甚至整个网站都可以被下载。</li><li>下例演示的就是用 wget 命令下载网站 <a href="http://www.linuxcommand.org/">http://www.linuxcommand.org/</a> 第一页内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ wget http://linuxcommand.org/index.php</span><br></pre></td></tr></table></figure></li><li>wget 命令的许多参数选项支持递归下载、后台文件下载以及继续下载部分被下载的文件等操作。</li></ol><h2 id="与远程主机的安全通信"><a href="#与远程主机的安全通信" class="headerlink" title="与远程主机的安全通信"></a>与远程主机的安全通信</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>多年以前，类 UNIX 操作系统就可以通过网络进行远程操控。</li><li>早期，在互联网还未普及的时候，登录远程主机有两个很受欢迎的命令 -rlogin 和 telnet 命令。</li><li>它们与 ftp 命令有着相同的致命缺点，及所有通信信息 (包括用户名和密码) 都是以明文的方式传输的，所以它们并不适用于互联网时代。</li></ol><h3 id="ssh-安全登录远程计算机"><a href="#ssh-安全登录远程计算机" class="headerlink" title="ssh - 安全登录远程计算机"></a>ssh - 安全登录远程计算机</h3><ol><li>ssh 基本介绍</li></ol><ul><li>为了解决明文传送的问题，一个叫做 SSH (Secure Shell) 的缩写的新协议应运而生。</li><li>SSH 协议解决了与远程主机进行安全通信的两个基本问题：第一，该协议能验证远程主机的身份是否属实，从而避免中间人攻击；第二，该协议将本机与远程主机之间的通信内容全部加密。</li><li>SSH 协议包括两个部分：一个试运行在远程主机上的 SSH 服务端，用来监听端口 22 上可能过来的连接请求；另一个是本地系统上的 SSH 客户端，用来与远程服务器进行通信。</li><li>多数 Linux 发行版都采用 BSD 项目的 openSSH ( SSH 的免费开源实现) 方法实现 SSH 。</li><li>有些发行版如 Red Hat 会默认包含客户端包和服务端包，而有的版本如 Ubuntu 则仅仅提供客户端包。系统想要接收远程连接，就必须安装、配置以及运行 OpenSSH-server 软件包，并且必须允许 TCP 端口 22 上进来的网络连接 (当服务器正在运行防火墙或是在防火墙后面时) 。</li><li>如果没有可以连接的远程系统但却要尝试本例，可以在系统已安装了 OpenSSH-server 软件包的基础上将远程主机名设为本地主机名，这样，机器便会与自身建立网络连接。</li><li>ssh 命令作为 SSH 客户端程序用于建立与远程 SSH 服务器之间的通信再合适不过了。</li></ul><ol start="2"><li>案例</li></ol><ul><li>如下便是使用 ssh 客户端程序来件与远程主机 remote-sys 的链接的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh remote-sys</span><br><span class="line">The authenticity of host <span class="string">&#x27;remote-sys(192.168.1.4)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA Key fingerprint is 41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting(yes/no)?</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>第一次尝试连接的时候，由于 ssh 程序从来没有接触过此远程主机，所以会跳出一条不能确定远程主机真实性的消息。当出现这条警告消息的时候输入 yes 接受远程主机的身份，一旦建立连接，会提示用户输入密码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: Permanently added <span class="string">&#x27;remote-sys,192.168.1.4&#x27;</span> (RSA) to the list of known hosts.</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br></pre></td></tr></table></figure></li><li>密码输入正确后，远程系统的 shell 提示符便出现了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Aug 13:00:48 2011</span><br><span class="line">[me@remote-sys ~]$</span><br></pre></td></tr></table></figure></li><li>远程 shell 对话将一直开启着，直到用户在该对话框中输入 exit 命令断开与远程系统的连接。连接一旦断开后，本地 shell 会话恢复，本地 shell 提示符又重新出现。</li><li>使用非本地系统上使用的用户名也可以登录远程系统。例如，当本地用户 me 在远程系统上有一个 bob 账户，me 用户就可以用下面的命令登录远程系统上的 bob 账户。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh bob@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">Last login: Tue Aug 30 13:03:21 2011</span></span><br><span class="line"><span class="string">[bob@remote-sys ~]$</span></span><br></pre></td></tr></table></figure></li><li>ssh 命令会验证远程主机的真实性。如果远程主机没有成功验证，就会跳出警告信息。</li></ol><h2 id="scp-安全传输文件"><a href="#scp-安全传输文件" class="headerlink" title="scp - 安全传输文件"></a>scp - 安全传输文件</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>OpenSSH 软件包包含了两个使用 SSH 加密隧道进行网络间文件复制的程序，scp 便是其中之一。</li><li>该命令与普通的文件复制命令 cp 类似，而他们之间最大的差别在于 scp 命令的源或是目地路径前面多个远程主机号和冒号。</li><li>案例</li></ol><ul><li>下面的例子实现了从 remote-sys 远程系统的 home 目录中将 document.txt 文件复制到本地系统当前工作目录下的操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ scp remote-sys:document.txt .</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">document.txt</span></span><br><span class="line"><span class="string">[me@linuxbox ~]$</span></span><br></pre></td></tr></table></figure></li><li>与 ssh 命令一样，如果不是用本地系统的用户名登录远程系统，那么久需在远程主机名前添加将要登录的远程系统的账户名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ scp bob@remote-sys:document.txt .</span><br></pre></td></tr></table></figure></li></ul><h2 id="sftp-安全传输文件"><a href="#sftp-安全传输文件" class="headerlink" title="sftp - 安全传输文件"></a>sftp - 安全传输文件</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>另外一个 SSH 文件复制程序是 sftp 。</li><li>sftp 是 ftp 程序的安全版本，sftp 与我们先前使用的 ftp 程序功能极为相似，只是 sftp 是用 SSH 加密隧道传输信息而不是以明文方式传输。</li><li>sftp 相比传统的 ftp 而言，还有一个重要的优点，就是它并不需要远程主机运行 FTP 服务器，仅仅需要 SSH 服务器，这就意味着任何与 SSH 客户端连接的远程机器都可以当作 FTP 服务器使用。</li><li>案例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sftp remote-sys</span><br><span class="line">Connecting to remote-sys ...</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">sftp&gt; ls</span></span><br><span class="line"><span class="string">ubuntu-8.04-desktop-i386.iso</span></span><br><span class="line"><span class="string">sftp&gt; lcd Desktop</span></span><br><span class="line"><span class="string">sftp&gt; get ubuntu-8.04-desktop-i386.iso</span></span><br><span class="line"><span class="string">Fetching /home/me/ubuntu-8.04-desktop-i386.iso to ubuntu-8.04-desktop-i386.iso</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/home/me/ubuntu-8.04-desktop-i386.iso 100% 699MB 7.4MB/s 01:35</span></span><br><span class="line"><span class="string">sftp&gt;bye</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四章 软件包管理</title>
      <link href="/post/4decfb84.html"/>
      <url>/post/4decfb84.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-软件包管理"><a href="#第十四章-软件包管理" class="headerlink" title="第十四章 软件包管理"></a>第十四章 软件包管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>软件包管理是一种在系统上安装、维护软件的方法。目前，很多人通过安装 Linux 经销商发布的软件包来满足他们所有的软件需求。</li><li>这与早期的 Linux 形成鲜明的对比。因为在 Linux 早期，想要安装软件必须先下载源代码，然后对齐进行编译。这并不是说编译源代码不好，源代码公开恰是 Linux 吸引人的一大亮点。</li><li>编译源代码赋予用户自主检查、提升系统的能力，只是使用预先编译的软件包会更快、更容易些。</li><li>本章会介绍一些用于 Linux 软件包管理的命令行工具。虽然所有主流的 Linux 发行版本都提供了强大而复杂的维持系统运行的图形化界面操作程序，但学习命令行程序同样重要，因为它可以执行许多图形化程序很难甚至无法完成的任务。</li></ol><h2 id="软件包系统"><a href="#软件包系统" class="headerlink" title="软件包系统"></a>软件包系统</h2><ol><li>基本介绍</li></ol><ul><li>不同的 Linux 发行版用的是不同的软件包系统，并且原则上，适用于一种发行版的软件包与其他版本是不兼容的。多数 Linux 发行版采用的不外乎两种软件包技术阵容，即 Debian 的 .deb 技术和 Red Hat 的 .rpm 技术。当然也有一些特例，比如 Gentoo、Slackware 和 Foresight 等。</li></ul><ol start="2"><li>主流软件包系统类</li></ol><table><thead><tr><th align="center">软件包系统</th><th align="center">发行版本(只列举了部分)</th></tr></thead><tbody><tr><td align="center">Debian 类 (.deb 技术)</td><td align="center">Debian、Ubuntu、Xandros、Linspire</td></tr><tr><td align="center">Red Hat 类 (.rpm 技术)</td><td align="center">Fedora、CentOS、Red Hat Enterprise Linux、OpenSUSE、Mandriva、PCLinuxOS</td></tr></tbody></table><h2 id="软件包系统工作方式"><a href="#软件包系统工作方式" class="headerlink" title="软件包系统工作方式"></a>软件包系统工作方式</h2><ol><li>基本介绍</li></ol><ul><li>在非开源软件产业中，给系统安装一个新的应用，通常先购买安装光盘之类的安装介质，然后运行安装向导进行安装。</li><li>Linux 并不是这样。事实上，Linux 系统所有软件均可在网上找到，并且多数以软件包文件的形式由发行商提供，其余则可以手动安装的源代码形式存在。</li></ul><ol start="2"><li>软件包文件</li></ol><ul><li>包文件是组成软件包系统的基本软件单元，它是由组成软件包的文件压缩而成的文件集。 </li><li>一个包可能包含大量的程序以及支持这些程序的数据文件，包文件既包含了安装文件，又包含了有关包自身及其内容的文本说明之类的软件包元数据。此外，许多软件包中还包含了安装软件包前后执行配置任务的安装脚本。 </li><li>包文件通常由软件包维护者创建，该维护者通常 (并不总是) 是发行商的职员。包维护者从上游供应商 (一般是程序的作者) 获得软件源代码，然后进行编译，并创建包的元数据及其他必须的安装脚本。 </li><li>通常，包维护者会在初始源代码上做了部分修改，从而提高了该软件包与该 Linux 发行版本其他部分的兼容性。</li></ul><ol start="3"><li>库</li></ol><ul><li>虽然一些软件项目选择自己包装和分销，但如今多数软件包均由发行商或感兴趣的第三方创建。Linux 用户可以从其所使用的 linux 版本的中心库中获得软件包。 </li><li>所谓的中心库，一般包含了成千上万个软件包，而且每一个都是专门为该发行版本建立和维护的。 </li><li>在软件开发生命周期的不同阶段，一个发行版本可能会维护多个不同仓库。 </li><li>例如，通常会有一个测试库，该库里面存放的是刚创建的、用于调试在软件包正式发布前查找漏洞的软件包。 </li><li>另外，一个发行版通常还会由一个开发库，存放的是下一个公开发行的版本中所包含的开发中软件包。 </li><li>一个发行版本可能还会有相关的第三方库，这些库通常提供因法律原因，如专享礼或数字版权管理 (DRM) 等反规避问题而不能包括在发行版本中的软件。 </li><li>第三方库主要用在软件专利和反规避法不适用的国家，这些库通常完全独立于他们所支持的 Linux 版本，用户必须充分了解后手动将其加入到软件包文件管理系统的配置文件中，才能使用他们。</li></ul><ol start="4"><li>依赖关系</li></ol><ul><li>几乎没有任何一个程序式独立的。与之相反，程序之间相互依赖彼此完成既定工作。</li><li>一些共有的操作，比如共有的操作，比如输入&#x2F;输出操作，就是由多个程序共享的历程执行。这些例程存储在共享库里面，共享库里面的文件为了多个文件程序提供必要的服务。 </li><li>如果一个软件包需要共享库之类的共享资源，说明其具有依赖性。 </li><li>现代软件包管理系统都提供依赖性解决策略，从而确保用户安装了软件包的同时也安装了其所有的依赖关系。</li></ul><ol start="5"><li>高级和低级软件包工具</li></ol><ul><li>软件包管理系统通常包含两类工具-执行如安装、删除软件包文件等任务的低级的低级工具和进行元数据索索及提供依赖性解决的高级工具。 </li><li>本章将要介绍 Debian 类型的系统 (如 Ubuntu 等类似系统) 所提供的软件包安装工具。 </li><li>尽管所有 Red-Hat 系列版本都是使用相同的低级工具 (.rpm) ，但使用的高级工具却不尽不同。 </li><li>下面我们将讨论高级软件包工具 yum 程序，它为高级 Fedora 、Red Hat Enterprise Linux (红帽企业版 Linux) 和 CentOS 等系统所用，而其他 Red Hat 系列的发行版本也提供功能与之相媲美的高级工具。</li></ul><ol start="6"><li>软件包系统工具</li></ol><table><thead><tr><th align="center">发行版本</th><th align="center">低级工具</th><th align="center">高级工具</th></tr></thead><tbody><tr><td align="center">Debian 类</td><td align="center">dpkg</td><td align="center">apt-get、aptitude</td></tr><tr><td align="center">Fedora、Red Hat Enterprise、CentOS</td><td align="center">rpm</td><td align="center">yum</td></tr></tbody></table><h2 id="常见软件包管理任务"><a href="#常见软件包管理任务" class="headerlink" title="常见软件包管理任务"></a>常见软件包管理任务</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>命令行软件包管理工具可以完成许多操作，下面我们介绍一些较常见的。</li><li>有一点要说明，低级工具也支持软件包文件的创建，但不在本书讨论范围内。</li></ol><h3 id="在库里面查找软件包"><a href="#在库里面查找软件包" class="headerlink" title="在库里面查找软件包"></a>在库里面查找软件包</h3><ol><li>基本介绍</li></ol><ul><li>通过使用高级工具来搜索库元数据时，我们可以根据包文件名或其描述来查看该包。</li></ul><ol start="2"><li>包搜索命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">apt-get update</td></tr><tr><td align="center"></td><td align="center">apt-cache search search_string</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">yum search  search_string</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>例如，在 Red Hat 系统的 yum 库中搜索 emac 文本编辑器的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search emacs</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装库中的软件包"><a href="#安装库中的软件包" class="headerlink" title="安装库中的软件包"></a>安装库中的软件包</h3><ol><li>软件包安装命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令行</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">apt-get update</td></tr><tr><td align="center"></td><td align="center">apt_get install package_name</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">yum install package_name</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，在 Debian 系统上安装 apt 元数据库中的 emacs 文本编辑器的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update;apt-get install emacs</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装软件包文件中的软件包"><a href="#安装软件包文件中的软件包" class="headerlink" title="安装软件包文件中的软件包"></a>安装软件包文件中的软件包</h3><ol><li>低级软件包安装命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">dpkg –install package_file</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">rpm -i package_file</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，当 emacs-22.1-7.fc7-i386.rpm 软件包文件从非库资源网站下载时，可采用如下方式安装于 Red Hat 系统中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i emacs-22.1-7.fc7-i386.rpm</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>补充说明</li></ol><ul><li>由于该方法采用低级 rpm 工具安装，所以并不会解决依赖性关系。一旦 rpm 在安装过程中发现缺少依赖包，rpm 就会跳出错误后退出。</li></ul><h3 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h3><ol><li>软件包移除命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">apt-get remove package</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">yum erase package_name</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，从 Debian 系统中卸载 emacs 软件包的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove emacs</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新库中的软件包"><a href="#更新库中的软件包" class="headerlink" title="更新库中的软件包"></a>更新库中的软件包</h3><ol><li>软件包更新命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">apt-get update;apt-get upgrade</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">yum update</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，更新所有已安装于 Debian 系统中的可更新软件包的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update; apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新软件包文件中的软件包"><a href="#更新软件包文件中的软件包" class="headerlink" title="更新软件包文件中的软件包"></a>更新软件包文件中的软件包</h3><ol><li>低级软件包更新命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">dpkg –install package_file</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">rpm -U package_file</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，将 Red Hat 上已经安装好的 emacs 程序更新为 emacs-22.1-7.fc7-i386.rpm 软件包文件中的版本的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -U emacs-22.1-7.fc7-i386.rpm</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>补充说明</li></ol><ul><li>与 rpm 命令不同，dpkg 命令在更新软件包时并没有指定的参数选项，只有在安装软件包时才有。</li></ul><h3 id="列出已安装的软件包列表"><a href="#列出已安装的软件包列表" class="headerlink" title="列出已安装的软件包列表"></a>列出已安装的软件包列表</h3><ol><li>软件包列表命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">dpkg –list</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">rpm -qa</td></tr></tbody></table><h3 id="判断软件包是否安装"><a href="#判断软件包是否安装" class="headerlink" title="判断软件包是否安装"></a>判断软件包是否安装</h3><ol><li>软件包状态命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">dpkg –status package_name</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">rpm -q package_name</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，判断 emacs 程序包在 Debian 系统中是否安装的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --status emacs</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看某具体文件由哪个软件包安装得到"><a href="#查看某具体文件由哪个软件包安装得到" class="headerlink" title="查看某具体文件由哪个软件包安装得到"></a>查看某具体文件由哪个软件包安装得到</h3><ol><li>查询文件所属命令</li></ol><table><thead><tr><th align="center">系统类型</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">Debian 系统</td><td align="center">dpkg –search file_name</td></tr><tr><td align="center">Red Hat 系统</td><td align="center">rpm -qf file_name</td></tr></tbody></table><ol start="2"><li>案例</li></ol><ul><li>例如，查看 Red Hat 系统中哪个软件包安装了 &#x2F;usr&#x2F;bin&#x2F;vim 目录下的文件的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf /sur/bin/vim</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五章 存储介质</title>
      <link href="/post/2421dd09.html"/>
      <url>/post/2421dd09.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章将会介绍如下命令：</li></ol><ul><li>mount: 挂载文件系统</li><li>umount: 卸载文件系统</li><li>fdisk: 硬盘分区命令</li><li>fsck: 检查修复文件系统</li><li>fdformat: 格式化软盘</li><li>mkf: 创建文件系统</li><li>dd: 像设备直接写入面向块数据</li><li>genisoimage (mkisofs) : 创建一个 ISO 9600 映像文件</li><li>wodim (cdrecord) : 向光存储介质写入数据</li><li>md5sum: 计算 MD5 校验码</li></ul><h2 id="挂载、卸载存储设备"><a href="#挂载、卸载存储设备" class="headerlink" title="挂载、卸载存储设备"></a>挂载、卸载存储设备</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>概述</li></ol><ul><li>Linux 图形界面操作最近所取得的进展已使得图形界面操作用户能非常容易地管理存储设备。 </li><li>多数情况下，设备只要连接上系统就能运作。 </li><li>管理存储设备首先要做的就是将该设备添加到文件系统树种，从而允许操作系统可以操作该设备，这个过程称之为挂载。</li></ul><ol start="2"><li>&#x2F;etc&#x2F;fstab 文件</li></ol><table><thead><tr><th align="center">LABEL&#x3D;&#x2F;12</th><th align="center">&#x2F;</th><th align="center">ext3</th><th align="center">defaults</th><th align="center">1</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">LABEL&#x3D;&#x2F;home</td><td align="center">&#x2F;home</td><td align="center">ext3</td><td align="center">defaults</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">LABEL&#x3D;&#x2F;boot</td><td align="center">&#x2F;boot</td><td align="center">ext3</td><td align="center">defaults</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">tmpfs</td><td align="center">&#x2F;dev&#x2F;shm</td><td align="center">tmpfs</td><td align="center">defaults</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">devpts</td><td align="center">&#x2F;dev&#x2F;pts</td><td align="center">devpts</td><td align="center">defaults</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">sysfs</td><td align="center">&#x2F;sys</td><td align="center">sysfs</td><td align="center">defaults</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">proc</td><td align="center">&#x2F;proc</td><td align="center">proc</td><td align="center">defaults</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">LABEL&#x3D;SWAP-sda3</td><td align="center">swap</td><td align="center">swap</td><td align="center">defaults</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><ol start="3"><li>&#x2F;etc&#x2F;fstab 文件参数含义</li></ol><table><thead><tr><th align="center">字段</th><th align="center">内容</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">设备</td><td align="center">通常，该字段表示的是与物理设备相关的设备文件的真实名称，比如 dev&#x2F;hda1 就代表第一个 IDE 通道上的主设备的第一块分区。但是如今的计算机都有很多可热拔插的设备，所以许多较新的 Linux 发行版用文本标签来关联设备。当设备与系统连接后，该标签就会被操作系统识别。通过这样的方式，不管实际的物理设备被分配到哪个设备文件，它仍然能被正确识别</td></tr><tr><td align="center">2</td><td align="center">挂载节点</td><td align="center">设备附加到文件系统树上的目录</td></tr><tr><td align="center">3</td><td align="center">文件系统类型</td><td align="center">Linux 能够挂载许多文件类型系统，最常见的原始文件是 ext3，但也支持许多其他系统 FAT16(msdos)、FAT32(vfat)、NTFS(ntfs)、CD_ROM(iso996) 等</td></tr><tr><td align="center">4</td><td align="center">选项</td><td align="center">文件系统挂载时可以使用许多选项参数，比如，可以设置文件系统以只读的方式挂载或是阻止任何程序修改它们</td></tr><tr><td align="center">5</td><td align="center">频率</td><td align="center">此数值被 dump 命令用来决定是否对该文件系统进行备份以及多久备一次</td></tr><tr><td align="center">6</td><td align="center">优先级</td><td align="center">此数值被 fsck 命令用来决定在启动时需要被扫描的文件系统的顺序</td></tr></tbody></table><h3 id="查看已挂载的文件系统列表"><a href="#查看已挂载的文件系统列表" class="headerlink" title="查看已挂载的文件系统列表"></a>查看已挂载的文件系统列表</h3><ol><li>基本介绍</li></ol><ul><li>mount 命令用于文件系统挂载。不带任何参数输入该命令将会调出目前已经挂载的文件系统列表。</li></ul><ol start="2"><li>mount 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ mount</span><br><span class="line">/dev/sda2 on / <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">prov on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/sda5 on /home <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br><span class="line">fusectl on /sysfs/fuse/connections <span class="built_in">type</span> fuesctl (rw)</span><br><span class="line">/dev/sdd1 on /media/disk <span class="built_in">type</span> vfat (rw,nosuid,nodev,noatime,uhelper=hal,uid=500,utf8,shortname=lower)</span><br><span class="line">twin4:/musicbox on /misc/musicbox <span class="built_in">type</span> nfs4 (rw,addr=192.168.1.4)</span><br></pre></td></tr></table></figure></li><li>补充说明</li></ol><ul><li>列表的格式是：device on mont_point type filesystem_type(options) 。 </li><li>上例中的第一行表示 dev&#x2F;sda2 设备挂载在根目录下，可读写，属于 ext3 类型。 </li><li>然而，可以看到该列表的末尾有两个有趣的条目，倒数第二个条目表示 &#x2F;media&#x2F;disk 目录下挂载了读卡器中 2GB 的 SD 记忆卡，最后一个条目表示 &#x2F;misc&#x2F;musicbox 目录下挂载了一个网络驱动</li></ul><ol start="4"><li>案例</li></ol><ul><li>以 CD-ROM 为例，在我们插入 CD-ROM 前，首先查看一下系统信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00 on / <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/hda1 on /boot <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br></pre></td></tr></table></figure></li><li>此列表来自于一个使用 LVM 机制创建其根文件系统的 CentOS5 系统。</li><li>与许多现代 Linux 发行版一样，此系统在 CD-ROM 插入后会自动进行挂载。</li><li>光盘插入后，输入 mount 命令，便会显示如下系统内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00 on / <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/hda1 on /boot <span class="built_in">type</span> ext3 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br><span class="line">/dev/hdc on /media/live-1.0.10-8 <span class="built_in">type</span> iso9660 (ro,noexec.nosuid,nodev,uid=500)</span><br></pre></td></tr></table></figure></li><li>与之前的信息列表相比，本列表只是在末尾处多了一个额外的条目，该条目表示 CD-ROM ，本系统上的设备名是 &#x2F;dev&#x2F;hdc，已经挂载在 &#x2F;media&#x2F;live-1.0.10-8 目录下并且是 iso9660 类型。</li><li>获取 CD-ROM 的设备名之后，便可以卸载该设备，然后将其挂载在文件系统树的另一个节点上。</li><li>进行此操作，必须首先获得超级用户权限，再使用 umount 命令卸载光盘。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -</span><br><span class="line">password:</span><br><span class="line">[root@linuxbox ~]<span class="comment"># umount /dev/hdc</span></span><br></pre></td></tr></table></figure></li><li>接下来，我们为光盘创建一个新的挂载节点。挂载节点仅仅是文件系统上的某个目录，并没有什么特别之处，甚至都不需要是空目录，如果在非空目录上挂载设备，该目录下原有的内容将不可见直到此设备被卸载。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># mkdir /mnt/cdrom</span></span><br></pre></td></tr></table></figure></li><li>CD 光盘挂载到新的节点上，使用 -t 选项指定文件系统类型：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># mount -t iso9660 /dev/hdc /mnt/cdrom</span></span><br></pre></td></tr></table></figure></li><li>之后，便可以通过新建的挂载节点访问 CD 光盘的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># cd /mnt/cdrom</span></span><br><span class="line">[root@linuxbox cdrom]<span class="comment"># ls</span></span><br></pre></td></tr></table></figure></li><li>请注意，如果此时试图卸载 CD 光盘就会出现下面问题：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox cdrom]<span class="comment"># umount /dev/hdc</span></span><br><span class="line">umount: /mnt/cdrom: device is busy</span><br></pre></td></tr></table></figure></li><li>因为设备正在被某人或事某程序使用时是不能被卸载的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox cdrom]<span class="comment"># cd </span></span><br><span class="line">[root@linuxbox ~]<span class="comment"># umount /dev/hdc</span></span><br></pre></td></tr></table></figure></li><li>如此该设备便卸载成功了。</li></ul><h3 id="确定设备名称"><a href="#确定设备名称" class="headerlink" title="确定设备名称"></a>确定设备名称</h3><ol><li>基本介绍</li></ol><ul><li>查看 &#x2F;dev 目录下的设备信息，我们就会发现有海量的设备：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>Linux 存储设备名称</li></ol><table><thead><tr><th align="center">模式</th><th align="center">设备</th></tr></thead><tbody><tr><td align="center">&#x2F;dev&#x2F;fd*</td><td align="center">软盘驱动器</td></tr><tr><td align="center">&#x2F;dev&#x2F;hd*</td><td align="center">较旧系统上的 IDE 硬盘。典型的主板有两个 IDE 连接点或通道，并且每个都有两个驱动器附着点。线缆上第一个驱动器叫做主设备，第二个叫做从设备。设备命名按照如下规则进行：&#x2F;dev&#x2F;hda 代表第一个通道上的主设备；&#x2F;dev&#x2F;hdb 表示第一个通道上的从设备；&#x2F;dev&#x2F;hdc 代表第二个通道上的主设备，以此类推，而末尾的数字代表设备的分区号。例如，当 &#x2F;dev&#x2F;hda 代表 整个硬盘时，&#x2F;dev&#x2F;hda1 表示该硬盘驱动上的第一块分区</td></tr><tr><td align="center">&#x2F;dev&#x2F;lp*</td><td align="center">打印机设备</td></tr><tr><td align="center">&#x2F;dev&#x2F;sd*</td><td align="center">SCSI 硬盘，在最近的 Linux 系统上，内核把所有的类硬盘设备 (包括 PATA&#x2F;SATA 硬盘、闪存、USB 海量存储设备等) 都当作 SCSI 硬盘。</td></tr><tr><td align="center">&#x2F;dev&#x2F;sr*</td><td align="center">光驱</td></tr></tbody></table><ol start="3"><li>补充说明</li></ol><ul><li>如果使用的系统不能自动挂载可移动设备，首先可以对 &#x2F;var&#x2F;log&#x2F;messages 文件进行实时查看：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo <span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>相关信息如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jul 23 10:07:59 linuxbox kernel: sdb:sdb1</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI removable disk</span><br></pre></td></tr></table></figure></li><li>获取设备名后，我们便可以挂载此闪存设备：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo <span class="built_in">mkdir</span> /mnt/flash</span><br><span class="line">[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">df</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>将一个使用 FAT32 文件系统的闪存驱动器重新格式化为 Linux 本地文件系统，需要两个步骤：第一个，在对现有的分区不满意的情况下创建一个新的分区布局；第二，在驱动器上创建一个新的空文件系统。</li></ol><h3 id="用-fdisk-命令进行磁盘分区"><a href="#用-fdisk-命令进行磁盘分区" class="headerlink" title="用 fdisk 命令进行磁盘分区"></a>用 fdisk 命令进行磁盘分区</h3><ol><li>fdisk 命令实现用户与磁盘设备进行比较低层次的直接交互。</li><li>该工具可以用来编辑、删除以及创建设备分区。使用闪存前，我们必须首先将其卸载，然后再启动 fdisk 程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo umount /dev/sdb1</span><br><span class="line">[me@linuxbox ~]$ sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure></li><li>请注意使用 fdisk 命令指定设备时，设备名要是整个设备的而不是分区号。</li><li>然后根据程序菜单，选择自己需要的选项，即可磁盘分区。</li></ol><h3 id="用-mkfs-命令创建新的文件系统"><a href="#用-mkfs-命令创建新的文件系统" class="headerlink" title="用 mkfs 命令创建新的文件系统"></a>用 mkfs 命令创建新的文件系统</h3><ol><li>基本介绍</li></ol><ul><li>分区编辑已经完成，我们便可以在闪存上创建新的文件系统。</li><li>mkfs 命令可以用来创建各种类型的文件系统。</li></ul><ol start="2"><li>mkfs 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo mkfs -t ext3 /dev/sdb1 <span class="comment"># ext3 文件系统类型</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="测试、修复文件系统"><a href="#测试、修复文件系统" class="headerlink" title="测试、修复文件系统"></a>测试、修复文件系统</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>概述</li></ol><ul><li>系统每次启动时，挂载文件系统前都会惯例性地检查文件系统的完整性，此检查过程是由 fsck 程序完成的，fstab 文件每个条目末尾的数字正是对应设备的检查优先级。</li><li>除了检查文件系统的完整性外，fsck 还能修复损坏的文件系统，修复程度取决于损坏程序。</li></ul><ol start="2"><li>fsck 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo fsck /dev/sdb1</span><br><span class="line">fsck 1.40.8 (13-Mar-2012)</span><br><span class="line">e2fsck 1.40.8 (13-Mar-2012)</span><br><span class="line">/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks</span><br></pre></td></tr></table></figure></li></ol><h2 id="格式化软盘"><a href="#格式化软盘" class="headerlink" title="格式化软盘"></a>格式化软盘</h2><ol><li>对于那些仍然使用配备软盘驱动器的老式电脑的用户，同样可以管理这些软盘设备。</li><li>首先，我们对软盘进行一个低级格式化操作，然后创建一个文件系统。</li><li>fdformat 程序后面输入指定的软盘设备名，即可完成格式化操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo fdformat /dev/fd0</span><br></pre></td></tr></table></figure></li><li>接下来用 mkfs 命令为软盘创建一个 FAT 文件系统<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo mkfs -t msdos /dev/fd0</span><br></pre></td></tr></table></figure></li><li>软盘准备工作完成后，就可以向其他设备一样被挂载</li></ol><h2 id="直接从设备转移数据"><a href="#直接从设备转移数据" class="headerlink" title="直接从设备转移数据"></a>直接从设备转移数据</h2><ol><li>基本介绍</li></ol><ul><li>我们通常认为电脑上的数据都是以文件的形式存储，但也有可能会认为数据以原始形式存储。</li><li>以磁盘驱动器为例，它包含了许多被操作系统当作目录或文件的数据块。如果可以简单地把磁盘驱动器当作一个大数据块集，那么我们就可以执行一些有用任务，诸如克隆设备等。</li><li>dd 程序可以完成这样的任务，该命令将数据块从一个地方复制到另一个地方。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=input_file of=output_file [bs=block_size [count=blocks]]</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>案例</li></ol><ul><li>假定现在有两个容量一样的 U 盘，并且我们希望将第一个 U 盘里面的内容准确完全地复制到第二个 U 盘里面。</li><li>如果这两个盘都已经连接到电脑上并且它们的设备名分别为 &#x2F;dev&#x2F;sdb 和设备 &#x2F;dev&#x2F;sdc，那么我们就可以用下面的命令行将第一个盘上的所有内容复制到第二个盘上：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc</span><br></pre></td></tr></table></figure></li><li>或者，如果只有一个盘连接到电脑上，那么我们可以将其内容先复制到一个普通的文件里以备后续存储或复制：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=flash_drive.img</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建-CD-ROM-映像"><a href="#创建-CD-ROM-映像" class="headerlink" title="创建 CD-ROM 映像"></a>创建 CD-ROM 映像</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>向 CD-ROM 写入数据包括两个步骤：首先，创建一个 ISO 映像文件，也就是 CD-ROM 文件系统映像；其次，将此映像文件写入到 CD-ROM 介质中。</li></ol><h3 id="创建一个-CD-ROM-文件映像副本"><a href="#创建一个-CD-ROM-文件映像副本" class="headerlink" title="创建一个 CD-ROM 文件映像副本"></a>创建一个 CD-ROM 文件映像副本</h3><ol><li>如果我们想给现有的 CD-ROM 创建一个 ISO 映像，可以使用 dd 命令将 CD-ROM 中所有数据块复制到本地某个文件。</li><li>假定我们有一张 Ubuntu 的 CD 光盘，并打算创建一个 ISO 文件以便后续制作更多副本。</li><li>CD 光盘被插入且其设备名被确定后，我们便可以制作 ISO 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom of =ubuntu.iso</span><br></pre></td></tr></table></figure></li><li>该方法同样适用于数据类 DVD，但不适用于音频 DVD，因为音频 DVD 并不使用文件系统实现存储。</li><li>对于音频 CD，可以使用 cdrdao 命令</li></ol><h3 id="从文件集合中创建映像文件"><a href="#从文件集合中创建映像文件" class="headerlink" title="从文件集合中创建映像文件"></a>从文件集合中创建映像文件</h3><ol><li>enisoimage 程序通常用于创建包含一个目录内容的 ISO 映像文件。</li><li>首先我们创建一个目录，该目录包含了所有我们希望加进映像文件里的文件，然后运行 enisoimage 程序创建映像文件。</li><li>例如，假使事先我们创建了一个叫做 ~&#x2F;cd-rom-files 的文件目录，并且该目录中包含了所有准备装入 CD-ROM 中的文件，那么接下来，我们就可以用 enisoimage 命令创建 ISO 映像文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</span><br></pre></td></tr></table></figure></li><li>-R 选项添加了允许 Rock Ridge 延伸的元数据，此延伸允许在 Linux 中使用较长文件名的文件以及 POSIX 风格的文件。</li><li>-J 选项允许 Joliet 延伸，此延伸允许在 Windows 中使用较长文件名的文件</li></ol><h2 id="向-CD-ROM-写入映像文件"><a href="#向-CD-ROM-写入映像文件" class="headerlink" title="向 CD-ROM 写入映像文件"></a>向 CD-ROM 写入映像文件</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>映像文件创建好，下一步便是将其刻录进光学介质中</li></ol><h3 id="直接挂载-ISO-映像文件"><a href="#直接挂载-ISO-映像文件" class="headerlink" title="直接挂载 ISO 映像文件"></a>直接挂载 ISO 映像文件</h3><ol><li>当 ISO 映像文件仍然在硬盘上时，我们可以把它当作已存在于光学介质中，并且有一个窍门可以实现映像文件的挂载。</li><li>那就是通过增加 -o loop 选项来挂载，如此便可以把映像文件当作设备一样挂载在文件系统树上了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/iso_image</span><br><span class="line">mount -t iso9660 -o loop image.iso /mnt/iso_image</span><br></pre></td></tr></table></figure></li><li>在上面的例子中，我们创建了一个叫做 &#x2F;mnt&#x2F;iso_image 挂载节点并将 image.iso 映像文件挂载在该节点上。</li><li>映像文件挂载成功后，就可以把它当作真实的 CD-ROM 或 DVD。</li><li>记住，当不需要该映像文件的时候要将其卸载。</li></ol><h3 id="擦除可读写-CD-ROM"><a href="#擦除可读写-CD-ROM" class="headerlink" title="擦除可读写 CD-ROM"></a>擦除可读写 CD-ROM</h3><ol><li>可擦写 CD-ROM 在重用之前需要被擦除或清空，我们可以通过 wodim 命令指定光盘刻录机操作对象的设备名以及所要执行的擦除类型来完成。</li><li>wodim 程序提供多种擦除类型，最基本的就是 fast 类型。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wodim dev=/dev/cdrw blank=fast</span><br></pre></td></tr></table></figure></li></ol><h3 id="写入映像文件"><a href="#写入映像文件" class="headerlink" title="写入映像文件"></a>写入映像文件</h3><ol><li>同样我们使用 wodim 命令写入映像文件，通过指定写入的光介质刻录设备的名字以及映像文件的名字来完成：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wodim dev=/dev/cdrw image.iso</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十八章 归档和备份</title>
      <link href="/post/49f62c41.html"/>
      <url>/post/49f62c41.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十八章-归档和备份"><a href="#第十八章-归档和备份" class="headerlink" title="第十八章 归档和备份"></a>第十八章 归档和备份</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>维护系统数据安全是计算机系统管理者的基本任务之一，及时创建系统文件的备份文件是维护系统数据安全的一种常用方法。</li><li>即便对于非系统管理员，经常创建备份文件或是在设备之间、文件夹之间移动大文件集通常都是非常有益的。</li><li>本章会介绍一些用于管理文件集合的常用命令：</li></ol><ul><li>文件压缩程序：<ul><li>gzip: 压缩和解压缩文件工具</li><li>bzip2: 块排序文件压缩工具</li></ul></li><li>文件归档程序：<ul><li>tar: 磁带归档工具</li><li>zip: 打包和压缩文件</li></ul></li><li>文件同步程序:<ul><li>rsync: 远程文件和目录的同步</li></ul></li></ul><h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>在计算领域的发展历史中，人们一直在努力实现以最小的可利用空间存储最多的数据，其中可利用空间包括内存、存储设备或者网络带宽。</li><li>许多如今认为理所当然的数据服务，比如便携式音乐播放器、高清电视和宽带互联网等之所以能够存在，都应该归功于有效的数据压缩技术。</li><li>数据压缩是一个移除数据冗余信息的过程。现今的压缩技术则更为先进、更复杂，但基本目标一直是消除冗余数据信息。</li><li>压缩算法 (压缩采用的数学方法) 一般分为两大类：无损压缩与有损压缩。</li><li>无损压缩保留原文件中的所有数据，也就是说这种方式的压缩文件还原时，还原后的文件与原文件完全一致。</li><li>有损压缩，在压缩时为了实现更大程度的压缩而删除了某些数据信息，有损压缩文件还原时，与原文件并不是完全吻合，但是与原文件差别并不大。</li><li>JPEG (图像压缩技术) 和 MP3 (音频压缩技术) 技术是典型的有损压缩实例。</li><li>下面的讨论中，仅仅涉及无损压缩，因为计算机上的大多数数据无法容忍任何数据损失。</li></ol><h3 id="gzip-文件压缩与解压缩"><a href="#gzip-文件压缩与解压缩" class="headerlink" title="gzip - 文件压缩与解压缩"></a>gzip - 文件压缩与解压缩</h3><ol><li>gzip 基本介绍</li></ol><ul><li>gzip 命令用于压缩一个或者更多文件。执行命令后，原文件会被其压缩文件取代。与之相反，gunzip 命令则将压缩文件还原为原文件。示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.*</span><br><span class="line">-rw-r--r-- 1 me me 15738 2012-10-14 07:15 foo.txt</span><br><span class="line">[me@linuxbox ~]$ gzip foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.*</span><br><span class="line">-rw-r--r-- 1 me me 3230 2012-10-14 07:15 foo.txt.gz</span><br><span class="line">[me@linuxbox ~]$ gunzip foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.*</span><br><span class="line">-rw-r--r-- 1 me me 15738 2012-10-14 07:15 foo.txt</span><br></pre></td></tr></table></figure></li><li>面对本例中，我们首先创建了一个名为 foo.txt 的文本文件，其内容为某目录所含文件的列表清单，然后运行 gzip 命令。于是，压缩后的文件 foo.txt.gz 便取代了原文件。</li><li>foo.* 表达式的文件，我们可以看到原文件已被其压缩文件取代，并且压缩后文件大小差不多才是原文件的 1&#x2F;5 。此外，我们还可以看出，压缩后的文件与原文件有着相同的权限和时间戳。</li><li>接着，我们运用 gunzip 命令进行解压缩，如此该压缩文件又被原始文件取代，而且权限和时间戳仍然会保持一致。</li></ul><ol start="2"><li>gzip 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">将输出内容写到标准输出端口并且保持原有文件。也可以用 --stdout 或是 --to-stdout 替代</td></tr><tr><td align="center">-d</td><td align="center">解压缩。加上此选项， gzip 命令便类似于 gunzip。也可以用 --decompress 或 --uncompress 替代</td></tr><tr><td align="center">-f</td><td align="center">强制压缩，即便原文件的压缩版本已经存在了。也可以用 --force 替代</td></tr><tr><td align="center">-h</td><td align="center">显示有用信息，也可以用 --help 替代</td></tr><tr><td align="center">-l</td><td align="center">列出所有压缩文件的压缩统计。也可以用 --list 替代</td></tr><tr><td align="center">-r</td><td align="center">如果该命令行的操作参数中有一个或是多个是目录，那么递归压缩包含在目录中的文件。也可以 --recursive 代替</td></tr><tr><td align="center">-t</td><td align="center">检查压缩文件的完整性。也可以用 --test 代替</td></tr><tr><td align="center">-v</td><td align="center">在压缩时显示详细信息。也可以用 --verbose 代替</td></tr><tr><td align="center">-number</td><td align="center">设定压缩级别， number 是 1 (速度最快，压缩比最小) ~ 9 (速度最慢，压缩比最大) 范围中的一个整数。当然 1 ~ 9 的数值亦可以分别描述为 --fast 和 --best 。 gzip 默认的压缩级别是 6</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>回顾前面的例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ gzip foo.txt</span><br><span class="line">[me@linuxbox ~]$ gzip -tv foo.txt.gz</span><br><span class="line">foo.txt.gz:     OK</span><br><span class="line">[me@linuxbox ~]$ gzip -d foo.txt.gz</span><br></pre></td></tr></table></figure></li><li>此例中，首先，我们将压缩文件 foo.txt.gz 取代了原文件 foo.txt 。接着，我们运用 -t、-v 选项检查压缩文件的完整性。最后，解压缩该文件为原来的形式。</li><li>借助标准输入输出，gzip 有很多有趣的用法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc | gzip &gt; foo.txt.gz</span><br></pre></td></tr></table></figure></li><li>此命令创建了一个目录列表的压缩版本。</li><li>gunzip 命令用于解压 gzip 的压缩文件，并且默默解压缩后缀为 .gz 的文件，所以，我们没有必要明确指定，只要指定名与已存在非压缩文件名不冲突就可以了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ gunzip foo.txt</span><br></pre></td></tr></table></figure></li><li>如果只是希望查看某个压缩文本文件的内容，可以直接输入下面的命令行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ gunzip -c foo.txt | less</span><br></pre></td></tr></table></figure></li><li>或者，利用 zcat 命令联合 gzip 一起，其效果等同于带有 -c 选项的 gunzip 。</li><li>zcat 的功能与 cat 命令相同，只是它的操作对象是压缩文件。用 zcat 命令处理 gzip 压缩文件的示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat -c foo.txt | less</span><br></pre></td></tr></table></figure></li><li>同样也有 zless 命令，它与前面所讲的 less 的管道功能相同。</li></ul><h3 id="bzip2-牺牲速度以换取高质量的数据压缩"><a href="#bzip2-牺牲速度以换取高质量的数据压缩" class="headerlink" title="bzip2 - 牺牲速度以换取高质量的数据压缩"></a>bzip2 - 牺牲速度以换取高质量的数据压缩</h3><ol><li>bzip2 基本介绍</li></ol><ul><li>bzip2 程序由 Julian Seward 开发，与 gzip 命令功能相仿，但使用不同的压缩算法。该算法具有该质量的数据压缩能力，但却降低了压缩速度。多数情况下，其用法与 gzip 类似，只是用 bzip2 压缩后的文件以 .bz2 为后缀。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt</span><br><span class="line">-rw-r--r-- 1 me me 15738 2012-10-17 13:51 foo.txt</span><br><span class="line">[me@linuxbox ~]$ bzip2 foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt.bz2</span><br><span class="line">-rw-r--r-- 1 me me 2792 2012-10-17 13:51 foo.txt.bz2</span><br><span class="line">[me@linuxbox ~]$ bunzip2 foo.txtb.z2</span><br></pre></td></tr></table></figure></li><li>由此例可以看出，bzip2 用法与 gzip 类似，前面所讨论的所有选项 (除了 -r 选项) ，bzip2 都支持。</li><li>然而，要注意的是，两者的压缩级别选项 (-number) 有些许不同。与此同时，解压缩 bzip2 压缩文件的专用工具是 bunzip2 和 bzcat 命令。</li><li>bzip2 还配有专门的 bzip2recover 命令，该命令用于恢复损坏的 .bz2 文件。</li></ul><h2 id="文件归档"><a href="#文件归档" class="headerlink" title="文件归档"></a>文件归档</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>归档是与压缩操作配合使用的一个常用文件管理任务。</li><li>归档是一个聚集众多文件并将它们组合为一个大文件的过程，它通常作为系统备份的一部分，而且通常也用于将旧数据从某个系统移动某些长期存储设备的情况下。</li></ol><h3 id="tar-磁带归档工具"><a href="#tar-磁带归档工具" class="headerlink" title="tar - 磁带归档工具"></a>tar - 磁带归档工具</h3><ol><li>tar 基本介绍</li></ol><ul><li>tar 命令是类 UNIX 系统中用于归档文件的经典工具。</li><li>tar 是 tape archive 的缩写，由此可见，该命令最初始的作用就是磁带备份。虽然该命令仍可用于传统的磁带备份，但同样也可用于其他存储设备。</li><li>大家肯定经常看到文件名以 .tar 和 .tgz 结尾的文件，它们分别是用普通的 tar 命令归档的文件和用 gzip 归档文件的文件。</li><li>tar 归档文件可以由许多独立的文件、一个或多个目录层次或者两者的混合组合而成，其用法如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar mode[options] pathname...</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>tar 操作模式</li></ol><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">c</td><td align="center">创建文件和&#x2F;或目录列表的归档文件</td></tr><tr><td align="center">x</td><td align="center">从归档文件中提取文件</td></tr><tr><td align="center">t</td><td align="center">在归档文件末尾追加指定路径名</td></tr><tr><td align="center">r</td><td align="center">列出归档文件的内容</td></tr></tbody></table><ol start="3"><li>tar 案例</li></ol><ul><li>tar 命令在选项的表达方式上有点奇怪，所以，我们需要据一些例子以说明其是如何工作的。首先，重新创建一个上一章中所建的 playground 文件夹。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> -p playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125;</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125;/file-&#123;A..Z&#125;</span><br></pre></td></tr></table></figure></li><li>下面，用 tar 命令为整个 playground 文件夹创建一个归档文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ tar cf playground.tar playground</span><br></pre></td></tr></table></figure></li><li>该命令行创建了一个叫做 playground.tar 的 tar 归档文件，该归档文件包含了 playground 文件夹的整个目录结构。</li><li>从命令行中我们可以看出，tar 的命令操作模式 c 参数和用于指定归档文件名的 f 参数可以直接连着写在一起而中间不需要连字符隔开。</li><li>然而，请注意，mode 参数必须在任何选项之前指定。</li><li>下面的命令行用于列出归档文件的内容，可用于查看已经备份了哪些文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ tar playground.tar</span><br></pre></td></tr></table></figure></li><li>如若想要获取更详细的信息，可以增加 -v (详细信息) 选项。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ tar tvf playground.tar</span><br></pre></td></tr></table></figure></li><li>现在，将 playground 文件夹中的内容提取到一个新的位置。首先创建一个名为 foo 的新文件夹，然后切换工作目录，在提取该归档文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ tar xf ../playground.tar</span><br><span class="line">[me@linuxbox foo]$ <span class="built_in">ls</span></span><br><span class="line">playground</span><br></pre></td></tr></table></figure></li><li>查看 &#x2F;foo&#x2F;playground 目录下的内容，便会发现该归档文件已经成功提取，并且是源文件的精确复制。</li><li>但是存在一个问题，除非是以超级用户的名义执行该命令，不然，从归档文件中提取出来的文件和目录的所有权属于执行归档操作的用户而不是文件的原始作者。</li><li>tar 命令处理档案文件路径名的方式也很有趣，其默认的路径名是相对路径而不是绝对路径，tar 命令创建归档文件时会简单地移除路径名前面的斜杠来实现相对路径。</li><li>作为演示，下面会重新创建一个归档文件，此次明确指定一个绝对路径。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox foo]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ tar cf playground2.tar ~/playground</span><br></pre></td></tr></table></figure></li><li>记住，当按下 Enter 键时，上面命令行输入的目录 ~&#x2F;playground 会扩展为 &#x2F;home&#x2F;me&#x2F;playground，也就是绝对路径。接下来，我们按照前面的步骤从归档文件中提取文件，注意观察所发生的变化。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ tar xf ../palyground2.tar</span><br><span class="line">[me@linux foo]$ <span class="built_in">ls</span></span><br><span class="line">home playground</span><br><span class="line">[me@linux foo]$ <span class="built_in">ls</span> home</span><br><span class="line">me</span><br><span class="line">[me@linux foo]$ <span class="built_in">ls</span> home/me</span><br><span class="line">playground</span><br></pre></td></tr></table></figure></li><li>此刻，我们便会发现当解压第二个归档文件是在当前工作目录 ~&#x2F;foo 下重新创建了一个 home&#x2F;me&#x2F;playground 目录，而不是在认定的聚堆路径根目录下创建的。</li><li>这样的工作方式看起来很奇怪，但是却更有用，因为如此可以将归档文件解压缩到任何目录下而不用被迫解压到源目录下，使用 -v 选项重复操作此实例可以详细地了解其运行情况。</li><li>下面让我们看一个假想的但很实用的 tar 命令应用实例。假设我们需要将一个系统上的主目录及其内容复制到另外一个系统上，并且具备用于实现这一转移的 USB 大硬盘连接系统后，设备名为 BigDisk 。接着用 tar 进行文件归档，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo tar cf /media/BigDisk/home.tar /home</span><br></pre></td></tr></table></figure></li><li>tar 归档的文件写入硬盘后，我们将硬盘卸载，再将其与另外一台计算机连接。同样，此硬盘挂载在了 &#x2F;media&#x2F;BigDisk 目录下。那么如何解压缩该归档文件，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox2 ~]$ <span class="built_in">cd</span> /</span><br><span class="line">[me@linuxbox2 /]$ sudo tar xf /media/BigDisk/home.tar</span><br></pre></td></tr></table></figure></li><li>当从归档文件中的所有文件采用的都是相对路径。</li><li>当从归档文件中提取文件时，可以限制只提取某些文件。例如，如果希望从归档文件中提取单个文件，可以用如下命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf archive.tar pathname</span><br></pre></td></tr></table></figure></li><li>在命令后面添加要提取的文件的路径名，可以确保 tar 只恢复指定文件，而且可以指定多个路径名。注意，指定的路径名必须是存储在归档文件中的完整、准确的相对路径。在指定路径名时，通常不支持通配符。但是，GNU 版本的 tar 命令 (在 Linux 发行版本中该版本的 tar 最常见) 通过使用 –wildcards 选项而支持通配符。下面就是一个利用前面的 playground.tar 归档文件实践通配符的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@Linuxbox foo]$ tar xf ../playground2.tar --wildcards <span class="string">&#x27;home/me/playground/dir-*/file-A&#x27;</span> </span><br></pre></td></tr></table></figure></li><li>此命令行只会提取那些路径名与通配符 dir-* 匹配的文件。 </li><li>tar命令创建归档文件时通常辅助以 find 命令。首先使用find命令查找到需要被归档的文件，然后借助 -exec 操作选项，启动 tar 的附加模式 r 将匹配文件添加到归档文件 playground.tar 中。</li><li>tar 命令结合 find 命令很适合创建目录数以及整个系统的增量备份，使用 find 命令找到那些在时间戳之后创建的文件，便可以创建一份只包含一次归档之后创建的文件的归档文件，当然假定该事件戳文件时在每个归档文件创建之后就立刻更新。 </li><li>tar命令还可以利用标准输入输出。下面就是一个综合例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox foo]$ <span class="built_in">cd</span> </span><br><span class="line">[me@Linuxbox foo]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> | tar cf - --files-from=. | gzip</span><br></pre></td></tr></table></figure></li><li>本例中，先用 find 命令搜索得到匹配文件列表，然后将匹配文件再送至 tar 命令处理。如果文件名前面明确指定有连字符 - ，那就意味着这是标准输入输出的文件 (顺便讲一下，使用 - 代表标注输入&#x2F;输出的惯例，其他许多程序也都采用) 。</li><li>--file-from 选项 (也可以简写成 -T) 则指定了 tar 命令从文件中而不是从命令行中读取文件路径名列表。</li><li>最后，tar 命令归档后的文件在送至 gzip 进行压缩，由此得到压缩归档文件 playground.tgz 。</li><li>后缀 .tgz 已经惯例性称为经 gzip 压缩的 tar 归档文件名的后缀，淡然，我们又是也用 .tar.gz 作后缀。</li><li>虽然可以从外部使用 gzip 命令创建压缩归档文件，但现代 GNU 版本的 tar 命令则提供 gzip+z 选项和 bzip2+j 选项直接实现这一功能。</li><li>以前面的例子为例，可以将命令行简化为一下命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> | tar czf playground.tgz -T -</span><br></pre></td></tr></table></figure></li><li>当然，如果我们想要创建一个 bzip2 压缩的归档文件，可以这么做。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> | tar cjf playground.tbz -T -</span><br></pre></td></tr></table></figure></li><li>通过简单地将压缩选项从 z 变为 j (并将输出文件后缀改为 .tbz 以显示是 bzip2 压缩的文件) ，即可实现 bzip2 式的压缩归档文件。</li><li>利用 tar 命令在系统之间传输网络文件，是 tar 另一个利用标准输入输出的有趣用法。</li><li>假设，有两台类 UNIX 系统的计算机正在运行，并且都安装了 tar 命令和 ssh 命令，于是，我们便可以将远程系统 (本例中远程主机名叫做 remote-sys ) 中的某目录转移到本地系统。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">mkdir</span> remote-stuff</span><br><span class="line">[me@Linuxbox ~]$ <span class="built_in">cd</span> remote-stuff</span><br><span class="line">[me@Linuxbox remote-stuff]$ ssh remote-sys <span class="string">&#x27;tar cf -Documents&#x27;</span> | tar xf -me@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">[me@Linuxbox remote-stuff]$ ls</span></span><br><span class="line"><span class="string">Documents</span></span><br></pre></td></tr></table></figure></li><li>上例中，名为 Documents 的目录从 remote-sys 的远程系统复制到本地系统上的 remote-stuff 的文件目录里。</li><li>首先，用 ssh 程序在远程系统上启动 tar 命令，此时可能会联想到前面所讲的 ssh 具有在联网及其上运行的远程程序并将结果显示在本地系统的能力，也就是远程系统的标准输出送至本地系统显示。</li><li>于是，利用这一特性，我们可以将 tar 命令创建的归档文件 (用 c 模式创建的) 送至标准输出而不是直接输出文件 (-f 选项) ，然后通过 ssh 建立的加密隧道将归档文件送至本地系统。</li><li>在本地系统上，我们在执行 tar 命令提取 (x 模式) 标准输入的归档文件 (同样用 f 选项加上连字符作为参数) 。</li></ul><h3 id="zip-打包压缩文件"><a href="#zip-打包压缩文件" class="headerlink" title="zip - 打包压缩文件"></a>zip - 打包压缩文件</h3><ol><li>zip 基本介绍</li></ol><ul><li>zip 程序即使文件压缩工具也是文件归档工具。 </li><li>Windows 用户肯定很熟悉这种文件格式，因为其读写的是 .zip 后缀的文件。然而，Linux 系统中，gzip 才是主要的压缩指令，而 bzip2 仅次之。 </li><li>Linux 用户主要使用 zip 程序与 Windows 系统交换文件，而不是将其用于压缩或是归档文件。 </li><li>zip 最基本的调用方式如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip options zipfile file...</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>zip 案例</li></ol><ul><li>例如，创建一个 playground 的 zip 归档文件，可以输入下面的命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ zip -r playground.zip playground</span><br></pre></td></tr></table></figure></li><li>此例中，如果不加 -r 选项递归的话，只保留 playground 这个目录而不包括目录中内容。虽然程序会自动默认添加后缀 .zip，但为了以示清晰，最好还是在命令行中添加文件后缀。</li><li>zip 归档文件创建的过程中，zip 通常会显示如下的一系列信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adding:playground/dir-020/file-Z(stored 0%)</span><br><span class="line">adding:playground/dir-020/file-Y(stored 0%)</span><br><span class="line">adding:playground/dir-020/file-X(stored 0%)</span><br><span class="line">adding:playground/dir-087/ (stored 0%)</span><br><span class="line">adding:playground/dir-087/file-S (stored 0%)</span><br></pre></td></tr></table></figure></li><li>这些信息显示的是每个新添归档文件的状态。zip 使用两种存储方式向归档文件中添加文件。第一，不对文件进行压缩直接存储，如本例；第二，缩小文件大小，即对文件进行压缩后存储。紧随存储方法之后显示的数值表示的是实现的压缩比。</li><li>由于使用的 playground 文件夹是空文件夹，所以并没有对齐内容进行压缩。</li><li>利用 unzip，我们可以直接提取 zip 文件中的内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@Linuxbox foo]$ unzip ../playground.zip </span><br></pre></td></tr></table></figure></li><li>关于 zip，有一点需要注意 (与 tar 命令相比) ，即如果指定的归档文件已经存在，那么 zip 仅仅只会更新而不会取而代之。这意味着原来存在的归档文件会保留下来，只是增加了一些新文件，原有匹配文件则被替换。</li><li>通过给 unzip 指定提取的文件名，我们可以选择性地从 zip 归档文件中提取文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ unzip -l playground.zip playground/dir-087/file-Z</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ unzip ../playground.zip playground/dir-087/file-Z </span><br></pre></td></tr></table></figure></li><li>使用 -l 选项，unzip 只会列出归档文件的内容而不会从中提取文件。</li><li>如果没有指定任何文件，unzip 将会提取归档文件中的所有文件，我们可以增加 -v 选项得到更更详细的列表。注意当提取的文件与已存在文件冲突时，原文件被取代之前会提示用户是否执行此替换操作。</li><li>与 tar 命令类似，zip 命令也可以利用标准输入输出，尽管此用法在某种程度上来说作用并不大。我们也可以用 -@ 选项将多个文件送至 zip 进行压缩。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox foo]$ <span class="built_in">cd</span></span><br><span class="line">[me@Linuxbox ~]$ find playground -name <span class="string">&quot;file-A&quot;</span> | zip -@ file-A.zip</span><br></pre></td></tr></table></figure></li><li>本例中，我们利用 find 命令产生一个匹配 -name 项的 file -A 文件列表，然后将结果直接作为 zip 命令的输入，从而得到一个包含选定文件的归档文件 file-A.zip 。</li><li>zip 同样可以将结果送至标准输出，但是由于只有极少的命令能够利用其输出结果，所以这种用法具有局限性。不幸的是，unzip 程序不支持标准输入，所以 zip 和 unzip 不能像 tar 命令一样一起用于处理网络文件。</li><li>然而，zip 命令支持标准输入，所以可以用于压缩其他程序的输出结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc/ | zip ls-etc.zip -</span><br><span class="line">adding: - (deflated 80%)</span><br></pre></td></tr></table></figure></li><li>本例中，我们将 ls 的输出结果列表直接送给 zip 。与 tar 命令一样，zip 会默认默认的连字符代表输入的文件是标准输入。</li><li>到目前为止，本章只涉及 zip 和 unzip 命令的一些基本用法，他们其实还有很多选项，尽管有些只适用于其他系统的特定平台，但是他们使用起来很灵活。zip 和 unzip 的 man 手册页都很全面，且包含了很多有用的例子。</li></ul><h2 id="同步文件和目录"><a href="#同步文件和目录" class="headerlink" title="同步文件和目录"></a>同步文件和目录</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>将一个或多个目录与本地系统 (通常是某种可移动存储设备) 或是远程系统上其他的目录保持同步，是维护系统备份文件的常用方法。</li><li>例如，本地系统上有一个正在开发的网站备份，用户通常会在远程 Web 服务器上进行实时备份以实现同步更新。</li></ol><h3 id="在网络上使用-rsync-命令"><a href="#在网络上使用-rsync-命令" class="headerlink" title="在网络上使用 rsync 命令"></a>在网络上使用 rsync 命令</h3><ol><li>通过网络复制文件是 rsync 用法的另一美妙之处。毕竟，rsync 命令名中的 r 其实指的是 remote (远程) 。</li><li>远程复制可以由以下两种方法中的任一种实现。</li><li>方法之一是针对于已安装了 rsync 命令以及诸如 ssh 等远程 shell 程序的系统。</li><li>假定本地网络有另外一个具有足够可利用硬盘空间的系统，同时希望利用远程系统而非外部设备进行备份操作。</li><li>假设远程系统已经有一个用于存放备份文件的 &#x2F;backup 目录，那么我们便可以直接运行下面的命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo rsync -av --delete --rsh=ssh /etc/home /usr/local remote-sys:/backup</span><br></pre></td></tr></table></figure></li><li>此处命令行改动了两个地方。第一，增加了 --rsh&#x3D;ssh 选项，该选项告诉 rsync 使用 ssh 命令作为其远程 shell 命令。只有这样，我们才可以通过SSH的加密隧道安全地从本地系统向远程主机传输数据。</li><li>第二，在 destination 路径名前指定了远程主机名 (本例中的远程主机名是 remote-sys) 。</li><li>方法之二，使用 rsync 服务器同步网络文件，通过配置 rsync 运行一个守护进行监听进来的同步请求。这种方法通常用于远程系统的镜像备份。</li><li>例如，Red Hat 软件为发行其 Fedora 系统，需要维持一个正在开发的大的软件包库。对于软件测试员来说，在发行版的测试阶段创建这个大集合的备份时很重要的，因为库中的文件会频繁变动，所以通过周期性的同步来维持本地文件镜像要批量复制软件库更可取。</li><li>Georgia Tech 就维护了其中一个库，可以使用本地复制工具 rsync 以及 Georgia Tech 的 rsync 服务器来创建该库的镜像备份。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> fedora-devel</span><br><span class="line">[me@linuxbox ~]$ rsync -av -delete rsync://rsync.gtlib.edu/fedora-linux-core/development/i386/os fedora-devel</span><br></pre></td></tr></table></figure></li><li>本例中，使用 rsync 远程服务的 URI 是由协议 (rsync:&#x2F;&#x2F;) 、远程主机名 (rsync.gitlib.gatech.edu) 和库的路径名组成。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 进程</title>
      <link href="/post/cfd6444.html"/>
      <url>/post/cfd6444.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-进程"><a href="#第十章-进程" class="headerlink" title="第十章 进程"></a>第十章 进程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>现代操作系统通常都支持多重任务管理。</li><li>多重任务处理是指系统通过快速切换运行中的程序来实现多个任务的同时执行。</li><li>Linux 内核通过使用进程来管理多重任务。</li><li>进程是 Linux 用来安排不同程序等待 CPU 调度的一种组织方式。</li><li>有时候计算机运行速度会变得很慢，或者应用程序会停止响应。</li><li>本章将介绍命令行中可用来查看程序当前的运行情况以及终止运行异常的进程的一些工具：</li></ol><ul><li>ps: 实现当前所有进程的运行情况 </li><li>top: 实时显示当前所有任务的资源占用情况 </li><li>jobs: 列出所有活动作业的状态信息</li><li>bg: 设置在后台中运行作业</li><li>fg: 设置在前台中运行作业</li><li>kill: 杀死指定名字的进程</li><li>shutdown: 关机或者重启系统</li></ul><h2 id="进程如何工作"><a href="#进程如何工作" class="headerlink" title="进程如何工作"></a>进程如何工作</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>系统启动时，内核先把它的一些程序初始化为进程，然后运行一个称为 init 的程序。</li><li>init 程序将依次运行一系列称为脚本初始化  (init script) 的 shell 脚本 (放在 &#x2F;etc 目录下) ，这些脚本将会启动所有的系统服务。其中的很多服务都是通过守护程序 (daemon program) 来实现的。</li><li>后台程序只是呆在后台做它们自己的事情，并且没有用户界面。</li><li>因此，即使没有用户登录，系统也在忙于执行一些例行程序。</li><li>一个程序的运行可以触发其他程序的运行，在进程系统中这种情况被表述为父进程创建子进程。</li><li>内核会保存每个进程的信息以便确保任务有序进行。比如，每个进程将被分配一个称为进程 ID (PID ， Process ID) 的号码。</li><li>进程 ID 是按递增的顺序来分配的， init 进程的 PID 始终为 1 。</li><li>内核也记录分配给每个进程的内存信息以及用来恢复运行的进程的就绪信息。</li><li>和文件系统类似，进程系统中也存在所有者、用户ID 、有效用户ID 等。</li></ol><h3 id="使用-ps-命令来查看进程信息"><a href="#使用-ps-命令来查看进程信息" class="headerlink" title="使用 ps 命令来查看进程信息"></a>使用 ps 命令来查看进程信息</h3><ol><li>ps 基本介绍</li></ol><ul><li>用来查看进程信息的命令中 (有多个) ，使用最普遍的就是 ps 命令。 </li><li>ps 命令有很多选项，其中最简单的使用格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps</span><br><span class="line">PID   TTY    Time     CMD</span><br><span class="line">5198  pts/1 00:00:00  bash</span><br><span class="line">10129 pts/1 00:00:00  ps</span><br></pre></td></tr></table></figure></li><li>这个例子的输出结果列出了两个进程：进程 5198 和进程 10129 ，它们分别对应 bash 命令和 ps 命令。</li><li>我们可以发现，默认情况下， ps 命令输出的信息并不是很多，只是输出和当前终端会话相关的进程信息。</li><li>为了获取更多的信息，我们需要添加一些选项，但是在介绍这个之前，让我们先看看 ps 命令输出的其他字段信息。 </li><li>TTY 是 teletype (电传打字机) 的缩写，代表了进程的控制终端 (controlling terminal) 。</li><li>UNIX 在这里也显示了进程的运行时间， TIME 字段表示了进程消耗的 CPU 时间总和。</li><li>如果在 ps 命令后面添加一个选项，那么我们将得到反映系统运行情况的更大的视图界面。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps x</span><br><span class="line">PID    TTY    STAT    TIME    COMMAND</span><br><span class="line">2799    ?      Ss1    0:00    /usr/libexec/bonbb-activation-server -ac</span><br><span class="line">2820    ?      S1     0:01    /usr/libexec/evolution-data=server-1.10 --</span><br><span class="line">15647   ?      Ss     0:00    /bin/sh /usr/bin/statkde</span><br><span class="line">15751   ?      Ss     0:00    /usr/bin-ssh-agent /usr/bin/dbus-lauch --</span><br><span class="line">15754   ?      S      0:00    /usr/bin/dbus-lauch --<span class="built_in">exit</span> -with-session</span><br><span class="line">15755   ?      Ss     0:01    /bin/dbus-daemon --fork --print-pid 4 -<span class="built_in">pr</span></span><br><span class="line">15774   ?      Ss     0:02    /usr/bin/gpg-agent -s -daemon</span><br><span class="line">15793   ?      S      0:00    start_kdeinit --new-starup + kcminit_start</span><br><span class="line">15794   ?      Ss     0:00    kdeinit Runing...</span><br><span class="line">15797   ?      S      0:00    dcopserver -nosid</span><br><span class="line"></span><br><span class="line">and many more...</span><br></pre></td></tr></table></figure></li><li>添加 x 选项 (注意这里没有前置的连字符的连字符) 将告知 ps 命令显示所有的进程，而不需要关注它们是由哪个终端所控制。 </li><li>TTY 列中出现的 ? 表示没有控制终端，使用这个选项可以查看所有进程的列表信息。</li><li>把 ps 命令的输出作为 less 命令输入的方法通常很管用，它可以更方便地查看显示结果。</li></ul><ol start="2"><li>进程状态</li></ol><table><thead><tr><th align="center">状态</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">R</td><td align="center">运行状态。进程正在运行或者准备运行</td></tr><tr><td align="center">S</td><td align="center">睡眠状态。进程不在运行，而是等待某时间发生，如果键盘输入或者收到网络报文。</td></tr><tr><td align="center">D</td><td align="center">不可中断的睡眠状态。进程正在等待 I&#x2F;O 操作，如应判断动</td></tr><tr><td align="center">T</td><td align="center">暂停状态。进程被指示</td></tr><tr><td align="center">Z</td><td align="center">无效或者僵尸进程。子进程被终止，但是还没有被其父进程彻底释放掉</td></tr><tr><td align="center">&lt;</td><td align="center">高优先级进程。进程可以被赋予更多的重要性，分配更多的 CPU 时间。进程的这一特性成为优先级 (niceiness) 。高优先级的进程被说成较不友好，是因为它将消耗更多的 CPU 时间，这样留给其他进程的 CPU 时间就会变少</td></tr><tr><td align="center">N</td><td align="center">低优先级。低优先级 (a nice process) 只有在其他更高优先级的进程使用完处理器后才能够获得试用处理器的时间</td></tr></tbody></table><ol start="3"><li>ps aux 指令</li></ol><ul><li>ps 另一个常用的选项组合是 aux (不带前置连字符) ，它将输出更多的信息，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps aux</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TYY STAT START TIME COMMAND</span><br><span class="line">root 1    0.0 0.0  2136 644 ?  Ss   Mar05 0:31 init</span><br><span class="line">root 2    0.0 0.0  0    0   ?  S&lt;   Mar05 0:00 [kt]</span><br><span class="line">root 3    0.0 0.0  0    0   ?  S&lt;   Mar05 0:00 [mi]</span><br><span class="line">root 4    0.0 0.0  0    0   ?  S&lt;   Mar05 0:06 [ks]</span><br><span class="line">root 5    0.0 0.0  0    0   ?  S&lt;   Mar05 0:36 [wa]</span><br><span class="line">root 6    0.0 0.0  0    0   ?  S&lt;   Mar05 0:00 [ev]</span><br><span class="line">root 7    0.0 0.0  0    0   ?  S&lt;   Mar05 0:00 [kh]</span><br></pre></td></tr></table></figure></li><li>该选项组合将会显示属于每个用户的进程信息，使用这些选项时不带前置连字符将使得命令以 BSD 模式 (BSD-style) 运行。</li></ul><ol start="4"><li>BSD 模式下 ps 命令输出的列标题</li></ol><table><thead><tr><th align="center">标题</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">USER</td><td align="center">用户 ID：表示该进程的所有者</td></tr><tr><td align="center">%CPU</td><td align="center">CPU 使用百分比</td></tr><tr><td align="center">%MEM</td><td align="center">内存使用百分比</td></tr><tr><td align="center">VSZ</td><td align="center">虚拟耗用内存大小</td></tr><tr><td align="center">RSS</td><td align="center">实际使用的内存大小，进程使用的物理内存 (RAM) 大小 (以 KB 为单位)</td></tr><tr><td align="center">START</td><td align="center">进程开启的时间，如果数值超过 24 小时，那么将使用日期来表示</td></tr></tbody></table><h3 id="使用-top-命令动态查看进程信息"><a href="#使用-top-命令动态查看进程信息" class="headerlink" title="使用 top 命令动态查看进程信息"></a>使用 top 命令动态查看进程信息</h3><ol><li>top 基本介绍</li></ol><ul><li>虽然 ps 命令可以显示有关机器运行情况的很多信息，但是它提供的只是在 ps 被执行时刻机器状态的一个快照。</li><li>要查看机器运行情况的动态视图，我们可以使用 top 命令，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ top</span><br></pre></td></tr></table></figure></li><li>top 程序将按照进程活动的顺序，以列表的形式持续更新系统进程的当前信息 (默认每 3 秒更新一次) 。</li><li>top 主要用于查看系统最高 (top) 进程的运行情况，其名字也来源于此。</li><li>top 命令显示的内容包含两个部分，顶部显示的是系统总体状态信息，下面显示的是一张按 CPU 活动时间排序的进程情况表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top-14:59:20 up 6:30, 2users, load average: 0.07, 0.02, 0.00</span><br><span class="line">Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie</span><br><span class="line">Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%<span class="built_in">id</span>, 0.0%wa, 0.0%hi, 0.0%si</span><br><span class="line">Mem: 319496k total, 314860k used, 4636k free, 19392k buff</span><br><span class="line">Swap: 875500k total, 149128k used, 726372k free, 114676k cach</span><br><span class="line"></span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">6244 me 39 19 31752 3124 2188 S 6.3 1.0 16:24.42 trackerd</span><br><span class="line">11071 me 20 0 2304 1092 840 R 1.3 0.3 0:00.14 top</span><br><span class="line">6180 me 20 0 2700 1100 772 S 0.7 0.3 0:03.66 dbus-dae</span><br><span class="line">6321 me 20 0 20944 7248 6560 S 0.7 2.3 2:51.38 multiloa</span><br><span class="line">4955 root 20 0 104m 9668 5776 S 0.3 3.0 2:19.39 Xorg</span><br><span class="line">1 root 20 0 2976 528 476 S 0.0 0.2 0:03.14 init</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>top 细节说明</li></ol><table><thead><tr><th align="center">行</th><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">top</td><td align="center">程序名</td></tr><tr><td align="center"></td><td align="center">14:59:20</td><td align="center">一天中的当前时间</td></tr><tr><td align="center"></td><td align="center">up 6:30</td><td align="center">正常运行时间 (uptime) 。从机器最后一次启动开始计算的时间总数。在这个例子中，系统已经运行了 6.5 小时。</td></tr><tr><td align="center"></td><td align="center">2 users</td><td align="center">有两个用户已登录</td></tr><tr><td align="center"></td><td align="center">load average</td><td align="center">负载均衡 (load average) 指的是等待运行的进程数；即共享 CPU 资源的处于可运行状态的进程数。显示的三个值分别对应不同的时间段：第一个对应的是前 60 秒的均值，下一个对应的是前 5 分钟的均值，最后一个对应的是前 15 分钟的均值。该值小于 1.0 表示该机器并不忙</td></tr><tr><td align="center">2</td><td align="center">task</td><td align="center">统计进程数及各个进程的状态信息</td></tr><tr><td align="center"></td><td align="center">0.7%us</td><td align="center">0.7% 的 CPU 时间被用户进程占用，这里指的是处于内核外的进程</td></tr><tr><td align="center"></td><td align="center">1.0%sy</td><td align="center">1.0% 的 CPU 时间被系统进程 (内核进程) 占用</td></tr><tr><td align="center"></td><td align="center">0.0%ni</td><td align="center">0.0% 的 CPU 时间被友好进程 (低优先级进程) 占用</td></tr><tr><td align="center"></td><td align="center">98.3%id</td><td align="center">98.3% 的 cpu 时间是空闲的</td></tr><tr><td align="center"></td><td align="center">0.0%wa</td><td align="center">0.0% 的 CPU 时间用来等待 I&#x2F;O 操作</td></tr><tr><td align="center"></td><td align="center">Mem</td><td align="center">显示物理 RAM 的使用情况</td></tr><tr><td align="center"></td><td align="center">Swap</td><td align="center">显示交换空间 (虚拟内存) 的使用情况</td></tr></tbody></table><ol start="3"><li>top 补充说明</li></ol><ul><li>top 程序可以接受许多键盘指令，其中最常用的有两个：一个是 h ，输入后将显示程序的帮助界面；另一个是 q ，用来退出 top 命令。</li></ul><h2 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>xlogo 程序是由 X 窗口系统 (X Window System ，使得显示器支持图形化界面的底层引擎) ，提供的一个示例程序，他只是简单地显示一个包含 X 标识的可缩放窗口。</li><li>首先，我们认识一下实验对象。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br></pre></td></tr></table></figure></li><li>输入该命令后，包含该标识的一个小窗口将在屏幕的某个地方出现。有些系统中， xlogo 可能会输出一条告警信息，但是我们可以忽略它，因为它并不会造成什么影响。</li><li>如果系统中不包含 xlogo 程序，那么试着使用 gedit 程序或者 kwrite 程序来替代。</li><li>我们可以通过改变窗口的大小来验证 xlogo 是否处于运行状态。</li><li>如果该表示适应新的窗口大小被重新绘制了，则表明该程序正在运行。</li><li>如果关闭 xlogo 窗口，那么提示符将返回。</li></ol><h3 id="中断进程"><a href="#中断进程" class="headerlink" title="中断进程"></a>中断进程</h3><ol><li>首先，输入 xlogo 命令，并确保程序在正常运行。接下来，返回到终端窗口，按下 Ctrl-C 键。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure></li><li>在终端里按下 Ctrl-C 键会中断 (interrupt) 一个程序，它意味着我们委婉地请求程序结束。按下 Ctrl-C 键后， xlogo 窗口将关闭， shell 提示符将返回。</li></ol><h3 id="使进程在后台运行"><a href="#使进程在后台运行" class="headerlink" title="使进程在后台运行"></a>使进程在后台运行</h3><ol><li>假设我们想要 shell 提示符返回，但又不终止 xlogo 程序，那么可以通过让该程序在后台 (background) 运行来实现。</li><li>我们可以把终端想象为有一个前台 (foreground) 和一个后台。</li><li>要想在启动程序时让该程序在后台运行，可以在命令后面加上和号字符 &amp; 来实现。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 28236</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>命令执行后，将出现 xlogo 窗口，而且 shell 提示符也可以返回，但是同时也会打印一些有趣的数字信息。</li><li>这条信息是 shell 的一个称为作业控制 (job control) 的特性表现。</li><li>shell 通过这条这条信息来显示已经启动的作业编号为 1([1]) , 其对应的 PID 是 28236 。</li><li>如果执行 PS 命令，可以查看到当前运行的进程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ PS</span><br><span class="line">PID    TTY     TIME   CMD</span><br><span class="line">10603  pts/1   0:00:00 bash</span><br><span class="line">28236  pts/1   0:00:00 xlogo</span><br><span class="line">28239  pts/1   0:00:00 ps</span><br></pre></td></tr></table></figure></li><li>shell 的作业控制特性也提供了一种方式来查看从该终端启动的所有作业。</li><li>使用 jobs 命令可以得到如下信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">jobs</span></span><br><span class="line">[1]+Running       xlogo &amp;</span><br></pre></td></tr></table></figure></li><li>输出结果现实存在一个编号为 1 的作业在运行，而且对应命令是 xlogo &amp; 。</li></ol><h3 id="使进程回到前台运行"><a href="#使进程回到前台运行" class="headerlink" title="使进程回到前台运行"></a>使进程回到前台运行</h3><ol><li>后台运行的进程不会收到任何键盘输入的影响，包括试图用来中断它的 Ctrl-C 键。要想是的进程返回到前台来运行，可以使用 fg 命令来实现，参见下面的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">jobs</span></span><br><span class="line">[1]+Running       xlogo &amp;</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">fg</span> %1</span><br><span class="line">xlogo</span><br></pre></td></tr></table></figure></li><li>我们可以通过在 fg 后面加上百分比符号和作业编号 (称为 jobspec 选项) 来实现这个功能。如果后台只有一个任务，那么可以不带 jobspec 选项，这时候按下 Ctrl-C 键就可以终止 xlogo 命令。</li></ol><h3 id="暂停进程"><a href="#暂停进程" class="headerlink" title="暂停进程"></a>暂停进程</h3><ol><li>如果我们只是想要暂停进程，而不是终止进程，那么通常需要我们将前台运行的进程移到后台去运行。</li><li>我们为了暂停前提进程需要按下 Ctrl-Z 键，让我们试试如下操作，在命令提示符后输入 xlogo ，按下 Enter 键后再按下 Ctrl-Z 键。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxboy ~]$ xlogo</span><br><span class="line">[1] + Stopped   xlogo</span><br></pre></td></tr></table></figure></li><li>在暂停 xlogo 命令后，我们可以试图改变 xlogo 图口的大小来确认该程序是否被暂停了。</li><li>我们可以使用 fg 命令让进程在前台恢复运行，也可以使用 bg 命令让进程移到后台运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxboy ~]$ <span class="built_in">bg</span> %1</span><br><span class="line">[1]+xlogo %</span><br><span class="line">[me@linuxboy ~]$ </span><br></pre></td></tr></table></figure></li><li>在使用 fg 命令，如果只存在一个作业，那么可以不带 jobspec 选项。</li><li>如果用命令方式启动了一个图形化程序，但是忘了在命令尾部加上 &amp; 符号来让程序在后台进行，那么在这种情况下，把进程从前台移到后台去运行的方法将非常方便。</li></ol><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>kill 命令通常用来杀死进程，它可以用来终止运行不正常的程序或者反过来拒绝终止的程序。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxboy ~]$ xlogo &amp;</span><br><span class="line">[1] 28401</span><br><span class="line">[me@linuxboy ~]$ <span class="built_in">kill</span> 28401</span><br><span class="line">[1]+Terminated        xlogo</span><br></pre></td></tr></table></figure></li><li>我们首先在后台启动了 xlogo 程序， shell 将打印输出改后台进程的 jobspec 选项信息和 PID 信息。接着，我们使用了 kill 命令，并且指定想要终结进程的 PID 。我们也可以使用 jobspec 选项代替 PID 信息来指定该进程。</li><li>信号是操作系统和程序间通信的多种方式之一，在使用 Ctrl-C 键和 Ctrl-Z 键时已经见识过信号的作用。当终端接收到其中的一个输入时，它将发送信号到前台进程。</li><li>在按下 Ctrl-C 键的情况下，它发送一个称为 INT (中断，Interrupt) 的信号；在按下 Ctrl-Z 的情况下，它将发送一个称为 TSTP (中断暂停，Terminal Stop) 的信号。</li></ol><h3 id="使用-kill-命令发送信号到进程"><a href="#使用-kill-命令发送信号到进程" class="headerlink" title="使用 kill 命令发送信号到进程"></a>使用 kill 命令发送信号到进程</h3><ol><li>kill 基本介绍</li></ol><ul><li>kill 命令最常用的语法格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] PID...</span><br></pre></td></tr></table></figure></li><li>如果命令行中没有指定信号，那么默认发送 TERM (Terminate) 信号。</li></ul><ol start="2"><li>kill 常用信号</li></ol><table><thead><tr><th align="center">信号编号</th><th align="center">信号名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">HUP</td><td align="center">挂起信号。该信号用来指示程序控制终端已被挂起。该信号的效果通过关闭终端会话的方式来表现，运行在终端上的前台程序收到该信号后将终止。该信号也被很多后台程序用来进行重新初始化。这意味着，当一个后台进程接收到该信号时，它将重启并且重新读取它的配置文件。 Apache Web 服务器就是后台进程使用 HUP 信号重新初始化的一个例子</td></tr><tr><td align="center">2</td><td align="center">INT</td><td align="center">中断信号。执行效果何在终端按下 Ctrl-C 键的效果一样。通常用来终止一个程序</td></tr><tr><td align="center">9</td><td align="center">KILL</td><td align="center">杀死信号。该信号比较特殊。鉴于程序可以选择不同的方式来处理发送过来的信号，包括忽略所有的这些信号，KILL 信号将不会真正意义上地被发送到目标程序。而是内核宁愿立即终止了该进程。当进程以这种方式被终止时，压根没有机会对它自己进行清理或者对当前工作进行保存。考虑到这个原因，KILL 信号只能当作其他的终端信号都执行失败的情况下的最后选择。</td></tr><tr><td align="center">15</td><td align="center">TREM</td><td align="center">终止信号。这是 kill 命令默认发送的信号类型。如果程序仍然有足够的活力 (alive enough) 来接收信号，那么它将被终止</td></tr><tr><td align="center">18</td><td align="center">CONT</td><td align="center">继续运行信号。恢复之前即接受了 STOP 信号的进程</td></tr><tr><td align="center">19</td><td align="center">STOP</td><td align="center">暂停信号。该信号将使进程暂停，而不是终止。和 KILL 信号类似，该信号不会被发送给目标进程，因此它不能被忽略</td></tr></tbody></table><ol start="3"><li>kill 案例</li></ol><ul><li>按照下面的方式使用 kill 命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxboy ~]$ xlogo &amp;</span><br><span class="line">[1] 13546</span><br><span class="line">[me@linuxboy ~]$ <span class="built_in">kill</span> -1 13546</span><br><span class="line">[1]+Hangup              xlogo</span><br></pre></td></tr></table></figure></li><li>在这个例子中，我们首先在后台启动了 xlogo 程序，接着使用 kill 命令给它发送 HUP 信号。</li><li>xlogo 程序将终止， shell 的输出信息表明了这个后台进程已经接收了一个挂起信号。你也许需要多敲几次 Enter 键才能看到这条输出信息。</li><li>注意，你可以通过信号编号指定信号，其中包含带有 SIG 前缀的信号名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13601</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">kill</span> -INT 13601</span><br><span class="line">[1]+Interrupt       xlogo</span><br><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13608</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">kill</span> -SIGINT 13608</span><br><span class="line">[1]+Interrupt            xlogo</span><br></pre></td></tr></table></figure></li><li>和文件一样，进程也有所有者，只有进程的所有者 (或者超级用户) 才能使用 kill 命令来给它发送信号。</li></ul><ol start="4"><li>kill 其他常用信号</li></ol><table><thead><tr><th align="center">信号编号</th><th align="center">信号名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">QUIT</td><td align="center">退出信息</td></tr><tr><td align="center">11</td><td align="center">SEGV</td><td align="center">段错误信号。如果程序非法使用了内存空间，即程序试图在没有写权限的空间执行写操作，那么系统将发送该信号。</td></tr><tr><td align="center">20</td><td align="center">TSTP</td><td align="center">终端暂停信号。在按下 Ctrl-Z 键时终端将发出该信号。与 STOP 信号不同的是， TSTP 信号由程序接收，但是程序可以选择忽略该信号。</td></tr><tr><td align="center">28</td><td align="center">WHNCH</td><td align="center">窗口改变信号。当窗口改变大小的时，系统将发送该信号。类似 top 和 less 的一些程序将会对该信号作出响应，重新绘制视图来适应新的窗口大小。</td></tr></tbody></table><ol start="5"><li>kill 补充说明</li></ol><ul><li>如果想要查看更多的信号，使用如下命令将显示完整的信号列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-killall-命令发送信号给多个进程"><a href="#使用-killall-命令发送信号给多个进程" class="headerlink" title="使用 killall 命令发送信号给多个进程"></a>使用 killall 命令发送信号给多个进程</h3><ol><li>killall 基本介绍</li></ol><ul><li>通过使用 killall 命令，我们可以给指定程序或者指定用户名的多个进程发送信号。一般语法格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [-u user] [-signal] name...</span><br></pre></td></tr></table></figure></li><li>要证明这一点，我们可以先启动两个 xlogo 程序实例，然后终止它们。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 18801</span><br><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[2] 18802</span><br><span class="line">[me@linuxbox ~]$ killall xlogo</span><br><span class="line">[1]-Terminated         xlogo</span><br><span class="line">[2]-Terminated         xlogo</span><br></pre></td></tr></table></figure></li></ul><h2 id="更多与进程相关的命令"><a href="#更多与进程相关的命令" class="headerlink" title="更多与进程相关的命令"></a>更多与进程相关的命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">vmstat</td><td align="center">输出系统资源使用情况的快照，包括内存，交换空间和磁盘 I&#x2F;O 。如果想要持续查看输出，可以在命令后面加上一个间隔时间 (以秒为单位) ，命令将按照间隔时间来动态更新显示的内容。按下 Ctrl-C 键可以终止输出。</td></tr><tr><td align="center">tload</td><td align="center">类似于 xload 程序，但是图形是在终端上绘制。按下 Ctrl-C 键终止输出。</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三章 定制提示符</title>
      <link href="/post/4d6da864.html"/>
      <url>/post/4d6da864.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十三章-定制提示符"><a href="#第十三章-定制提示符" class="headerlink" title="第十三章 定制提示符"></a>第十三章 定制提示符</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章将会讲解一个看似微不足道的细节：shell 提示符。通过讲解，我们会发现 shell 和终端仿真器程序的内部工作机制。</li><li>和 Linux 中的很多程序一样，shell 提示符的可配置性很高。尽管大多数用户并不重视提示符，但是，一旦我们学会了怎样控制它，它就会成为一种相当有用的设备。</li></ol><h2 id="提示符的分解"><a href="#提示符的分解" class="headerlink" title="提示符的分解"></a>提示符的分解</h2><ol><li>基本介绍</li></ol><ul><li>系统的默认提示符看起来如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$</span><br></pre></td></tr></table></figure></li><li>提示符是由名为 PS1 (prompt string 1 的缩写，即提示符字符串 1) 的环境变量定义的。</li><li>echo 命令可以帮助用户看到 PS1 的值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line">[\u@\h \w]\$</span><br></pre></td></tr></table></figure></li><li>如果输出的结果同本书的范例不同，也不需要担心。每一个 Linux 发行版本对此提示符字符串的定义都会有所不同，有一些甚至定义的很奇怪。</li><li>PS1 包含了一些提示符中出现的符号，比如方括号、@ 符号和美元符号，但是其余的部分则令人困惑。</li></ul><ol start="2"><li>shell 提示符中使用的转义字符</li></ol><table><thead><tr><th align="center">转义字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">ASCII 铃声。在遇到该转义字符时，计算机发出哔哔声</td></tr><tr><td align="center">\d</td><td align="center">当前日期，以星期、月、日的形式表示，如 Mon May 26</td></tr><tr><td align="center">\h</td><td align="center">本地机器的主机名，但是不带域名</td></tr><tr><td align="center">\H</td><td align="center">完整的主机名</td></tr><tr><td align="center">\j</td><td align="center">当前 shell 会话中进行的任务个数</td></tr><tr><td align="center">\l</td><td align="center">当前终端设备的名称</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\s</td><td align="center">shell 程序的名称</td></tr><tr><td align="center">\t</td><td align="center">当前时间 (24小时制) ，格式为小时，分钟，秒</td></tr><tr><td align="center">\T</td><td align="center">当前时间 (12小时制)</td></tr><tr><td align="center">@</td><td align="center">当前时间 (12小时制，格式为 AM&#x2F;PM)</td></tr><tr><td align="center">\A</td><td align="center">当前 (24小时制) ，格式为小时：分钟</td></tr><tr><td align="center">\u</td><td align="center">当前用户的用户名</td></tr><tr><td align="center">\v</td><td align="center">shell 的版本号</td></tr><tr><td align="center">\V</td><td align="center">shell 的版本号和发行号</td></tr><tr><td align="center">\w</td><td align="center">当前工作目录名</td></tr><tr><td align="center">\W</td><td align="center">当前工作目录名称的最后一部分</td></tr><tr><td align="center">!</td><td align="center">当前命令的历史编号</td></tr><tr><td align="center">#</td><td align="center">当前 shell 会话中输入的命令数</td></tr><tr><td align="center">$</td><td align="center">在非管理权限下输出 $ 。在管理员权限下输出 #</td></tr><tr><td align="center">\[</td><td align="center">标志一个或多个非打印字符序列的开始。用于嵌入非打印的控制字符，使其以一定方式操纵终端仿真器，比如移动光标或更改文本颜色</td></tr><tr><td align="center">\]</td><td align="center">标志着非显示字符序列的结束</td></tr></tbody></table><h2 id="尝试设计提示符"><a href="#尝试设计提示符" class="headerlink" title="尝试设计提示符"></a>尝试设计提示符</h2><ol><li>通过这个特殊字符列表，我们可以更改提示符来查看效果。我们首先备份现有的字符串，以便过后进行恢复。</li><li>为此，将现有的字符串复制到我们创建的另外一个 shell 变量中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ ps1_old=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li>这样我们就创建了名为 ps1_old 的新变量，并将 PS1 的值赋给了 ps1_old 。我们可以使用 echo 命令来验证 PS1 的值确实已经被复制了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$ps_old</span></span><br><span class="line">[\u@\h \W]\$</span><br></pre></td></tr></table></figure></li><li>在终端会话中，用户随时可以通过这个过程的逆操作来复原最初的提示符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ PS1=<span class="string">&#x27;$ps1_old&#x27;</span></span><br></pre></td></tr></table></figure></li><li>现在一切准备就绪。接下来让我们看看如果提示符为空会发生什么。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ PS1=</span><br></pre></td></tr></table></figure></li><li>若提示符为空，那么用户不会得到任何提示。根本就没有提示字符串嘛！尽管提示符就在那里，但是系统并不会显示。这样的提示看起来很令人困惑，所以现在将提示符设置为最简略的内容。</li><li>这样就好多了，至少现在用户知道自己在做什么了。可以注意到双引号中末尾的空格。当显示提示符时，这个空格会把美元符号和光标分隔开。</li><li>在提示符中添加一个铃声。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PS1=<span class="string">&quot;\a\$&quot;</span></span><br></pre></td></tr></table></figure></li><li>这样以来，每当系统显示提示符的时候，用户都会听到哔哔声。虽然这可能会使用户感到厌烦，但是在一些情况下可能会很有帮助，比如可以在一个耗时特别长的命令执行完毕通知用户。</li><li>接下来，我们试着创建一个信息丰富的提示符，其中包括主机名和当天的时间信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PS1=<span class="string">&quot;\A \h \$&quot;</span></span><br></pre></td></tr></table></figure></li><li>如果我们需要记录某些任务的执行时间，在提示符中添加时间信息会比较有用。最后，我们定制一个类似于最初样式的提示符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:37 linuxbox $ PS1=<span class="string">&quot;&lt;\u@\h \W&gt;\$&quot;</span></span><br><span class="line">&lt;me@linuxbox ~&gt;$</span><br></pre></td></tr></table></figure></li></ol><h2 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h2><ol><li>基本介绍</li></ol><ul><li>大多数终端都会响应某些非打印字符序列，来控制光标位置、字符属性 (如颜色、粗体、文本闪烁等) 内容。</li><li>字符颜色是由发送到终端仿真器的一个 ANSI 转移代码来控制的，该转义代码嵌入到了要显示的字符流中。控制代码不会打印到屏幕上，而是被中断解释为一条指令。</li><li>在之前的表中可以看到，\[ 和 \] 这两个序列用来封装非打印字符串。一个 ANSI 转义代码以八进制 033 (该代码由转义键 [escape key] 产生开始) ，后面跟着一个可选的字符属性，之后是一条指令。</li><li>例如，将文本颜色设置为正常 (attribute&#x3D;0) 、黑色的代码是\033[0;30m 。</li></ul><ol start="2"><li>设置文本颜色的转义序列</li></ol><table><thead><tr><th align="center">字符序列</th><th align="center">文本颜色</th></tr></thead><tbody><tr><td align="center">\033[0;30m</td><td align="center">黑色</td></tr><tr><td align="center">\033[0;31m</td><td align="center">红色</td></tr><tr><td align="center">\033[0;32m</td><td align="center">绿色</td></tr><tr><td align="center">\033[0;33m</td><td align="center">棕色</td></tr><tr><td align="center">\033[0;34m</td><td align="center">蓝色</td></tr><tr><td align="center">\033[0;35m</td><td align="center">紫色</td></tr><tr><td align="center">\033[0;36m</td><td align="center">青色</td></tr><tr><td align="center">\033[0;37m</td><td align="center">淡灰色</td></tr><tr><td align="center">\033[1;30m</td><td align="center">深灰色</td></tr><tr><td align="center">\033[1;31m</td><td align="center">淡红色</td></tr><tr><td align="center">\033[1;32m</td><td align="center">淡绿色</td></tr><tr><td align="center">\033[1;33m</td><td align="center">黄色</td></tr><tr><td align="center">\033[1;34m</td><td align="center">淡蓝色</td></tr><tr><td align="center">\033[1;35m</td><td align="center">淡紫色</td></tr><tr><td align="center">\033[1;36m</td><td align="center">淡青色</td></tr><tr><td align="center">\033[1;37m</td><td align="center">白色</td></tr></tbody></table><ol start="3"><li>案例一</li></ol><ul><li>现在让我们尝试创造红色的提示符 (本书中表现为灰色) 。我们将相应的转义代码插入提示符的开端。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;me@linuxbox ~&gt;$ PS1 = <span class="string">&quot;\[\033[0;31m\]&lt;\u@\h \W&gt;\$&quot;</span></span><br><span class="line">&lt;me@linuxbox ~&gt;</span><br></pre></td></tr></table></figure></li><li>事实证明操作可行，但是此时用户输入的所有文字也变成红色。要修复这个问题，可以在提示符的末尾插入一条转移码，以通知终端仿真器回复到原来的颜色。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;me@linuxbox ~&gt;$ PS1=<span class="string">&quot;\[\033[0;31m\]&lt;\u@\h \W&gt;\$\[\033[0m\&quot;</span></span><br><span class="line"><span class="string">&lt;me@linuxbox ~&gt;$</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>设置背景颜色的转义序列</li></ol><table><thead><tr><th align="center">字符序列</th><th align="center">背景颜色</th></tr></thead><tbody><tr><td align="center">\033[0;40m</td><td align="center">黑色</td></tr><tr><td align="center">\033[0;41m</td><td align="center">红色</td></tr><tr><td align="center">\033[0;42m</td><td align="center">绿色</td></tr><tr><td align="center">\033[0;43m</td><td align="center">棕色</td></tr><tr><td align="center">\033[0;44m</td><td align="center">蓝色</td></tr><tr><td align="center">\033[0;45m</td><td align="center">紫色</td></tr><tr><td align="center">\033[0;46m</td><td align="center">青色</td></tr><tr><td align="center">\033[0;47m</td><td align="center">淡灰色</td></tr></tbody></table><ol start="5"><li>案例二</li></ol><ul><li>通过为第一个转义代码做一些修改，就可以创建带有红色背景的提示符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;me@linuxbox ~&gt;$ PS1=<span class="string">&quot;\[\033[0;41m\]&lt;\u@h \W&gt;\$\[\033[0m\]]&quot;</span></span><br></pre></td></tr></table></figure></li><li>用户除了正常 (0) 和粗体 (1) 属性外，还可以设置为下划线 (4) 、闪烁 (5) 和斜体 (7) 。</li></ul><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ol><li>基本介绍</li></ol><ul><li>转义代码也可以用来定位光标。比如在提示符出现的时候，这些转义代码通常用来在屏幕的不同位置 (比如屏幕上方的一角) 显示一个时钟或其他信息。</li></ul><ol start="2"><li>光标移动转义序列</li></ol><table><thead><tr><th align="center">转义码</th><th align="center">动作</th></tr></thead><tbody><tr><td align="center">\033[1;cH</td><td align="center">将光标移动至 1 行 c 列</td></tr><tr><td align="center">\033[nA</td><td align="center">将光标向上移动 n 行</td></tr><tr><td align="center">\033[nB</td><td align="center">将光标向下移动 n 行</td></tr><tr><td align="center">\033[nC</td><td align="center">将光标向前移动 n 个字符</td></tr><tr><td align="center">\033[nD</td><td align="center">将光标向后移动 n 个字符</td></tr><tr><td align="center">\033[2J</td><td align="center">清空屏幕并将光标移动至左上角 (第 0 行第 0 列)</td></tr><tr><td align="center">\033[K</td><td align="center">清空当前光标位置到行末的内容</td></tr><tr><td align="center">\033[s</td><td align="center">存储当前光标位置</td></tr><tr><td align="center">\033[u</td><td align="center">恢复之前存储的光标位置</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>通过使用这些代码，用户可以构建这样的一条提示符。每当提示符出现时，屏幕的上方会绘制出一个红色的横条，横条中有用黄色文本显示的时间。用于提示符的编码就是一个看起来很可怕的字符串：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[Om\033[u\]&lt;\u@\h \W&gt;\$&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>复杂提示符的分解</li></ol><table><thead><tr><th align="center">字符序列</th><th align="center">动作</th></tr></thead><tbody><tr><td align="center">\[</td><td align="center">开始一个非打印字符序列。其真正目的是为了让 bash 正确计算可见提示符的长度。如果没有该字符，命令行编辑功能无法正确定位光标</td></tr><tr><td align="center">\033[s</td><td align="center">存储光标位置。在屏幕的顶部横条绘制完成并显示时间后，读取并使光标返回此位置。需要注意的是，一些终端仿真器不支持该代码</td></tr><tr><td align="center">\033[0;0H]</td><td align="center">将光标移动至左上角，即第 0 行第 0 列</td></tr><tr><td align="center">\033[0;41m]</td><td align="center">将背景颜色设置为红色</td></tr><tr><td align="center">\033[K</td><td align="center">将光标当前位置 (左上角) 到行末的内容清空。因为现在背景颜色已经是红色了，所以清空后的行就是红色，也就会绘出了红色的横条。需要注意的是清空行的内容并不会改变光标的位置，光标仍处于屏幕左上角</td></tr><tr><td align="center">\033[1;33m</td><td align="center">将文本颜色设置为黄色</td></tr><tr><td align="center">\t</td><td align="center">显示当前时间。尽管这是一个可打印的元素，但是还是将其包含在提示符非打印部分中，这是因为 bash 在计算可见提示符的长度时，不应当将其计算在内</td></tr><tr><td align="center">\033[0m</td><td align="center">关闭颜色。对文本和背景均有效</td></tr><tr><td align="center">\033[u</td><td align="center">恢复之前存储的光标位置</td></tr><tr><td align="center">\]</td><td align="center">结束非打印的字符序列</td></tr><tr><td align="center">&lt;\u@\h \W&gt;$</td><td align="center">提示符字符串</td></tr></tbody></table><h2 id="保存提示符"><a href="#保存提示符" class="headerlink" title="保存提示符"></a>保存提示符</h2><ol><li>很显然，用户不会想要每次都输入这样一长串代码，所以就需要将提示符存储在某个地方。将提示符添加到 .bashrc 文件中是一个一劳永逸的解决方法。也就是将以下两行代码添加到文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[Om\033[u\]&lt;\u@\h \W&gt;\$&quot;</span></span><br><span class="line"><span class="built_in">export</span> PS1</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十九章 正则表达式</title>
      <link href="/post/cf182f8f.html"/>
      <url>/post/cf182f8f.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十九章-正则表达式"><a href="#第十九章-正则表达式" class="headerlink" title="第十九章 正则表达式"></a>第十九章 正则表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在下面几章，我们已经知道，文本数据在类 UNIX 系统中扮演这非常重要的角色。</li><li>但是，在领略这些工具强大的功能前，我们还是先看一下经常与这些工具的复杂用法相关联的技术-正则表达式。</li><li>前面我们已经接触命令行提供的许多特性和工具，并且也遇到过一些相当神秘的 shell 特性及命令。比如 shell 扩展和引用、键盘快捷键和命令历史记录等，更不用提 vi 编辑器了。</li><li>正则表达式也延续了这种传统，而且可以说是众多特性中最神秘的一个。</li></ol><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><ol><li>简单地说，正则表达式是一种符号表示法，用于识别文本模式。在某种程度是上，它们类似于匹配文件和路径名时使用的 shell 通配符，但其用途更广泛。</li><li>许多命令行工具和大多数编程语言都支持正则表达式，以此来解决文本操作方面的问题。</li><li>然而，在不同的工具，以及不同的编程语言之间，正则表达式都会略有不同，这让事情进一步麻烦起来。</li><li>方便起见，我们将正则表达式的讨论限定在 POSIX 标准中，与许多编程语言不同，这些编程语言使用的符号集要更多一些。</li></ol><h2 id="grep-文本搜索"><a href="#grep-文本搜索" class="headerlink" title="grep - 文本搜索"></a>grep - 文本搜索</h2><ol><li>grep 基本介绍</li></ol><ul><li>我们用来处理正则表达式的主要程序是 grep 。</li><li>grep 名字源于 global regular expression print ，由此可以看到，grep 与正则表达式有关。</li><li>实际上，grep 搜索文本文件中于指定正则表达式匹配的行，并将结果送至标准输出。</li><li>目前为止，我们已经利用 grep 搜索了固定的字符串，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@liunxbox ~]$ <span class="built_in">ls</span> /usr/bin | grep zip</span><br></pre></td></tr></table></figure></li><li>该命令行的作用是列出 &#x2F;usr&#x2F;bin 目录下文件名包含 zip 字符串的所有文件。</li><li>grep 程序按照如下方式接受选项和参数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure></li><li>其中字符串 regex 代表的是整个正则表达式。</li></ul><ol start="2"><li>grep 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">忽略大小写。不区分大写和小写字符，也可以用 --ignore-case 指定</td></tr><tr><td align="center">-v</td><td align="center">不匹配。正常情况下， grep 会输出匹配行，而该选项可使 grep 输出不包含匹配项的所有行。也可以用 --invert-match 指定</td></tr><tr><td align="center">-c</td><td align="center">输出匹配项文件名而不是直接输出匹配行自身。也可以用 --files-without-matches 指定</td></tr><tr><td align="center">-n</td><td align="center">在每个匹配行前面加上该行在文件内的行号。也可以用 --line-number 指定</td></tr><tr><td align="center">-h</td><td align="center">进行多文件搜索时，抑制文件名输出。也可以用 --no-filename 指定</td></tr></tbody></table><ol start="3"><li>grep 案例</li></ol><ul><li>为了全面地了解 grep ，我们创建几个文本文件来进行搜索。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@liunxbox ~]$ <span class="built_in">ls</span> /bin &gt; dirlist-bin.txt</span><br><span class="line">[me@liunxbox ~]$ <span class="built_in">ls</span> /usr/bin &gt; dirlist-usr-bin.txt</span><br><span class="line">[me@liunxbox ~]$ <span class="built_in">ls</span> /sbin &gt; dirlist-sbin.txt</span><br><span class="line">[me@liunxbox ~]$ <span class="built_in">ls</span> /usr/sbin &gt; dirlist-usr-sbin.txt</span><br><span class="line">[me@liunxbox ~]$ <span class="built_in">ls</span> dirlist*.txt</span><br><span class="line">dirlist-bin.txt dirlist-sbin.txt dirlist-usr-sbin.txt dirlist-usr-bin.txt</span><br></pre></td></tr></table></figure></li><li>我们可以对文件列表执行简单搜索，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@liunxbox ~]$ grep bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br></pre></td></tr></table></figure></li><li>本例中，grep 命令会搜索所有的文件，以查找字符串 bzip ，并找到了两个匹配项，而且这两个匹配项都在文件 dirlist-bin.txt 里。</li><li>如果我们只对包含匹配项的文件感兴趣而不是对匹配项本身感兴趣，可以指定 -l 选项。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt</span><br></pre></td></tr></table></figure></li><li>相反，如果那只想查看那些不包含匹配项的文件，则可以用如下命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br><span class="line">dirlist-usr-sbin.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="元字符和文字"><a href="#元字符和文字" class="headerlink" title="元字符和文字"></a>元字符和文字</h2><ol><li>虽然看起来不是很明显，但 grep 搜索一直都在使用正则表达式，尽管那些例子都很简单。</li><li>正则表达式 bzip 用于匹配文本中至少包含 4 个字符、存在连续的按 b、z、i、p 顺序组成的字符串的行。</li><li>字符串 bzip 中的字符都是文字字符，即它们只能与自身进行匹配。除了文字字符，正则表达式还可以包含用于指定更为复杂的匹配的元字符。正则表达式的元字符包括以下字符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ $ . [ ] &#123;&#125; - ? * + () | \</span><br></pre></td></tr></table></figure></li><li>其他所有字符则被当做文字字符，但是在极少数的情况下，反斜杠字符用来创建元序列，以及用来对元字符进行转义，使其称为文字字符，而在被解释为元字符。</li><li>可以看到，当 shell 在执行扩展时，许多正则表达式的元字符在 shell 中具有特殊的含义。</li><li>所以，在命令行中输入包含元字符的正则表达式时，应把这些元字符用引号括起来以避免不必要的 shell 扩展。</li></ol><h2 id="任意字符"><a href="#任意字符" class="headerlink" title="任意字符"></a>任意字符</h2><ol><li>接下来讨论的第一个元字符是点字符或者句点字符，该字符用于匹配任意字符。如果将其加进某个正则表达式中，它将会在对应位置匹配任意字符。</li><li>下面就是一个应用实例。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;.zip&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li><li>上述命令行，搜索到了所有匹配正则表达式 .zip 的命令行，但其输出结果有一些有趣的地方，比如说输出中并没有包含 zip 程序，这是因为正则表达会中的 . 元字符将匹配长度增加到了 4 个字符。</li><li>而 zip 只包含了三个字符，所以不匹配。同样，如果列表中某个文件包含了文件扩展名 .zip ，那么该文件也会被认为是匹配文件，因为文件扩展名中的 . 符号也被当做任意字符处理了。</li></ol><h2 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h2><ol><li>插入符 ^ 和美元符号 $ 在正则表达式只与行的开头 ^ 或是末尾 $ 的内容进行匹配比较。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;zip$&#x27;</span> dirlist*.txt</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip$&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br></pre></td></tr></table></figure></li><li>上例中搜索的是行开头、行末尾都有字符串 zip (例如 zip 自动成一行) 的文件。请注意，正则表达式 ^$ (行开头和末尾之间没有字符) 将会匹配空行。</li></ol><h2 id="中括号表达式和字符类"><a href="#中括号表达式和字符类" class="headerlink" title="中括号表达式和字符类"></a>中括号表达式和字符类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>中括号除了可以用于匹配正则表达式中给定位置的任意字符外，还可以用匹配指定字符集中单个字符。借助于中括号，我们可以指定要匹配的字符集 (也包括那些可能会被解释为元字符的字符) 。</li><li>如下命令行则利用了一个两个字母组成的字符集，用于匹配包含 bzip 或 gzip 字符串的文本行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gzip</span><br></pre></td></tr></table></figure></li><li>一个字符集可以包含任意数目的字符，并且当元字符放置到中括号中时，会失去它们的特殊含义。然而，在两种情况下，则会在中括号中使用元字符；并且当元字符放置到中括号中时，会失去它们的特殊含义。</li><li>然而，在两种情况下，则会在中括号中使用元字符，并且会有不同的含义。</li><li>第一个就是插入符 ^ ，它在中括号内使用表示否定；另外一个是连字符 - ，表示字符范围。</li></ol><h3 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h3><ol><li>如果中括号内的第一个字符是插入符 ^ ，那么剩下的字符则被当作不应该在指定位置出现的字符集。</li><li>作为演示，我们对前面的例子稍作修改。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[^bg]zip&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li><li>通过使用否定操作，我们可以得到哪些包含 zip 字符但 zip 前面既不是 b 也不是 g 的所有程序。请注意，此时 zip 命令仍然没有出现在结果列表中，由此可见否定，字符集仍然需要在指定位置有对应字符，只不过这个字符不是否定字符集中的成员而已。</li><li>插入符号 ^ 只有是中括号表达式中的第一个字符时才会被当作否定符，如果不是第一个，^ 将会丧失其特殊含义而成为普通字符。</li></ol><h3 id="传统字符范围"><a href="#传统字符范围" class="headerlink" title="传统字符范围"></a>传统字符范围</h3><ol><li>如果我们希望建立一个正则表达式，用于查找文件名以答谢字母开头的文件，可以用下面的命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[ABCDEFGHIJKLMNOPQRSTUVWXZY]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li><li>这仅仅是将 26 个大写字母写入中括号的小事，但是要输入 26 个字母是在有点麻烦，我们可以用下面的简单方法完成。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Z]&#x27;</span> dirlist*.txt</span><br><span class="line">MAKEDEV</span><br><span class="line">ControlPanel</span><br><span class="line">GET</span><br><span class="line">HEAD</span><br><span class="line">POST</span><br><span class="line">X</span><br><span class="line">X11</span><br></pre></td></tr></table></figure></li><li>通过使用三个字符表示的字符范围，我们可以缩写这 26 个字母。能够按照这种方式表达的任何字符范围可以包含多个范围，比如下面这个表达式可以匹配以字母和数字开头的所有文件名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Za-z0-9]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li><li>在字符范围中，可以看到连字符有了特殊的用法，那么如何在中括号中真正包括一个连字符字符，可将连字符作为中括号内的第一个字符，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[-AZ]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li><li>匹配的则是文件名包含连字符、大写字母 A 或大写字母 Z 的文件。</li></ol><h3 id="POSIX-字符类"><a href="#POSIX-字符类" class="headerlink" title="POSIX 字符类"></a>POSIX 字符类</h3><ol><li>基本介绍</li></ol><ul><li>传统的字符范围表示方法很容易理解，而且能够有效、快速地指定字符集。</li><li>但不足之处在于，他并不是所有情况都是用。虽然到目前为止，在使用 grep 命令时还没有遇到过任何问题，但是在其他程序中则可能会遇到问题。</li><li>在第 4 章，我们讨论了如何使用通配符来执行路径名扩展。在该讨论中我们提到，字符范围的用法几乎与其正则表达式中一致，现在问题出现了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*</span><br><span class="line">/usr/sbin/MAKEFLOPPIES</span><br><span class="line">/usr/sbin/NetworkManagerDispatcher</span><br></pre></td></tr></table></figure></li><li>Linux 发行版本不同，上述命令行得到的结果可能会不同，甚至有可能是空列表。本例中的列表来自于 Ubuntu 系统。该命令行得到预期效果-只有一大些字母开头的文件列表。但是，如果我们使用下面的命令行，便会得到完全不同的结果 (只显示了输出结果的一部分) 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[A-Z]*</span><br><span class="line">/usr.sbin/biosdecode</span><br><span class="line">/usr/sbin/chat</span><br><span class="line">/usr/sbin/chpasswd</span><br><span class="line">/usr/sbin/chroot</span><br></pre></td></tr></table></figure></li><li>在 UNIX 开发初期，它只识别 ASCII 字符，而正是这一特性导致了上面的差异。在 ASCII 码中，前 32 个字符 (第 0-32 字符) 都是控制字符 (像 Tab 键、空格键以及 Enter 键等) ，后 32 个字符 (第 32-63) 包含可打印字符，包括大多数的标点符号以及数字 0-9 ，接下来的 32 个 (第 64-95) 包含大写字母和一些标点符号，最后的 31 个 (第 96-127) 则包含小写字母以及更多的标点符号。基于这样的安排，使用 ASCII 的系统使用了下面这种排序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure></li><li>这与通常的字典顺序不一样，字典中的字母的顺序表通常如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbBcCdDeEfFGhHiIjJKKlLmMnNoOpPqQrRsStuUvVwWxXyYzZ</span><br></pre></td></tr></table></figure></li><li>随着 UNIX 在美国以外国家的普及，人们越来越希望计算机能支持没事英语中找不到的字符。于是，ASCII 字符表也得以扩展，开始使用 8 位二进制来表示，这也就增加了第 188~255 的字符，兼容了更多的语言。</li><li>为了支持这种功能，POSIX 标准引入域 (locale) 的概念，它通过不停调整以选择特定的位置所需要的字符集。我们可以使用下面的命令行查看系统的语言设置。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure></li><li>有了这个设置，POSIX 兼容的应用程序使用的便是字典中的字典排行顺序，而不是用 ASCII 码中的字符排序顺序。这样，便解释了上面命令行的诡异行为。</li><li>A-Z 的字符范围，用字典的顺序全是时，包括了字母表中出了小写字母 a 的所有字母，因此使用命令行 ls&#x2F;usr&#x2F;sbin&#x2F;[A-Z]* 才会出现全然不同的结果。</li></ul><ol start="2"><li>POSIX 字符类</li></ol><table><thead><tr><th align="center">字符串</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">字母字符和数字字符；在 ASCII 码中，与 [A-Za-z0-9] 等效</td></tr><tr><td align="center">[:word:]</td><td align="center">基本与 [:alnum] 一样，只是多了一个下划线字符 (_)</td></tr><tr><td align="center">[:alpha:]</td><td align="center">字母字符：在 ASCII 中，等效于 [A-Za-z]</td></tr><tr><td align="center">[:bank:]</td><td align="center">包括空格和制表符</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">ASCII 控制码: 包括 ASCII 字符 0~31 以及 127</td></tr><tr><td align="center">[:digit:]</td><td align="center">数字 0~9</td></tr><tr><td align="center">[:graph:]</td><td align="center">可见字符；在 ASCII 中，包括字符 33~126</td></tr><tr><td align="center">[:lower:]</td><td align="center">小写字母</td></tr><tr><td align="center">[:punct:]</td><td align="center">标点符号字符；在 ASCII 中，与 [-!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[\]_{</td></tr><tr><td align="center">[:print:]</td><td align="center">可打印字符；包括 [:graph:] 中的所有字符再加上空格字符</td></tr><tr><td align="center">[:space:]</td><td align="center">空白字符如空格符、制表符、回车符、换行符、垂直制表符以及换页符。在 ASCII&#96; 中，等效为 [\t\r\n\v\f]</td></tr><tr><td align="center">[:upper:]</td><td align="center">大写字母</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">用于表示十六进制的字符；在 ASCII 中，与 [0-9A-Fa-f] 等效</td></tr></tbody></table><ol start="3"><li>POSIX 补充说明</li></ol><ul><li>当然，即便是有了这么多字符类，仍然没有比较方便的方法表示部分范围，如 [A-M] 。</li><li>使用字符类，我们可以重复上述大写字母的例子，并得到改善的输出结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[[:upper:]]*</span><br><span class="line">/usr/sbin/MAKEFLOPPIES</span><br></pre></td></tr></table></figure></li><li>然而，请记住，上述并不是一个正则表达式的示例，它其实是 shell 路径名扩展的一个例子。在此处提及，主要是因为这两种用法都支持 POSIX 字符类。</li></ul><h2 id="POSIX-基本正则表达式和扩展正则表达式的比较"><a href="#POSIX-基本正则表达式和扩展正则表达式的比较" class="headerlink" title="POSIX 基本正则表达式和扩展正则表达式的比较"></a>POSIX 基本正则表达式和扩展正则表达式的比较</h2><ol><li>POSIX 规范将正则表达式的实现方式分为了两种：基本正则表达式 (BRE) 和扩展正则表达式 (ERE) 。</li><li>在 BRE 方式中，只承认 ^、$、. 、[、]、* 这些事元字符，所有其他的字符都被识别为文字字符。而在ERE中，添加了(、)、{、}、?、+|、等元字符 (及其相关功能) 。</li><li>只有在用反斜杠进行转义的情况下，字符 (、)、{、} 才会被当做元字符处理，而 ERE 中，任何元字符前面加入反斜杠反而会使其被当作文字字符来处理。</li><li>由于下面要讨论的特性是 ERE 的一部分，所以需要使用不一样的 grep 。传统上，这是由 egrep 程序来执行的，但是 GNU 版本的 grep 可以运用 -E 选项以支持 ERE 方式。</li></ol><h2 id="或选项"><a href="#或选项" class="headerlink" title="或选项"></a>或选项</h2><ol><li>我们将要讨论的第一个扩展正则表达式的特性是或选项 (alternation) ，它是用于匹配表达式集的工具。括号表达式可以从指定字符集匹配单一字符，而或选项则用于从字符串或正则表达式集中寻求匹配项。</li><li>首先，我们进行一个简单的子字符串匹配<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep <span class="string">&quot;AAA&quot;</span></span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;BBB&quot;</span> | grep <span class="string">&quot;AAA&quot;</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>这是一个直白的例子，将 echo 的输出结果送至 grep 进行匹配搜索。如果匹配成功，结果便输出打印出来，如无匹配项，则无结果输出。</li><li>现在添加或选项，它用元字符 | 表示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep -E <span class="string">&quot;AAA|BBB&quot;</span></span><br><span class="line"></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;BBB&quot;</span> | grep -E <span class="string">&quot;AAA|BBB&quot;</span></span><br><span class="line">BBB</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;CCC&quot;</span> | grep -E <span class="string">&quot;AAA|BBB&quot;</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>这里出现了 “AAA|BBB” 正则表达式，此表达式的含义是匹配字符串 AAA 或者匹配字符串 BBB 。请注意，由于此处使用的是扩展特性，所以 grep 增加了 -E 选项 (虽然可以使用 egrep 命令来代替) ，并且将正则表达式用引号引起来以防止 shell 将元字符 | 当做管道操作符来处理。</li><li>另外或选项并不局限于两种选择，还可以有更多的选择项。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep -E <span class="string">&quot;AAA|BBB|CCC&quot;</span></span><br><span class="line">AAA</span><br></pre></td></tr></table></figure></li><li>为了将或选项可与其他正则表达式符号结合使用符号结合使用，我们可以用 () 将或选项的所有元素与其他符号隔开。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Eh <span class="string">&quot;^(bz|gz|zip)&quot;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li><li>以上表达式的含义是匹配以 bz、gz 或是 zip 开头的文件。如果不使用括号 () ，该正则表达式的含义就完全不同，其匹配的便是文件名以 bz 开头或者是包含 gz 和 zip 文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Eh <span class="string">&quot;^bz|gz|zip&quot;</span> dirlist*.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>扩展正则表达式 (ERE) 提供多种方法指定某元素匹配的次数。</li></ul><h3 id="匹配某元素-0-次或-1-次"><a href="#匹配某元素-0-次或-1-次" class="headerlink" title="? - 匹配某元素 0 次或 1 次"></a>? - 匹配某元素 0 次或 1 次</h3><ol><li>该限定符实际上意味着前面的元素可选。</li><li>所谓电话号码有效，指的是电话号码必须是下面两种形式 (nnn)nnn-nnnn 和 nnn nnn-nnnn 中的一种，其中 n 是数值。于是，我们构造如下所示的正则表达式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure></li><li>此表达式中，括号字符的后面增加了 ? 符号以表示括号字符只能匹配一次或零次。同样，由于括号字符在 ERE 中通常是元字符，所以其前面加上了反斜杠告诉 shell 此括号为文字字符，所以其前面加上了反斜杠告诉 shell 此括号为文字字符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;(555) 123-4567&quot;</span> | grep -E <span class="string">&quot;^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&quot;</span></span><br><span class="line">(555) 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;555 123-4567&quot;</span> | grep -E <span class="string">&quot;^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&quot;</span></span><br><span class="line">555 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA 123-4567&quot;</span> | grep -E <span class="string">&quot;^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&quot;</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>由此可以看出，该表达式匹配了上述两种形式的电话号码，但不匹配那些非数字字符的号码。</li></ol><h3 id="匹配某元素多次或零次"><a href="#匹配某元素多次或零次" class="headerlink" title="* - 匹配某元素多次或零次"></a>* - 匹配某元素多次或零次</h3><ol><li>与 ？元字符类似，* 用于表示一个可选择的条目。然后，与 ? 不同，该条目可以多次出现，而不仅仅是一次。</li><li>例如，如果我们想知道一串字符是否是一句话，也就是说，这串字符是否以大写字母开头而以句号结束，并且中间内容是任意数目的大小写字母和空格，那么要匹配这种非常粗糙的句子定义，可以用如下正则表达式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[:upper:]][[:upper:][:lower:] ]*\.</span><br></pre></td></tr></table></figure></li><li>该表达式匹配前两个测试语句，但是不匹配第三个，原因是它的首字母不是大写并且末尾没有句号。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This works.&quot;</span> | grep -E <span class="string">&quot;[[:upper:]][[:upper:][:lower:] ]*\.&quot;</span></span><br><span class="line">This works.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This Works.&quot;</span> | grep -E <span class="string">&quot;[[:upper:]][[:upper:][:lower:] ]*\.&quot;</span></span><br><span class="line">This Works.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;this does not&quot;</span> | grep -E <span class="string">&quot;[[:upper:]][[:upper:][:lower:] ]*\.&quot;</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>该表达式匹配前面两个测试语句，但是不匹配第三个，原因是它的首字母不是大写并且末尾没有句号。</li></ol><h3 id="匹配某元素一次或多次"><a href="#匹配某元素一次或多次" class="headerlink" title="+ - 匹配某元素一次或多次"></a>+ - 匹配某元素一次或多次</h3><ol><li><ul><li>元字符与 * 非常类似，只是 + 要求置于其前面的元素至少出现一次。</li></ul></li><li>示例如下，该正则表达式用于匹配由单个空格分隔的一个或者多个字母字符组成的行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([[:alpha:]+ ?])+$</span><br></pre></td></tr></table></figure></li><li>示例如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This that&quot;</span> | grep -E <span class="string">&quot;^([[:alpha:]]+ ?)+$&quot;</span></span><br><span class="line">This that</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b c&quot;</span> | grep -E <span class="string">&quot;^([[:alpha:]]+ ?)+$&quot;</span></span><br><span class="line">a b c</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b 9&quot;</span> | grep -E <span class="string">&quot;^([[:alpha:]]+ ?)+$&quot;</span></span><br><span class="line">[me@linuxbox ~]$</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b  d&quot;</span> | grep -E <span class="string">&quot;^([[:alpha:]]+ ?)+$&quot;</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>我们可以看到此表达式并不匹配 a b 9 这一行，因为该行包含了非字母字符 9 ，同样也不匹配 abc  d 这一行，因此c和d之间被多个空格符分开了</li></ol><h3 id="以指定次数匹配某元素"><a href="#以指定次数匹配某元素" class="headerlink" title="{} - 以指定次数匹配某元素"></a>{} - 以指定次数匹配某元素</h3><ol><li>{} 指定匹配次数</li></ol><table><thead><tr><th align="center">指定项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">{n}</td><td align="center">前面的元素恰好出现 n 次则匹配</td></tr><tr><td align="center">{n,m}</td><td align="center">前面的元素出现的次数在 n~m 次之间时则匹配</td></tr><tr><td align="center">{n,}</td><td align="center">前面的元素出现次数超过 n 次则匹配</td></tr><tr><td align="center">{,m}</td><td align="center">前面的元素出现次数不超过 m 次则匹配</td></tr></tbody></table><ol start="2"><li>{} 案例</li></ol><ul><li>回到前面电话号码的例子，我们可以运用此处讲到的指定重复次数的方法将原来的正则表达式 “^(?[0-9][0-9][0-9])? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]” 简化为 “^(?[0-9]{3})? [0-9]{3}-[0-9]{4}”</li><li>示例如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;(555) 123-4567&quot;</span> | grep -E <span class="string">&quot;^\(?[0-9]&#123;3&#125;\)? [0-9]&#123;3&#125;-[0-9]&#123;4&#125;&quot;</span></span><br><span class="line">(555) 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;555 123-4567&quot;</span> | grep -E <span class="string">&quot;^\(?[0-9]&#123;3&#125;\)? [0-9]&#123;3&#125;-[0-9]&#123;4&#125;&quot;</span></span><br><span class="line">555 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;5555 123-4567&quot;</span> | grep -E <span class="string">&quot;^\(?[0-9]&#123;3&#125;\)? [0-9]&#123;3&#125;-[0-9]&#123;4&#125;&quot;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure></li><li>结果表明，修改后的表达式不管有无括号都可验证数字的有效性，并剔除那些格式不正确的数字。</li></ul><h2 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>让我们回顾一些前面已经用过的命令，观察它们如何使用正则表达式。</li></ol><h3 id="用-grep-命令验证号码簿"><a href="#用-grep-命令验证号码簿" class="headerlink" title="用 grep 命令验证号码簿"></a>用 grep 命令验证号码簿</h3><ol><li>前面的例子中，我们只验证了一个电话号码的有效性，而检验一个号码列表往往才是实际需求，所以我们先创建一个号码列表。</li><li>于是，我们在命令行中输入一些神奇的咒语以创建号码列表，之所以称其为神奇是因为里面多数命令到目前为止本书还未涉及到。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;(<span class="variable">$&#123;RANDOM:0:3&#125;</span>) <span class="variable">$&#123;RANDOM:0:3&#125;</span>-<span class="variable">$&#123;RANDOM:0:4&#125;</span>&quot;</span> &gt;&gt; phonelist.txt; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li>该命令行会产生一个包含 10 个电话号码的名为 phonelist.txt 的文件。每次重复该命令行，该列表就会添加 10 个号码。我们也可以通过更改命令行前端的数字 10 来指定创建更多或更少的电话号码。</li><li>然而，如果检查文件内容，我们就会发现如下问题。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> phonelist.txt</span><br><span class="line">(263) 302-9778</span><br><span class="line">(120) 109-1260</span><br><span class="line">(986) 320-2757</span><br><span class="line">(276) 946-6691</span><br><span class="line">(287) 127-1098</span><br><span class="line">(176) 148-5524</span><br><span class="line">(144) 134-2784</span><br><span class="line">(200) 175-1285</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br></pre></td></tr></table></figure></li><li>其中有部分数字是畸形的，而这正好满足我们的练习要求，因为接下来就是要用 grep 判断它们的有效性。</li><li>进行有效验证，可对文件内容进行扫描以搜索无效数字，并将结果显示出来。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Ev <span class="string">&quot;^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$ phonelist.txt</span></span><br><span class="line"><span class="string">(292) 108-518</span></span><br><span class="line"><span class="string">(129) 44-1379</span></span><br><span class="line"><span class="string">[me@linuxbox ~]$</span></span><br></pre></td></tr></table></figure></li><li>此处我们使用 -v 选项输出相反的结果，也就是输出列表中不符合指定表达式的那些行。此表达式本身在每行末尾使用锚元字符，从而确保每个数字末尾没有多余的字符。</li></ol><h3 id="用-find-查找奇怪的文件名的文件"><a href="#用-find-查找奇怪的文件名的文件" class="headerlink" title="用 find 查找奇怪的文件名的文件"></a>用 find 查找奇怪的文件名的文件</h3><ol><li>find 命令的 test 选项可以用正则表达式表示。运用正则表达式时，find 和 grep 有一点不同，grep 命令是搜索哪些只包含与指定表达式匹配的字符串的行，而 find 则要求文件名与指定表达式完全一致。</li><li>下面的例子中，我们将利用 find 命令结合正则表达式来查找文件名中不包含如下所示集合中的任一字符的文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-_./0-9a-zA-Z]</span><br></pre></td></tr></table></figure></li><li>用此表达式进行搜索，将会输出文件名中包含内嵌空格以及其他潜在不规范字符的文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find . -regex <span class="string">&quot;.*[^-_./0-9a-zA-Z].*&quot;</span></span><br></pre></td></tr></table></figure></li><li>由于要求整个路径名与正则表达式的描述完全一致，所以表达式的两端增加了 .* 以匹配 0 个或多个字符。在表达式的中间部分，我们使用了一个否定的中括号表达式，其中包含了可接受的路径名字的字符集。</li></ol><h3 id="用-locate-查找文件"><a href="#用-locate-查找文件" class="headerlink" title="用 locate 查找文件"></a>用 locate 查找文件</h3><ol><li>locate 命令既支持基本正则表达式 (--regexp 选项)，也支持扩展正则表达式 (--regex 选项) 。利用 locate ， 可以完成之前对 dirlist 所做的许多操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate --regex <span class="string">&quot;bin/(bz|gz|zip)&quot;</span></span><br><span class="line">/bin/bzcat</span><br><span class="line">/bin/bzcmp</span><br><span class="line">/bin/gzexe</span><br><span class="line">/bin/gzip</span><br><span class="line">/usr/bin/zip</span><br><span class="line">/usr/bin/zipcloak</span><br></pre></td></tr></table></figure></li><li>利用或选项，我们搜索到了那些路径包含 bin&#x2F;bz、bin&#x2F;gz 或 bin&#x2F;zip 等字符串的文件。</li></ol><h3 id="利用-less-和-vim-命令搜索文本"><a href="#利用-less-和-vim-命令搜索文本" class="headerlink" title="利用 less 和 vim 命令搜索文本"></a>利用 less 和 vim 命令搜索文本</h3><ol><li>less 和 vim 采用同样的方法进行文本搜索。按下 &#x2F; 键后输入正则表达式，即开始进行搜索。</li><li>我们可以利用 less 查看 phonelist.txt 文件的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less phonelist.txt</span><br></pre></td></tr></table></figure></li><li>按下 &#x2F; 键后输入正则表达式，即开始进行搜索。less 会以高亮的方式显示匹配字符串，这样就很容易找到那些无效的号码。</li><li>另一方面，vim 也支持基本正则表达式，所以，我们可以用下面的搜索表达式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/([0-9]\&#123;3\&#125;) [0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;</span><br></pre></td></tr></table></figure></li><li>可以看到，基本表达式基本一样。然而，在扩展表达式中被当作元字符的许多字符在基本表达中则被看作文字字符，只有使用反斜杠转义后才会被当作元字符。匹配项是否以高亮形式显示，则取决于自己系统上 vim 的设置。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二章 vi 文本编辑器</title>
      <link href="/post/861881a0.html"/>
      <url>/post/861881a0.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十二章-vi-文本编辑器"><a href="#第十二章-vi-文本编辑器" class="headerlink" title="第十二章 vi 文本编辑器"></a>第十二章 vi 文本编辑器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>概述</li></ol><ul><li>现在这个时代存在着很多图形界面编辑器和易用的基于文本的编辑器，例如 nano ，那为什么还要学习 vi ？这里有三条充分理由：<ul><li>vi 总是可用的。如果用户面前系统没有图形界面，例如远程服务器或者是本地系统的 X 配置不可用，那么 vi 就会成为救命稻草。 </li><li>尽管 nano 已经得到了越来越广泛的应用，但是，迄今为止它还不是通用的。而 POSIX (一种 UNIX 系统的程序兼容标准) 则要求系统必须配备有 vi 。 </li><li>vi 是轻量级的软件，运行速度快。对很多的任务来说，启动 vi 比在菜单中找到一个图形界面编辑器并等待几兆大小的编辑器载入要容易得多。另外，vi 的设计还非常利于打字。</li></ul></li></ul><h2 id="vi-背景"><a href="#vi-背景" class="headerlink" title="vi 背景"></a>vi 背景</h2><ol><li>1976年，加州大学生伯克利分校的学生，之后成为 Sun 公司创始人之一的 Bill Joy 写出了 vi 的第一个版本。</li><li>vi 出自单词 visual ，含义是能够在视频终端上移动光标来进行编辑。</li><li>在图形界面编辑器出现之前是行编辑器的天下，用户每次只能在一行文本上进行编辑。</li><li>使用行编辑器的时候，用户需要告知编辑器是在哪一行进行什么样操作。比如添加或者删除。</li><li>视频终端 (而非基于打印机的终端，比如电报) 的来临使得全屏幕的编辑成为了可能。</li><li>由于 vi 融合了强大的行编辑器 ex ，vi 用户也可以同时使用行编辑命令。</li><li>大多数 Linux 发行版配备的并不是真正的 vi ，而是 Bram Moolenaar 编写的 vi 加强版 vim 。 </li><li>vim 是传统 UNIX 系统中 vi 的实质性改良版。</li><li>通常， vim 的硬链接 (或别名) 指向 Linux 系统的 vi 名称。</li></ol><h2 id="vi-启动和退出"><a href="#vi-启动和退出" class="headerlink" title="vi 启动和退出"></a>vi 启动和退出</h2><ol><li>输入以下命令启动 vi :<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi</span><br></pre></td></tr></table></figure></li><li>像操作 nano 一样，现在应该先学习如何退出 vi 。输入以下命令退出 vi (需要注意的是，冒号是命令的一部分) 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure></li><li>此时 shell 会返回初始的操作窗口，如果因为一些原因，vi 不能够退出 (通常是因为没有保存修改过的文件) ，可以通过在命令后添加感叹号的方式强制退出 vi 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure></li><li>如果用户不能确定 vi 所处的状态，可以按 Esc 键两次返回初始状态。</li></ol><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><ol><li>vi 编辑模式</li></ol><ul><li>再次启动 vi ，并向其传递一个不存在的文件名，就可以通过 vi 创建新文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> -f foo.txt</span><br><span class="line">[me@linuxbox ~]$ vi foo.txt</span><br></pre></td></tr></table></figure></li><li>vi 是一个模态编辑器。 vi 启动后进入的是命令模式。</li></ul><ol start="2"><li>进入插入模式</li></ol><ul><li>如果用户需要向文件中添加一些内容，那么首先要做的就是按 I 键进入插入模式。</li><li>若此时 vim 是在增强模式下正常地运行，那么在屏幕底部会出现以下内容 (若 vim 以兼容模式运行，则不会出现) ：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--INSERT--</span><br></pre></td></tr></table></figure></li><li>现在用户可以进行输入操作了，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>最后按 Esc 退出插入模式并返回命令模式。</li></ul><ol start="3"><li>保存工作</li></ol><ul><li>要保存用户修改过的文件，在命令模式下输入一条 ex 命令，也就是按 : 键。</li><li>这样之后，一个冒号之后输入 w ，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure></li><li>文件写入硬盘驱动器之后，用户会在屏幕底部得到一条确认的信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;foo.txt&quot;</span> [New] 1L, 46C written</span><br></pre></td></tr></table></figure></li><li>如果用户阅读 vim 的说明文档，会困惑地发现命令模式被称为普通模式，而使用 ex 命令则被称为命令模式。</li></ul><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ol><li>基本介绍</li></ol><ul><li>在命令模式下， vi 提供了很多移动光标命令，其中有一些命令是与 less 命令共用的。</li><li>为什么使用 H、 J、 K 和 L 键来移动光标呢？这是因为在 vi 最初出现的阶段，并不是所有的视频终端都有方向键，这样的设计使得 vi 高手可以手不离键盘地移动光标。 </li><li>许多 vi 的命令的前面都可以缀上数字。前缀数字可以控制命令执行的次数，比如 5j 可以使得光标下移 5 行。</li></ul><ol start="2"><li>vi 移动光标</li></ol><table><thead><tr><th align="center">键</th><th align="center">光标</th></tr></thead><tbody><tr><td align="center">L 或 右方向键</td><td align="center">右移一位</td></tr><tr><td align="center">H 或 左方向键</td><td align="center">左移一位</td></tr><tr><td align="center">J 或 下方向键</td><td align="center">下移一行</td></tr><tr><td align="center">K 或 上方向键</td><td align="center">上移一行</td></tr><tr><td align="center">数字 0</td><td align="center">至本行开头</td></tr><tr><td align="center">Shift-6(^)</td><td align="center">至本行第一个非空字符</td></tr><tr><td align="center">Shift-4($)</td><td align="center">至本行的末尾</td></tr><tr><td align="center">W</td><td align="center">至下一单词或标点的开头</td></tr><tr><td align="center">Shift-W(W)</td><td align="center">至下一单词的开头，忽略标点</td></tr><tr><td align="center">B</td><td align="center">至上一单词或标点的开头</td></tr><tr><td align="center">Shift-B(B)</td><td align="center">至上一个单词的开头，忽略标点</td></tr><tr><td align="center">Ctrl-F 或 Page Down</td><td align="center">下翻一页</td></tr><tr><td align="center">Ctrl-B 或 Page UP</td><td align="center">上翻一页</td></tr><tr><td align="center">number-Shift-G</td><td align="center">至第 number 行(如 1G 将光标移到文件的第一行)</td></tr><tr><td align="center">Shift-G(G)</td><td align="center">至文件的最后一行</td></tr></tbody></table><h2 id="基本编辑"><a href="#基本编辑" class="headerlink" title="基本编辑"></a>基本编辑</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>插入、删除、剪切、复制等构成了基本的文本编辑操作， vi 也以其特殊的方式支持这些操作。</li><li>同时 vi 还支持有限的撤销操作，在命令模式下按 U 键就可以撤销用户最后一步操作。</li></ol><h3 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h3><ol><li>有几种方式都可以进入 vi 的插入模式。现在假设已经使用 i 命令进入插件模式。</li><li>先回顾下 foo.txt 内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>因为光标不能跳出行末，所以单纯使用 i 命令并不能完成在文本末尾添加内容的任务。</li><li>为此 vi 提供了在行末添加文本的 a 命令。当用户将光标移动到行的末尾并使用 a 命令时，光标会越过文本的末尾，同时 vi 进入插入模式。</li><li>这样用户就可以在行末添加文本了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br></pre></td></tr></table></figure></li><li>输入结束后不要忘记按 Esc 退出插入模式。</li><li>因为用户经常用到在行末添加文本的功能，所以 vi 提供了使光标移动到行末并进行插入模式的快捷方式 -A 命令。</li><li>首先，使用 0 命令将光标移动到行的开头。接下来使用 A 命令将以下内容写入文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line5</span><br></pre></td></tr></table></figure></li><li>按 Esc 键退出插入模式。可以看到，A 命令使 vi 进入插入模式并自动将光标移动到行尾，非常好用。</li></ol><h3 id="插入一行"><a href="#插入一行" class="headerlink" title="插入一行"></a>插入一行</h3><ol><li>基本介绍</li></ol><ul><li>插入文本的另一种方式是在文本中重开一行，即在两行现存的文字中间插入空白行并进入插入模式。</li></ul><ol start="2"><li>vi 插入一行</li></ol><table><thead><tr><th align="center">命令</th><th align="center">开行</th></tr></thead><tbody><tr><td align="center">o</td><td align="center">当前行上方</td></tr><tr><td align="center">O</td><td align="center">当前行的下方</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>下面这个例子示范了这两种命令的作用。先将光标置于 Line 3 ，在输入 O ，结果如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line"></span><br><span class="line">line 4</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure></li><li>我们可以看到在第三方的下方 vi 插入了一行，并进入了插入模式。按 Esc 键退出插入模式。按 Esc 键退出插入模式，按 u 键取消上述操作。</li><li>继续输入命令 o ，就会在第三行的上方插入了一行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line"></span><br><span class="line">Line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure></li><li>再次按 Esc 键退出插入模式并按 u 键取消操作。</li></ul><h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><ol><li>基本介绍</li></ol><ul><li>就像用户期待的一样， vi 提供了很多种删除文本的方式，每一种都需要进行一次至两次的按键操作。</li><li>首先，X 键会删除光标处的字符。x 命令可以加以数字前缀来明确删除的字符数目。D 键则使用得更加普遍。</li><li>像 x 命令一样，d 命令也可加练数字前缀来明确删除次数。另外，d 命令总是加以控制删除范围的光标移动命令作为后缀。</li></ul><ol start="2"><li>vi 文本删除</li></ol><table><thead><tr><th align="center">命令</th><th align="center">删除内容</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">当前字符</td></tr><tr><td align="center">3x</td><td align="center">当前字符和之后 2 个字符</td></tr><tr><td align="center">dd</td><td align="center">当前行</td></tr><tr><td align="center">5dd</td><td align="center">当前行和之后 4 行</td></tr><tr><td align="center">dW</td><td align="center">当前字符到下一单词的起始</td></tr><tr><td align="center">d$</td><td align="center">当前字符到当前行的末尾</td></tr><tr><td align="center">d0</td><td align="center">当前字符到当前行的起始</td></tr><tr><td align="center">d^</td><td align="center">当前字符到当前行下一个非空字符串</td></tr><tr><td align="center">dG</td><td align="center">当前行到文件末尾</td></tr><tr><td align="center">d20G</td><td align="center">当前行到文件第 20 行</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>现在让我们来练习一下使用 d 命令。我们再次将光标移动到单词 It ，使用 dW 命令来删除整个单词。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure></li><li>使用的的 d$ 删除光标至本行末尾的字符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure></li><li>使用 dG 删除当前行到文件末尾的内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure></li><li>可以使用 u 命令三次来取消之前的操作。</li></ul><h3 id="剪切、复制和粘贴文本"><a href="#剪切、复制和粘贴文本" class="headerlink" title="剪切、复制和粘贴文本"></a>剪切、复制和粘贴文本</h3><ol><li>基本介绍</li></ol><ul><li>命令 d 不只是删除文本，而是在剪切文本。用户每次使用 d 命令之后，都会复制删除的内容进缓存 (类似剪切板) ，然后用户就可以使用 p 命令将缓存中的内容粘贴到光标之后或使用 p 命令将内容粘贴到光标之前。</li><li>就像命令 d 剪切文本的形式一样，命令 y 会复制文本。</li></ul><ol start="2"><li>vi 复制命令</li></ol><table><thead><tr><th align="center">命令</th><th align="center">复制内容</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">当前行</td></tr><tr><td align="center">5yy</td><td align="center">当前行和之后 4 行</td></tr><tr><td align="center">yW</td><td align="center">当前字符到下一个单词的起始</td></tr><tr><td align="center">y$</td><td align="center">当前字符到当前行的末尾</td></tr><tr><td align="center">y0</td><td align="center">当前字符到当前行的起始</td></tr><tr><td align="center">y^</td><td align="center">当前字符到当前行下一个非空字符</td></tr><tr><td align="center">yG</td><td align="center">当前行到文件末尾</td></tr><tr><td align="center">y20G</td><td align="center">当前行到文件第 20 行</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>现在让我们来练习一下复制和粘贴。我们将光标移至文本的第一行，使用 yy 命令复制当前行。接下来，将光标移至最后一行 (G) ，使用 p 命令将复制的内容粘贴到当前行的下方。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br></pre></td></tr></table></figure></li><li>命令 u 会取消我们的操作。将光标一纸文件的最后一行，输入 p 命令将文本粘贴到当前行的上方。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">line 4</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure></li></ul><h3 id="合并行"><a href="#合并行" class="headerlink" title="合并行"></a>合并行</h3><ol><li>基本介绍</li></ol><ul><li>vi 在行的概念上非常严格。通常来说，将光标移动到行的末端并删除行的末尾字符并不能将此行合并。</li><li>因此，vi 专门提供了 J 命令 (不要与移动光标的 j 命令混淆) 来合并行。</li></ul><ol start="2"><li>vi 合并行</li></ol><ul><li>若将光标置于第 3 行并输入 J 命令，将得到如下结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The quick brown <span class="keyword">for</span> jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3 Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure></li></ul><h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>vi 提供了在一行或者整个文件中，根据需要将文件移动至指定位置的功能。</li><li>vi 还可以执行文本替换工作，用户可指定替换时是否需要用户确认。</li></ol><h3 id="行内搜索"><a href="#行内搜索" class="headerlink" title="行内搜索"></a>行内搜索</h3><ol><li>命令 f 在行内进行搜索，并将光标移至搜索到的下一个指定字符。比如，命令 fa 就会将光标移动到本行下移除字符 a 的地方。</li><li>在执行过一次行内搜索之后，输入分号可以使 vi 重复一次搜索。</li></ol><h3 id="搜索整个文件"><a href="#搜索整个文件" class="headerlink" title="搜索整个文件"></a>搜索整个文件</h3><ol><li>基本介绍</li></ol><ul><li>同第 3 章中讲解过的 less 程序一样，命令 &#x2F; 可以完成对单词或短语的搜索。 </li><li>当用户使用 &#x2F; 命令后，一个 &#x2F; 符号会出现在屏幕的底部。接下来，输入需要搜索的单词或短语，Enter 结束。 </li><li>这时光标就会移动到下一次处包含被搜索字符串的地方，使用 n 命令可以重复此搜索。</li></ul><ol start="2"><li>案例</li></ol><ul><li>文件如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure></li><li>将光标移至文件的第一行，并输入如下代码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Line</span><br></pre></td></tr></table></figure></li><li>输入 Enter 以结束，光标将移动至第 2 行。接下来，输入 n ，光标将继续移动至第 3 行。重复输入 n 直至光标移动到文档的最后，且找不到符合条件的字符串。</li><li>尽管现在只讲解到 vi 的单词和词组的搜索模式，但是 vi 同样支持正则表达式 (一种强大的表达复杂文本模式的方法) 的应用。</li></ul><h3 id="全局搜索和替换"><a href="#全局搜索和替换" class="headerlink" title="全局搜索和替换"></a>全局搜索和替换</h3><ol><li>基本介绍</li></ol><ul><li>vi 使用 ex 命令来执行几行内或者整个文件中的搜索和替换操作。</li><li>输入以下命令可将文件中的 Line 替换为 line 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/Line/line/g</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>vi 全局搜索和替换语法</li></ol><table><thead><tr><th align="center">组成</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">分号用于启动一条 ex 命令</td></tr><tr><td align="center">%</td><td align="center">确定了操作作用范围。 % 简洁地代表了从文件的第一行到最后一行。本命令的范围还可以表示为 1,5 (因为本文件只有 5 行) ，或者是 1,$ ，意思是从第 1 行到文件最后一行。如果不明确指出命令的作用范围，那么命令只会在当前行生效</td></tr><tr><td align="center">s</td><td align="center">指定了具体的操作-本次是替换操作 (搜索和替换)</td></tr><tr><td align="center">&#x2F;Line&#x2F;line</td><td align="center">搜索和替换的文本</td></tr><tr><td align="center">g</td><td align="center">代指 global (全局) ，也就是说对搜索到的每一行的每一个实例，进行替换。如果 g 缺失，那么只替换每一行第一个符合条件的实例</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>以下是执行过查找和替换命令之后的文档内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure></li><li>在命令末尾添加 c ，则命令在每次替换之前都会请求用户确认。如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/line/Line/gc</span><br></pre></td></tr></table></figure></li><li>此命令将会将文件替换回原来的样子，但是每次替换前，vi 都会停下来询问用户是否确认执行替换。</li></ul><ol start="4"><li>vi 替换确认功能键</li></ol><table><thead><tr><th align="center">功能键</th><th align="center">执行</th></tr></thead><tbody><tr><td align="center">y</td><td align="center">执行替换</td></tr><tr><td align="center">n</td><td align="center">跳过此次替换</td></tr><tr><td align="center">a</td><td align="center">执行此次替换和之后的所有替换</td></tr><tr><td align="center">q 或者 Esc</td><td align="center">停止替换</td></tr><tr><td align="center">l</td><td align="center">执行此次替换并退出替换，last 的缩写</td></tr><tr><td align="center">Ctrl-E，Ctrl</td><td align="center">分别是向下滚动和向上滚动，能用于查看替换处的上下文</td></tr></tbody></table><h2 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>用户经常遇到需要同时编辑多个文件的情况。可能是需要对多个文件作出修改，或者是拷贝文件的部分内容到另一个文件。用户可以通过在命令行具体指定多个文件的方式使 vi 打开多个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi file1 file2 file3...</span><br></pre></td></tr></table></figure></li><li>现在退出所处的 vi 会话，并创建一个用于编辑的新文件，输入 :wq 来退出 vi 并保存做出的修改。</li><li>接下来，使用 ls 命令的部分输出在主目录创建一个用于实现的新文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>现在就用 vi 来同时编辑旧文件和新文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi foo.txt ls-output.txt</span><br></pre></td></tr></table></figure></li><li>vi 启动后，屏幕显示内容如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure></li></ol><h3 id="切换文件"><a href="#切换文件" class="headerlink" title="切换文件"></a>切换文件</h3><ol><li>使用一下 ex 命令来从一个文件切换到下一个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n</span><br></pre></td></tr></table></figure></li><li>切换回上一个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:N</span><br></pre></td></tr></table></figure></li><li>当用户从一个文件切换到另一个的时候，vi 要求用户必须先保存对当前文件做出的修改才能切换到其他文件。</li><li>若要放弃对文件的修改并使 vi 强制切换到另一个文件，可在命令后添加感叹号 ! 。</li><li>除了以上描述的切换方法之外，vim (和一些版本的 vi) 还提供了一些 ex 命令让用户可以更轻松地编辑多个文本。用户可使用 :buffers命令来查看正在编辑的文件列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:buffers</span><br><span class="line">1  %a  <span class="string">&quot;foo.txt&quot;</span>        line 1</span><br><span class="line">2      <span class="string">&quot;ls-output&quot;</span>      line 0</span><br><span class="line">Press ENTER or <span class="built_in">type</span> <span class="built_in">command</span> to <span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li><li>输入 :buffer 加文件编号可切换到另一个问卷。如从文件 1 (foo.txt) 切换到文件 2 (ls-output.txt) ，用户应当输入如下命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:buffer 2</span><br></pre></td></tr></table></figure></li><li>现在屏幕展示的就是文件 2 的内容了。</li></ol><h3 id="载入更多的文件"><a href="#载入更多的文件" class="headerlink" title="载入更多的文件"></a>载入更多的文件</h3><ol><li>我们也可以在现有的编辑会话中载入更多的文件。使用 ex 命令 :e 加文件名可以载入另一个文件。</li><li>先退出现有的编辑会话并回到命令行模式。重启 vi，并只打开一个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi foo.txt</span><br></pre></td></tr></table></figure></li><li>添加一个文件到编辑会话中，输入下列代码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e ls-output.txt</span><br></pre></td></tr></table></figure></li><li>屏幕将展示第二个文件的内容，而第一个文件仍然处在编辑状态，可使用 buffers 命令来证实。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:buffers</span><br><span class="line">1  %a  <span class="string">&quot;foo.txt&quot;</span>        line 1</span><br><span class="line">2      <span class="string">&quot;ls-output&quot;</span>      line 0</span><br><span class="line">Press ENTER or <span class="built_in">type</span> <span class="built_in">command</span> to <span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li><li>使用 :ez 载入的文件不会响应 :n 或者 :N 命令，而需使用 :buffer 加文件编号来切换文件。</li></ol><h3 id="文件之间的内容复制"><a href="#文件之间的内容复制" class="headerlink" title="文件之间的内容复制"></a>文件之间的内容复制</h3><ol><li>用户在编辑多个文件的过程，有时会需要将一个文件中的一部分复制到另一个文件中。使用之前使用过的复制粘贴命令即可完成此功能。</li><li>首先，在载入的两个文件中，切换到文件 1 (foo.txt) 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:buffer 1</span><br></pre></td></tr></table></figure></li><li>此时屏幕显示如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure></li><li>接下来，将光标移动到文件的第一行并输入 yy 命令来复制第一行。</li><li>输入如下命令以切换到文件 2。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:buffer 2</span><br></pre></td></tr></table></figure></li><li>现在屏幕将会显示一份文件列表，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total 343700</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2011-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2011-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2012-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2010-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2011-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2011-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure></li><li>将光标移动到文件的第一行并使用 p 命令将从文件 1 复制的内容粘贴到本文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">total 343700</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2011-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2011-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2012-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2010-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2011-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2011-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入整个文件"><a href="#插入整个文件" class="headerlink" title="插入整个文件"></a>插入整个文件</h3><ol><li>用户还可以将一个文件完全插入正在编辑的文件中。为了实际演示这项功能，先结束现有的 vi 会话并重启 vi 的同时只打开一个文件。</li><li>屏幕将再次显示一份文件列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total 343700</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2011-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2011-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2012-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2010-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2011-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2011-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure></li><li>将光标移动到文件的第三行并输入如下 ex 命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r foo.txt</span><br></pre></td></tr></table></figure></li><li>命令 :r 将指定的文件内容插入到光标位置之前。现在屏幕显示如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">total 343700</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2011-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2011-12-09 13:39 411toppm</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2012-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2010-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2011-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2011-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure></li></ol><h2 id="保存工作"><a href="#保存工作" class="headerlink" title="保存工作"></a>保存工作</h2><ol><li>就像其他功能一样，vi 提供了很多种方式来保存编辑过的文件。前面的章节已经介绍过用于此功能的 ex 命名 :w ，但是还有一些其他可用的方法。</li><li>在命令模式下，输入 ZZ 将保存当前文档并退出 vi 。同样的， ex 命令 :wq 组合了 :w 和 :q 这两个命令的功能，能够保存文件并退出 vi 。</li><li>当命令 :w 指定一个随意的文件名时，命令的功能就类似于另存为。</li><li>例如，用户在编辑 foo.txt 的时候想要将其另存为 foo1.txt ，那么就可以输入如下内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w foo1.txt</span><br></pre></td></tr></table></figure></li><li>此命令在以新名称保存文件的同时，并不更改编辑中的原文件的名称。当用户继续编辑时，编辑的还是 foo.txt 而不是 foo1.txt 。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十二章 打印</title>
      <link href="/post/d9bb899a.html"/>
      <url>/post/d9bb899a.html</url>
      
        <content type="html"><![CDATA[<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>前面几章讲述了文本的操纵，现在是时候讨论如何将文本输出到纸张上了，本章将会介绍一些用于打印文件以及控制打印机操作的命令行工具。</li><li>本章会讨论如下命令：</li></ol><ul><li>pr: 转换文本文件，从而进行打印操作</li><li>lpr: 打印文件</li><li>lp: 打印文件 (System V)</li><li>a2ps: 格式化文件，以在 PostScript 打印机上打印</li><li>lpstat: 显示打印机状态信息。</li><li>lpq: 显示打印机队列状态。</li><li>lprm: 取消打印任务</li><li>cancel: 取消打印任务 (System V)</li></ul><h2 id="打印操作简史"><a href="#打印操作简史" class="headerlink" title="打印操作简史"></a>打印操作简史</h2><ol><li>在充分理解类 UNIX 操作系统的打印特性之前，我们必须首先了解一些打印操作的的发展史。</li><li>类 UNIX 系统的打印操作可以追溯到操作系统的起源，那个时期，打印机及其使用方法与现在有很大区别。</li><li>打印操作简史如下：</li></ol><ul><li>灰暗时期的打印 </li><li>基于字符的打印机 </li><li>图形化打印机 </li><li>Linux 方式的打印</li></ul><h2 id="准备打印文件"><a href="#准备打印文件" class="headerlink" title="准备打印文件"></a>准备打印文件</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>作为命令行用户，我们多数还是倾向于打印文本文件，虽然其他的数据形式也可以打印。</li></ol><h3 id="pr-将文本文件转换为打印文件"><a href="#pr-将文本文件转换为打印文件" class="headerlink" title="pr - 将文本文件转换为打印文件"></a>pr - 将文本文件转换为打印文件</h3><ol><li>pr 基本介绍</li></ol><ul><li>前面章节略微介绍了 pr 的相关知识，本节将讨论其与打印操作联合使用时用到的一些参数选项。</li></ul><ol start="2"><li>常见的 pr 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">+first[:last]</td><td align="center">输出一个从 first 开始以 last 结束的页范围</td></tr><tr><td align="center">-columns</td><td align="center">将页的内容分成指定的 columns 列</td></tr><tr><td align="center">-a</td><td align="center">默认情况下，多列输出是垂直列出的。通过增加 -a 选项，内容便是水平列出</td></tr><tr><td align="center">-d</td><td align="center">隔行打印输出</td></tr><tr><td align="center">-D format</td><td align="center">用 format 格式来格式化页眉的显示时期。可以查看日期命令的 man 手册页以了解格式字符串的描述。</td></tr><tr><td align="center">-f</td><td align="center">使用换页符而不是回车符作为页与页之间的分隔符</td></tr><tr><td align="center">-h header</td><td align="center">在页眉的中间部分，使用 header 替代正在处理的文件名</td></tr><tr><td align="center">-l length</td><td align="center">将页的长度设为 length 。默认是 66 行</td></tr><tr><td align="center">-n</td><td align="center">对行进行编号</td></tr><tr><td align="center">-o offset</td><td align="center">创建一个有 offset 字符宽的左页边距</td></tr><tr><td align="center">-w width</td><td align="center">设定页面宽度为 width，默认是 72 个字符</td></tr></tbody></table><ol start="3"><li>pr 案例</li></ol><ul><li>pr 通常用于管道传输的过滤器。</li><li>下面例子生成 &#x2F;usr&#x2F;bin 文件夹下的目录列表，并且 pr 将其格式化为分页的、三列的输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -3 -w 65 | <span class="built_in">head</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="向打印机发送打印任务"><a href="#向打印机发送打印任务" class="headerlink" title="向打印机发送打印任务"></a>向打印机发送打印任务</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>CUPS 打印组件支持两种打印方式，它们都是类 UNIX 系统过去使用过的。</li><li>一种方法叫做 Berkeley 或 LPD ，运用的是 lpr 命令；另一种方法叫做 SysV (来源于 UNIX 的 System V 版本) ，运用的是 lp 命令。这两个命令大致做着相同的事情，用户可以根据个人喜好选择使用。</li></ol><h3 id="lpr-打印文件"><a href="#lpr-打印文件" class="headerlink" title="lpr - 打印文件"></a>lpr - 打印文件</h3><ol><li>lpr 基本介绍</li></ol><ul><li>lpr 命令可以将文件传送至打印机，同时由于其支持标准输入，所以也可用于管道传输。</li><li>例如，要打印上述的多列目录列表，我们可以进行如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -3 | lpr</span><br></pre></td></tr></table></figure></li><li>该报告将被送至系统默认的打印机。如果想将文件发送至不同的打印机，可以使用 -P 选项，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpr -P printer_name</span><br></pre></td></tr></table></figure></li><li>此处 printer_name 是指目标打印机的名称。可以用下面的命令行查看系统打印机列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpstat -a</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>常用的 lpr 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-#number</td><td align="center">打印 number 份副本</td></tr><tr><td align="center">-p</td><td align="center">每一页都将包括日期、时间、工作名称和页码的页眉用阴影打印出来。这中所谓的优质打印可以用于打印文本文件</td></tr><tr><td align="center">-P printer</td><td align="center">指定用于打印输出的打印机名。如果未指定打印机，那就是用系统默认的打印机</td></tr><tr><td align="center">-r</td><td align="center">打印结束后删除文件。此选项适用于那些产生临时打印文件输出文件的程序</td></tr></tbody></table><h3 id="lp-打印文件"><a href="#lp-打印文件" class="headerlink" title="lp - 打印文件"></a>lp - 打印文件</h3><ol><li>lp 基本介绍</li></ol><ul><li>与 lpr 类似，lp 命令既支持文件输入也支持标准输入。它与 lpr 的不同之处在于它有一个不同 (稍微复杂点) 的参数选项设置。</li></ul><ol start="2"><li>lp 常用的选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-d printer</td><td align="center">设置目标打印机为 printer 。如果未指定 -d 选项，将会使用系统默认的打印机</td></tr><tr><td align="center">-n number</td><td align="center">打印 number 份副本</td></tr><tr><td align="center">-o landscape</td><td align="center">将输出设置为横向</td></tr><tr><td align="center">-o fitplot</td><td align="center">根据页面大小缩放文件，这在打印诸如 JPEG 文件时非常有用</td></tr><tr><td align="center">-o scaling&#x3D;number</td><td align="center">设定文件缩放比例为 number 。如果该值为 100 ，则正好填充一页纸；如果该值小于 100 ，那么一页纸将填不满；如果该值大于 100 ，则打印内容将打印在多个页面上</td></tr><tr><td align="center">-o cpi&#x3D;number</td><td align="center">设置每英寸输出字符数位 number。默认是  10</td></tr><tr><td align="center">-o lpi&#x3D;number</td><td align="center">设置每英寸输出指定 number 的行。默认是 6</td></tr><tr><td align="center">-P pages</td><td align="center">指定页列表。页的表达形式可以为用逗号隔开的页列表或是 - 表示的页范围。</td></tr></tbody></table><ol start="3"><li>lp 案例</li></ol><ul><li>我们重新生成目录清单<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -4 -w 90 -l 88 | lp -o page-left=36 -o cpi=12 -o lpi=8</span><br></pre></td></tr></table></figure></li><li>该管道使用了比默认规格更小的字体从而得到了一个 4 列列表。每行增加的字符数是的一页纸能够容纳更多列。</li></ul><h2 id="监测和控制打印任务"><a href="#监测和控制打印任务" class="headerlink" title="监测和控制打印任务"></a>监测和控制打印任务</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>与 UNIX 打印系统类似，CUPS 也是以处理来自多用户的多项打印任务而设计的。</li><li>每个打印机都有一个打印队列，打印任务排列其中等待被送至打印机打印。</li><li>CUPS 提供了几个用于管理打印机状态和打印队列命令行的程序。</li><li>与 lpr 和 lp 程序类似，这些管理程序都是以 Berkeley 和 System V 打印系统相应的程序为原型的。</li></ol><h3 id="lpstat-显示打印系统状态"><a href="#lpstat-显示打印系统状态" class="headerlink" title="lpstat - 显示打印系统状态"></a>lpstat - 显示打印系统状态</h3><ol><li>lpstat 基本介绍</li></ol><ul><li>lpstat 程序可以确定系统中打印机的名称和可用性。</li><li>例如，假定一台打印系统，既有物理打印设备，也有 PDF 虚拟打印机，那么便可以用下面的命令行检查它们各自的状态。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpstat -a</span><br></pre></td></tr></table></figure></li><li>更进一步，我们可以用下面的方式得到更具体的打印系统配置描述。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpstat -s</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>lpstat 常用选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-a[printer…]</td><td align="center">显示 printer 打印机的打印队列状态，请注意，该状态显示的是打印队列接受打印任务的能力，而不是物理打印机的状态。如果未指定打印机，所有的打印队列都会显示出来</td></tr><tr><td align="center">-d</td><td align="center">显示系统默认的打印机名</td></tr><tr><td align="center">-p[]printer…</td><td align="center">显示指定的 printer 状态。如果未指定打印机，所有的打印机都会显示出来</td></tr><tr><td align="center">-r</td><td align="center">显示打印服务器的状态</td></tr><tr><td align="center">-s</td><td align="center">显示状态汇总报告</td></tr><tr><td align="center">-t</td><td align="center">显示一个完整的状态报告</td></tr></tbody></table><h3 id="lpq-显示打印队列状态"><a href="#lpq-显示打印队列状态" class="headerlink" title="lpq - 显示打印队列状态"></a>lpq - 显示打印队列状态</h3><ol><li>lpq 基本介绍</li></ol><ul><li>我们可以使用 lpq 程序查看一个打印队列的状态，该程序可以查看打印机队列状态以及所包含的打印任务。</li><li>如下为系统默认的打印机 printer 的一个空队列。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpq</span><br><span class="line">printer is ready</span><br><span class="line">no entries</span><br></pre></td></tr></table></figure></li><li>如果事先并未指定打印机 (使用 -P 选项) ，系统便会显示默认的打印机。</li><li>如果向打印机发送打印任务，然后查看打印队列，便会看到如下列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> *.txt | <span class="built_in">pr</span> -3 | lp</span><br><span class="line">request <span class="built_in">id</span> is printer-603 (1 file(s))</span><br><span class="line">[me@linuxbox ~]$ lpq</span><br><span class="line">printer is ready and printing</span><br><span class="line">Rank    Owner   Job     File(s)     Total Size</span><br><span class="line">active  me      603     (stdin)     1024 bytes</span><br></pre></td></tr></table></figure></li></ul><h3 id="lprm-与-cancel-删除打印任务"><a href="#lprm-与-cancel-删除打印任务" class="headerlink" title="lprm 与 cancel - 删除打印任务"></a>lprm 与 cancel - 删除打印任务</h3><ol><li>lprm 与 cancel 基本介绍</li></ol><ul><li>CUPS 提供了两个用于终止打印任务并将它们从打印队列中移除的程序。其中一个就是 Berkeley 类型的 lprm ，另外一个是 System V 的 cancel 。</li><li>它们在所支持的参数选项上有稍许不同，但基本上实现的是同样的功能。</li><li>以上面的例子中使用的打印任务为例，将该打印任务终止并移除，可以使用如下命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ cancel 603</span><br><span class="line">[me@linuxbox ~]$ lpq</span><br><span class="line">printer is ready</span><br><span class="line">no entries</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章 环境</title>
      <link href="/post/d672eea5.html"/>
      <url>/post/d672eea5.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章-环境"><a href="#第十一章-环境" class="headerlink" title="第十一章 环境"></a>第十一章 环境</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ol><li>前面讲到，在 shell 会话调用环境 (environment) 期间， shell 会存储大量的信息。</li><li>程序使用存储在环境中的数据来确定我们的配置。尽管大多数系统程序使用配置文件 (configuration file) 来存储程序设置，但是也有一些程序会查找环境中存储的变量来调整自己的行为。</li><li>本章会讲解下述命令</li></ol><ul><li>printenv: 打印部分或者全部的环境信息</li><li>set: 设置 shell 选项</li><li>export: 将环境导出到随后要运行的程序中</li><li>alias: 为命令创建一个别名</li></ul><h2 id="环境中存储的是什么"><a href="#环境中存储的是什么" class="headerlink" title="环境中存储的是什么"></a>环境中存储的是什么</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>尽管 shell 在环境中存储了两种基本类型的数据，但是在 bash 中，这两种类型基本上没有什么区别。这两种数据类型分别是环境变量 (environment variable) 和 shell 变量 (shell variable) 。</li><li>shell 变量是由 bash 存放的少量数据，环境变量就是除此之外的所有其他变量。除变量之外，shell 还存储了一些编程数据 (programmatic data) ，也就是别名和 shell 函数。</li></ol><h3 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h3><ol><li><p>要了解环境中存储的内容，需要用到集成在 bash 中的 set 命令或 printenv 程序。</p></li><li><p>不同的是， set 命令会同时显示 shell 变量和环境变量，而 printenv 只会显示环境变量。</p></li><li><p>由于环境的内容可能会比较冗长，所以最好将这两个命令的输出以管道形式重定向到 less 命令中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printenv</span> | less</span><br><span class="line">KDE_MULTIHED=<span class="literal">false</span></span><br><span class="line">SSH_AGENT_PID=6666</span><br><span class="line">HOSTNAME=linuxbox</span><br><span class="line">GPG_AGENT_INFO = /tmp/gpg-PdOt7g/S.gpg-agent:6689:1</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">TERM=XTERM</span><br><span class="line">USER=me</span><br></pre></td></tr></table></figure></li><li><p>可以看到，输出结果是一系列的环境变量及其变量值。</p></li><li><p>例如，让我们来看一个名为 USER 的变量，其值为 me 。命令 printenv 也能够列出特定变量的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printenv</span> USER</span><br><span class="line">me</span><br></pre></td></tr></table></figure></li><li><p>在使用 set 命令时，如果不带选项或参数，那么只会显示 shell 变量，环境变量以及任何已定义的 shell 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">set</span> | less</span><br></pre></td></tr></table></figure></li><li><p>与 printenv 命令不同的是，set 命令的输出结果是按照字母顺序排序的。</p></li><li><p>如果需要查看单个变量的值，我们也可以使用 echo 命令，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure></li><li><p>set 命令和 printenv 命令都不能显示的一个环境元素是别名。要查看别名，需使用不带任何参数的 alias 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll = <span class="string">&#x27;ls -l --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span> = <span class="string">&#x27;ls --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> vi = <span class="string">&#x27;vim&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span> = <span class="string">&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --showilde&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="一些有趣的变量"><a href="#一些有趣的变量" class="headerlink" title="一些有趣的变量"></a>一些有趣的变量</h3><table><thead><tr><th align="center">变量</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DISPLAY</td><td align="center">运行图形界面环境时界面的名称。通常为：O ，表示由  X 服务器生成的第一个界面</td></tr><tr><td align="center">EDITOR</td><td align="center">用于文本编辑的程序名称</td></tr><tr><td align="center">SHELL</td><td align="center">本机 shell 名称</td></tr><tr><td align="center">HOME</td><td align="center">本机主目录的路径名</td></tr><tr><td align="center">LANG</td><td align="center">定义了本机语言的字符集和排序规则</td></tr><tr><td align="center">OLD_PWD</td><td align="center">先前的工作目录</td></tr><tr><td align="center">PAGER</td><td align="center">用于分页输出的程序名称，通常设置为 &#x2F;usr&#x2F;bin&#x2F;less</td></tr><tr><td align="center">PATH</td><td align="center">以冒号分割的一个目录列表，当用户输入一个可执行程序的名称时，会查看该目录列表</td></tr><tr><td align="center">PS1</td><td align="center">提示符字符串 1 。定义了本机 shell 系统提示符的内容。在后面我们会看到，可以灵活地自定义该变量</td></tr><tr><td align="center">PWD</td><td align="center">当前工作目录</td></tr><tr><td align="center">TERM</td><td align="center">终端类型的名称。类 UNIX 系统支持很多种终端协议；此变量设定了本机终端模拟器使用的协议</td></tr><tr><td align="center">TZ</td><td align="center">用于指定本机所处的时区。大多数类 UNIX 系统以协调世界时 (UTC) 来维护计算机的内部时钟，而显示的本地时间是根据本变量确定的时差计算出来的</td></tr><tr><td align="center">USER</td><td align="center">用户名</td></tr></tbody></table><h2 id="环境是如何建立的"><a href="#环境是如何建立的" class="headerlink" title="环境是如何建立的"></a>环境是如何建立的</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>用户登录系统后，bash 程序就会启动并读取一系列被称为启动文件的配置脚本，这些脚本定义了所有用户共享的默认环境。</li><li>接下来， bash 会读取更多存储在主目录下的用于定义个人环境的启动文件。这些步骤执行的确切顺序是由启动的 shell 会话类型决定的。</li></ol><h3 id="login-shell-和-non-login-shell"><a href="#login-shell-和-non-login-shell" class="headerlink" title="login shell 和 non-login shell"></a>login shell 和 non-login shell</h3><ol><li>login shell 和 non-login shell 基本介绍</li></ol><ul><li>shell 会话存在两种类型，分别为 login shell 和 non-login shell 会话。 </li><li>login shell 会话会提示用户输入用户名和密码，如虚拟控制台会话。而我们在 GUI 中启动的终端会话就是一个典型的 non-login shell 会话。</li></ul><ol start="2"><li>login shell 启动文件</li></ol><table><thead><tr><th align="center">文件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;etc&#x2F;profile</td><td align="center">适用于所有用户的全局配置脚本</td></tr><tr><td align="center">~&#x2F;.bash_profile</td><td align="center">用户的个人启动文件。可扩展或重写全局配置脚本中的设置</td></tr><tr><td align="center">~&#x2F;.bash_login</td><td align="center">若 ~&#x2F;.bash_profile 缺失 ，则 bash 尝试读取此脚本</td></tr><tr><td align="center">~&#x2F;.profile</td><td align="center">若在 ~&#x2F;.bash_profile 与 ~&#x2F;.bash_login 均缺失，则 bash 尝试读取此文件。在基于 Debian 的 Linux 版本中，这是默认值</td></tr></tbody></table><ol start="3"><li>non-login shell 的启动文件</li></ol><table><thead><tr><th align="center">文件</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">&#x2F;etc&#x2F;bash.bsahrc</td><td align="center">适用于所有用户的全局配置脚本</td></tr><tr><td align="center">~&#x2F;.bashrc</td><td align="center">用户的个人启动文件。可扩展或重写全局配置脚本中的设置</td></tr></tbody></table><ol start="4"><li>login shell 和 non-login shell 补充说明</li></ol><ul><li>在读取以上启动文件之外，non-login shell 还会继承父类进程的环境，父类进程通常是一个 login shell 。</li><li>用户可查看本机系统有哪些启动文件，需要注意的是这些文件大多数以 . 开头(意味着这些文件是被隐藏的)，所以用户在使用 ls 命令时，需要伴随使用 -a 选项。</li><li>在普通用户看来， ~&#x2F;.bashrc 可能是最重要的启动文件，因为系统几乎总是要读取它。</li><li>non-login shell 会默认读取 ~&#x2F;.bashrc ，而大多数 login shell 的启动文件也能以读取 ~&#x2F;.bashrc 文件的方式编写。</li></ul><h3 id="启动文件中有什么"><a href="#启动文件中有什么" class="headerlink" title="启动文件中有什么"></a>启动文件中有什么</h3><ol><li>.bash_profile 启动文件</li></ol><ul><li>一个典型的 .bash_profile 内容如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure></li><li>文件中以 # 开始的行是注释行，而 shell 是不会读取注释行的，注释是为了提高用户可读性而存在的。一件有趣的是发生在第 4 行，如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li>这段代码被称作 if 复合命令，会在本书的第四部分进行讲解，现在可以将这段代码理解为如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the file <span class="string">&quot;~/.bashrc&quot;</span> exists, <span class="keyword">then</span> <span class="built_in">read</span> the <span class="string">&quot;~/.bashrc&quot;</span> file.</span><br></pre></td></tr></table></figure></li><li>可以看到这一段代码阐述了 login shell 读取 .bashrc 文件的机制。</li><li>以上启动文件中另一个很重要的元素是 PATH 变量。</li><li>在命令行输入一条命令后，你曾经疑惑过 shell 是怎样找到这些命令的吗？当用户输入命令 ls ，shell 不会搜索整个系统来寻找 &#x2F;bin&#x2F;ls ( ls 命令的完全路径名) ，而是会搜索 PATH 变量中存储的目录列表。</li><li>PATH 变量通常是由启动文件 &#x2F;etc&#x2F;profile 中的一段代码设定 (并不总是如此，这取决于系统的发行版本) 。<br>PATH&#x3D;$PATH:$HOME&#x2F;bin</li><li>这段代码将 $HOME&#x2F;bin 添加到了 PATH 值的尾部。这是一个参数扩展的实例。</li><li>以下代码可以帮助用户理解扩展的机理：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=<span class="string">&quot;This is some&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">This is some</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span><span class="string">&quot; text.&quot;</span></span><br><span class="line">This is some text.</span><br></pre></td></tr></table></figure></li><li>使用参数扩展，用户可以将更多的内容添加到变量值的尾部。 </li><li>在字符串 $HOME&#x2F;bin 添加到 PATH 值的尾部之后，当系统需要检索用户输入的命令时，$HOME&#x2F;bin 这个路径就会处于被搜索的路径列表中。这就意味着当我们想在主目录下创建名为 bin 的目录，并在此目录中存放自己的私有程序时，shell 已经为我们准备好了，我们要做的就是将创建的目录称之为 bin 。 </li><li>很多 Linux 发行版本在默认情况下提供了该 PATH 设置。一些基于 Debian 的发行版本，如 Ubuntu ，会在登录时检查 ~&#x2F;bin 目录是否存在，若存在，就会自动将其添加到 PATH 变量中。 </li><li>最后一行是如下代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure></li><li>该 export 命令告诉 shell ，将 shell 的子进程使用 PATH 变量的内容。</li></ul><h2 id="修改环境"><a href="#修改环境" class="headerlink" title="修改环境"></a>修改环境</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>现在用户已经知道了系统启动文件的位置和内容，就可以修改启动文件，来自定义我们的环境。</li></ol><h3 id="用户应当修改哪些文件"><a href="#用户应当修改哪些文件" class="headerlink" title="用户应当修改哪些文件"></a>用户应当修改哪些文件</h3><ol><li>一般来说，在 PATH 中添加目录，或者定义额外的环境变量，需要将这些更改放入到 .bash_profile 文件中，其他的改变则应录入 .bashrc 文件中。</li><li>除非是系统管理员需要修改用户公用的默认设置，普通用户只需对主目录下的文件做出修改即可。</li><li>当然用户也可以修改其他目录下的文件。比如 &#x2F;etc 下的 profile 文件，而且很多情况会需要用户这样做。</li></ol><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><ol><li>为了编辑 shell 的启动文件，以及系统中的其他大多数配置文件，我们将用到一个称为文本编辑器的程序。</li><li>文本编辑器类似字处理器，它允许用户通过移动光标的方式来编辑屏幕中的文字。与字处理器不同的是，文本编辑器只支持纯文本，而且通常包含为编写程序而设计的特性。</li><li>文本编辑器是软件开发人员编写代码的主要工具，系统管理员也可以使用文本编辑器来管理系统的配置文件。</li><li>文本编辑器可大概分为两类：图形界面的和基于文本的。GNOME (GNU 网络对象模型环境) 和 KDE (K 桌面环境) 都配备有一些流行的图形界面编辑器。</li><li>GNOME 配备的编辑器叫做 gedit ，在 GNOME 菜单中 gedit 通常被称为 Text Editor 。</li><li>KDE 则配备了三种编辑器，分别是 kedit、kwrite 和 kate (复杂程度递增) 。</li><li>有很多种基于文本的编辑器，常见编辑器中较受用户欢迎的是 nano、vi 和 emacs 。</li><li>nano 是一种简单易用的编辑器，最初是为了替代 pico (由 PINE 电子邮箱套件提供) 而出现的。 vi 是类 Unix 系统的传统文本编辑器 (在大多数 Linux 系统中已被 vim 所取代) 。</li><li>emacs 仍然可用，但是大多数 Linux 系统很少默认安装 emacs 。</li></ol><h3 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h3><ol><li>基本介绍</li></ol><ul><li>所有的文本编辑器都可以通过在命令行输入编辑器名称和需编辑的文件名称的方式启动。如果输入的文件不存在，编辑器会认为用户想要创建一个新的文件。</li><li>下面是一个 gedit 的范例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@kinuxbox ~]$ gedit some_file</span><br></pre></td></tr></table></figure></li><li>如果 some_file 文件存在，这条命令将启动 gedit 编辑器，并载入 some_file 。</li><li>接下来，我们将通过 .bashrc 文件的编辑过程来讲解 nano ， nano 是一个基于文本的编辑器。 </li><li>但是在此之前，需要采取一些安全措施。在修改一些重要的配置文件时，先对配置文件进行备份是一个很好的习惯。 </li><li>我们可以使用以下代码备份：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@kinuxbox ~]$ <span class="built_in">cp</span> .bashrc .bashrc.bak</span><br></pre></td></tr></table></figure></li><li>为备份文件取什么名字并不重要，只要备份文件的名称易于理解即可。扩展名 .bak、.sav、.old 和 .orig 是常用的标示备份文件的方法。</li><li>需要说明的是，cp 命令会默默地覆盖现有的文件。</li><li>备份文件完成之后，就可以启动文件编辑器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@kinuxbox ~]$ nano .bashrc</span><br></pre></td></tr></table></figure></li><li>nano 启动后，屏幕显示内容如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GNU nano 2.0.3        File: .bashrc</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ];<span class="keyword">then</span></span><br><span class="line">        . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># User specific aliases and Fuctions</span></span><br><span class="line">                [ Read 8 lines ]</span><br><span class="line">^G Get Help^O WriteOut^R Read Fil^Y Prev Pag^K Cut Text^C Cur Pos</span><br><span class="line">^X Exit ^J Justify ^W Where Is^V Next Page^U UnCut Te^T To Spell</span><br></pre></td></tr></table></figure></li><li>屏幕显示内容分为三个部分：顶端的标题 (header) 、中间的可编辑文本和底部的命令菜单。 </li><li>由于 nano 是替代电子邮件文本编辑器出现的，所以其编辑文本和底部的命令菜单中有相关的介绍。^X 代表了 Ctrl-X ，这是控制字符的常见表示法，很多程序中都使用它。 </li><li>我们需要了解的第二个命令就是如何保存我们的工作。就 nano 来说，按 Ctrl-O 完成保存。</li><li>掌握这些知识之后，我们就可以进行文本编辑操作了。请使用向下箭头键或者向下翻页键使光标移动到文件的末尾，然后添加以下代码 .bashrc 文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unmask 0002</span><br><span class="line"><span class="built_in">export</span> HISTCONTROL=ignoredups</span><br><span class="line"><span class="built_in">export</span> HISTSIZE=1000</span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l --color=auto&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="15"><li><p>用户系统的 .bashrc 文件可能已经写入了这些代码的一部分，但是不用担心，重复的代码不会造成什么危害。</p></li><li><p>.bashrc 文件增加的代码</p></li></ol><table><thead><tr><th align="center">代码行</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Umask 0002</td><td align="center">设置 umask 以解决第 9 章中讨论过共享目录的问题</td></tr><tr><td align="center">Export HISTSIZE&#x3D;1000</td><td align="center">使命令历史记录规模从默认的 500 行增加到 1000 行</td></tr><tr><td align="center">alias l.&#x3D;’ls -d .* –color&#x3D;aut0’</td><td align="center">创建新的命令： l. ，功能是显示所有以 . 开头的目录条目</td></tr><tr><td align="center">alias ll&#x3D;’ls -l -color&#x3D;auto’</td><td align="center">创建新的命令： ll ，功能是以长格式来展示目录列表</td></tr></tbody></table><ol start="3"><li>.bashrc 文件的注释</li></ol><ul><li>可以看到，很多新增加的代码并不易于理解，所以就需要在 .bashrc 文件中添加一些注释来帮助用户理解代码含义。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Change umask to make directory sharing easier</span></span><br><span class="line"><span class="built_in">umask</span> 0002</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore duplicates in command history and increase</span></span><br><span class="line"><span class="comment"># history size to 1000 lines</span></span><br><span class="line"><span class="built_in">export</span> HISTCONTROL=ignoredups</span><br><span class="line"><span class="built_in">export</span> HISTSIZE=1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add some helpful aliases</span></span><br><span class="line"><span class="built_in">alias</span> l. =<span class="string">&#x27;ls -d .* --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll = <span class="string">&#x27;ls -l --color=auto&#x27;</span></span><br></pre></td></tr></table></figure></li><li>这样一来就易懂多了。最后我们按 Ctrl-O 保存文档，按 Ctrl-X 退出 nano ，这样对 .bashrc 文件的修改就完成了。</li></ul><h3 id="激活我们的修改"><a href="#激活我们的修改" class="headerlink" title="激活我们的修改"></a>激活我们的修改</h3><ol><li>因为只有在启动 shell 会话时才读取 .bashrc ，所以对 .bashrc 做出的修改只有在关闭 shell 终端会话并重启的时候才会生效。当然也可以使用以下命令强制命令 bash 重新读取 .bashrc 文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十七章 文件搜索</title>
      <link href="/post/dbc052ec.html"/>
      <url>/post/dbc052ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十七章-文件搜索"><a href="#第十七章-文件搜索" class="headerlink" title="第十七章 文件搜索"></a>第十七章 文件搜索</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章我们主要介绍两个用于在 Linux 系统中搜索文件的工具：</li></ol><ul><li>locate: 通过文件名查找文件</li><li>find: 在文件系统目录框架中查找文件</li><li>xargs: 从标准输入中建立、执行命令行</li><li>touch: 更改文件的日期时间</li><li>stat: 显示文件或文件系统的状态</li></ul><h2 id="locate-较简单的方式查找文件"><a href="#locate-较简单的方式查找文件" class="headerlink" title="locate - 较简单的方式查找文件"></a>locate - 较简单的方式查找文件</h2><ol><li>locate 命令通过快速搜索数据库，以寻找路径名与给定子字符串相匹配的文件，同时输出所有匹配结果。</li><li>例如，假定查找名称以 zip 字符串开头的程序，由于查找的是程序文件，所以可以认为包含所要查找的程序的目录应以 &#x2F;bin 结尾。因此，可以尝试下面的命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate bin/zip</span><br></pre></td></tr></table></figure></li><li>有时搜索需求并不是这么简单，这时便可以用 locate 命令结合其它诸如 grep 这样的工具实现一些更有趣的搜索。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate zip | grep bin</span><br><span class="line">/bin/bunzip2</span><br><span class="line">/bin/bzip2</span><br><span class="line">/bin/bzip2recover</span><br></pre></td></tr></table></figure></li><li>locate 程序已经使用了很长时间，因此出现了多种衍生体。 slocate 和 mlocate 是现代 Linux 发行版本中最常见的两个衍生体，而它们通常都是由名为 locate 的符号链接访问。</li><li>不同版本的 locate 有一些相同的选项设置，而有些版本则包括正则表达式匹配和通配符支持等。</li></ol><h2 id="find-较复杂的方式查找文件"><a href="#find-较复杂的方式查找文件" class="headerlink" title="find - 较复杂的方式查找文件"></a>find - 较复杂的方式查找文件</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>locate 程序查找文件仅仅是依据文件名，而 find 程序则是依据文件的各种属性在既定的目录 (及其子目录) 里查找。</li><li>find 最简单的用就是用户给定一个或是更多目录名作为其搜索范围。</li><li>下面就用 find 命令列出当前系统主目录 ~ 下的文件列表清单。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~</span><br></pre></td></tr></table></figure></li><li>对于一些比较活跃的用户，一般系统内文件会比较多，使得上述命令输出的列表肯定很长。</li><li>不过，列表信息是以标准形式输出的，所以可以直接将此输出结果作为其他程序的输入。</li><li>如下就是用 wc 程序计算 find 命令搜索到文件的总量。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ | <span class="built_in">wc</span> -l</span><br><span class="line">47068</span><br></pre></td></tr></table></figure></li><li>find 命令的美妙之处就是可以用来搜索符合特定要求的文件，它通过综合应用 test 选项、action 选项以及 options 选项实现高级文件搜索。</li></ol><h3 id="test-选项"><a href="#test-选项" class="headerlink" title="test 选项"></a>test 选项</h3><ol><li>基本介绍</li></ol><ul><li>下面让我们首先了解 test 选项。假设我们想要查找的是目录文件，我们可以添加下面的 test 选项达到此目的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ -<span class="built_in">type</span> d | <span class="built_in">wc</span> -l</span><br><span class="line">1695</span><br></pre></td></tr></table></figure></li><li>添加 test 参数 -type d 可以将搜索范围限制为目录，而下面例子中使用 -type f 则表示只对普通文件进行搜索。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>find 支持搜索的文件类型</li></ol><table><thead><tr><th align="center">文件类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">块设备文件</td></tr><tr><td align="center">c</td><td align="center">字符设备文件</td></tr><tr><td align="center">d</td><td align="center">目录</td></tr><tr><td align="center">f</td><td align="center">普通文件</td></tr><tr><td align="center">l</td><td align="center">符号链接</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>另外我们还可以通过添加其他的 test 项参数实现依据文件大小和文件名的搜索。</li><li>如下命令行就是用来查找所有符合 *.JPG 通配符格式以及超过 1 MB 的普通文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ -<span class="built_in">type</span> f -name <span class="string">&quot;*.JPG&quot;</span> -size +1M | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li><li>本例中添加的 -name “*.JPG” 的 test 选项表示查找的是符合 .JPG 通配符格式的文件。</li><li>注意，这里将通配符扩在上引号中是为了避免 shell 路径名扩展。</li><li>另外添加的 -size +1M test 选项，前面的加号表示查找的文件大小比给数值 1M 大。</li><li>若字符串前面是减号则表示与给定值完全相等。末尾的 M 是计算单位 MB 的简写</li></ul><ol start="4"><li>find 支持的计量单位</li></ol><table><thead><tr><th align="center">字母</th><th align="center">单位</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">512 字节块 (没有具体说明时的默认值)</td></tr><tr><td align="center">c</td><td align="center">字节</td></tr><tr><td align="center">w</td><td align="center">两个字节的字</td></tr><tr><td align="center">k</td><td align="center">KB (每单位包含 1024 字节)</td></tr><tr><td align="center">M</td><td align="center">MB (每单位包含 1048576 字节)</td></tr><tr><td align="center">G</td><td align="center">GB (每单位包含 1073741824 字节)</td></tr></tbody></table><ol start="5"><li>find 命令的 test 参数</li></ol><table><thead><tr><th align="center">test参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-cmin n</td><td align="center">匹配 n 分钟前改变状态 (内容或属性) 的文件或目录。如果不到 n 分钟，就用 -n ，如果超过 n 分钟，就用 +n</td></tr><tr><td align="center">-cnewer file</td><td align="center">匹配内容或属性的修改时间比文件 file 更晚的文件或目录</td></tr><tr><td align="center">-ctime n</td><td align="center">匹配系统中 n*24 小时前文件状态被改变 (内容、属性、访问权限等) 的文件或目录</td></tr><tr><td align="center">-empty</td><td align="center">匹配空文件及空目录</td></tr><tr><td align="center">-group name</td><td align="center">匹配属于 name 组的文件或目录。 name 可以描述为组名，也可以描述为该组的 ID 号</td></tr><tr><td align="center">-iname pattern</td><td align="center">与 -name test 项功能类似只是不区分大小写</td></tr><tr><td align="center">-inum n</td><td align="center">匹配索引节点是 n 的文件。该 test 选项有助于查找某个特定索引节点上的所有硬件连接</td></tr><tr><td align="center">-mmin n</td><td align="center">匹配 n 分钟前内容被修改的文件或目录</td></tr><tr><td align="center">-mtime n</td><td align="center">匹配 n*24 小时前只有内容被更改的文件或目录</td></tr><tr><td align="center">-name pattern</td><td align="center">匹配有特定通配符模式的文件或目录</td></tr><tr><td align="center">-newer file</td><td align="center">匹配内容的修改时间比 file 文件更近的文件或目录。这在编写 shell 脚本进行文件备份的时候非常有用。每次创建备份时，更新某个文件 (比如日志) ，然后用 find+ 此参数选项来确定上一次更新后哪个文件改变了</td></tr><tr><td align="center">-nouser</td><td align="center">匹配不属于有效用户的文件或目录。该 test 可以用来查找哪些属于已删除账户的文件，也可以用来检测攻击者的活动匹配不属于有小组的文件或目录</td></tr><tr><td align="center">-perm mode</td><td align="center">寻找访问权限与既定模式匹配的文件或目录。既定模式可以用八进制或符号的形式表示</td></tr><tr><td align="center">-samefile name</td><td align="center">与 -inum test 选项类似。匹配与 file 文件用相同的 inode 号的文件</td></tr><tr><td align="center">-size n</td><td align="center">匹配 n 大小的文件</td></tr><tr><td align="center">-type c</td><td align="center">匹配 c 类型的文件</td></tr><tr><td align="center">-user name</td><td align="center">匹配属于 name 用户的文件和目录。 name 可以描述为用户也可以描述该组的 ID 号</td></tr></tbody></table><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol><li>基本介绍</li></ol><ul><li>即使拥有 find 命令提供的所有 test 参数，我们仍然会需要一个更好的工具来描述 test 参数之间的逻辑关系。</li><li>例如，如果我们需要确定某目录下是否所有的文件和子目录都有安全的访问权限，该怎么办？原则上就是去查找那么访问权限不是 0600 的文件和访问权限不是 0700 的子目录。</li><li>幸运的是，find 命令的 test 可以结合逻辑操作从而建立具有复杂逻辑关系的匹配条件。</li><li>我们可以用下面的命令行来满足上述 find 命令的匹配搜索。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ \(-<span class="built_in">type</span> f -not -perm 0600 \) -or \(-<span class="built_in">type</span> d -not -perm 0700 \)</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>find 命令的逻辑操作符</li></ol><table><thead><tr><th align="center">操作符</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-and (与操作)</td><td align="center">查找使该操作符两遍的检验条件都是真的匹配文件。有时直接缩写成 -a 。注意如果两个检测条件之间没有显式的显式操作符， and 就是默认的逻辑关系</td></tr><tr><td align="center">-or (或操作)</td><td align="center">查找使该操作符任何一边的检测条件为真的匹配文件。有时候直接缩写成 -o</td></tr><tr><td align="center">-not (非操作)</td><td align="center">查找使该操作符后面的检测条件为假的匹配文件。有时候直接缩写成-!</td></tr><tr><td align="center">() (括号操作)</td><td align="center">有时为了获得想要的结果必须扰乱默认的执行顺序，即便不需要，将一串字符表达式括起来对提高命令的可读性也很有帮助。请注意，括号字符在 shell 环境中有特殊意义，所以必须将它们在命令行中用引号引起来，这样才能作为 find 的参数传递。通常用反斜杠来避免这样的问题</td></tr></tbody></table><ol start="3"><li>操作符的补充说明</li></ol><ul><li>对照这张逻辑操作符的列表，重新剖析上述的 find 命令行。从最全局的角度看，所有检测条件由一个或 (or) 操作符分成了两组。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(表达式1) -or (表达式2) </span><br></pre></td></tr></table></figure></li><li>这样做是有原因的，因为我们查找的是具有某种权限设置的文件和另外一种权限设置的目录。</li><li>那既然要同时查找文件和目录，怎么不使用 and 而是用 or ？因为 find 命令在扫描所有的文件和目录时，会判断每一个文件或目录是否匹配该 test 项检测条件。</li><li>而我们的目标是具有不安全访问权限的文件或是具有不安全访问权限的目录，都知道匹配者不可能既是文件又是目录，所以不能用 and 逻辑关系。由此，可将表达式扩充如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(file with bad perms) -or (directory with bad perms)</span><br></pre></td></tr></table></figure></li><li>接下来的问题就是如何判断文件或是目录具有危险权限，我们该怎么做呢？事实上，我们并不需要直接去寻找危险权限的文件或是目录，而是查找那些具有不好权限的文件或目录，因为我们知道什么是好的权限。</li><li>对于文件来说，权限是 0600 表示好的，而对于目录，好的权限应该是 0700 。于是，判断具有不好访问权限的文件的表达式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">type</span> f -and -not -perms 0600</span><br></pre></td></tr></table></figure></li><li>同样，判断具有不好访问权限的目录的表达式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">type</span> d -and -not -perms 0700</span><br></pre></td></tr></table></figure></li><li>and 操作是默认的，所以可以安全地移除。把如上表达式都整理到一起一下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ (-<span class="built_in">type</span> f -not -perms 0600) -or (-<span class="built_in">type</span> d not -perms 0700)</span><br></pre></td></tr></table></figure></li><li>然而，由于括号在 shell 环境下有特殊含义，所以我们必须对它们进行转义以防 shell 试图编译它们。在每个括号前加上反斜杠便可解决此问题。 </li><li>逻辑运算符的另外一个特性也很值得大家了解，有如下两个逻辑操作符分开的表达式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 -operator expr2</span><br></pre></td></tr></table></figure></li><li>在任何情况下，表达式 expr1 都会被执行，而中间的操作符将决定表达式 expr2 是否被执行</li></ul><ol start="4"><li>find 命令的 and&#x2F;or 逻辑运算</li></ol><table><thead><tr><th align="center">表达式 expr1 的结果</th><th align="center">逻辑操作</th><th align="center">表达式 expr2 执行情况</th></tr></thead><tbody><tr><td align="center">真</td><td align="center">and</td><td align="center">总是执行</td></tr><tr><td align="center">假</td><td align="center">and</td><td align="center">不执行</td></tr><tr><td align="center">真</td><td align="center">or</td><td align="center">不执行</td></tr><tr><td align="center">假</td><td align="center">or</td><td align="center">总是执行</td></tr></tbody></table><ol start="5"><li>操作符细节说明</li></ol><ul><li>主要还是为了提高效率，以 -and 逻辑运算为例，很明显表达式 expr1 -and expr2 的值在 expr1 为假的情况下不可能为真，所以就没有必要再运算表达式 expr2 了。</li><li>同样，对于表达式 expr1 -or expr2 ，在表达式 expr1 为真的情况下其逻辑值显然为真，于是就没有必要在运算表达式 expr2 了。</li></ul><h3 id="action-选项"><a href="#action-选项" class="headerlink" title="action 选项"></a>action 选项</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>前面 find 命令已经查找到所需要的文件，但是我们真正想做的是处理这些已查找的文件。幸运的是，find 命令允许直接对搜索结果执行动作。</li></ol><h4 id="预定义动作"><a href="#预定义动作" class="headerlink" title="预定义动作"></a>预定义动作</h4><ol><li>基本介绍</li></ol><ul><li>对搜索到的文件进行操作，即可以用诸多现成的预定义动作指令，也可以使用用户自定义的动作。首先来看一些预定义动作。</li></ul><ol start="2"><li>预定义的 find 命令操作</li></ol><table><thead><tr><th align="center">动作</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-delete</td><td align="center">删除匹配文件</td></tr><tr><td align="center">-ls</td><td align="center">对匹配文件执行 ls 操作，以标准格式输出其文件名以及所要求的的其他信息</td></tr><tr><td align="center">-print</td><td align="center">将匹配的文件的全路径以标准形式输出，当没有指定任何具体操作时，该操作是默认操作</td></tr><tr><td align="center">-quit</td><td align="center">一旦匹配成功便退出</td></tr></tbody></table><ol start="3"><li>案例</li></ol><ul><li>本章开头所举的第一个例子如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~</span><br></pre></td></tr></table></figure></li><li>此命令行产生了一个包含当前系统主 ~ 目录中所有文件和子目录的列表。</li><li>列表之所以会在屏幕上显示出来，是因为在没有指定其他操作的情况下，-print 操作是默认的。因此，上述命令行等效于如下形式的命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></li><li>当然也可以使用 find 命令删除满足特定条件的文件。示例如下，此命令行用于删除 .BAK (这种文件一般是用来制动备份文件的) 后缀的文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;.BAK&#x27;</span> -delete</span><br></pre></td></tr></table></figure></li><li>本例中，用户主目录及其子目录下的每个文件都搜索了一遍匹配文件名以 .BAK 结尾的文件。一旦被找到，直接删除。</li><li>毫无疑问，在使用 -delete 操作时，你一定要格外小心。最好先用 -print 操作确认搜索结果后再执行 -delete 删除命令。</li><li>补充介绍一下逻辑运算是如何映像 find 的 action 操作的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;*.BAK&#x27;</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></li><li>正如我们所知道，该命令行用来查找所有文件名以 .BAK 结尾的普通文件 (-type f) 并且以标准形式 (-print) 输出每个匹配文件的相关路径名。</li><li>然而，该命令行之所以照这样方式是由每个 test 选项和 action 之间的逻辑关系决定的。记住，每个 test 选项和 action 选项之间默认的逻辑关系是与 (and) 逻辑。下面的命令行逻辑关系能看得更清楚些。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -and -name <span class="string">&#x27;*.BAK&#x27;</span> -and -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></li><li>如上便是完整的表达式，列出了逻辑运算符是如何影响 action 操作的。</li></ul><ol start="4"><li>逻辑运算符的影响</li></ol><table><thead><tr><th align="center">检测条件&#x2F;执行操作</th><th align="center">在该情况下执行操作</th></tr></thead><tbody><tr><td align="center">-print</td><td align="center">-type f 和 -name ‘*.BAK’ 条件都匹配时，也就是文件是普通文件并且文件名也是以 .BAK 结尾时</td></tr><tr><td align="center">-name ‘*.BAK’</td><td align="center">-type f 项匹配，也就是说文件是普通文件时</td></tr><tr><td align="center">-type f</td><td align="center">总是执行，因为是与逻辑关系中的第一个操作数</td></tr></tbody></table><ol start="5"><li>补充说明</li></ol><ul><li>test 选项与 action 选项之间的逻辑关系决定了他们的执行情况，所以 test 选项和 action 选项的顺序很重要。</li><li>例如，如果重新排列这些 test 选项和 action 选项，并将 -print 操作作为逻辑运算的第一个操作数，那么命令行的运行结果将会有很大不同。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">print</span> -and -<span class="built_in">type</span> f -and -name <span class="string">&#x27;*.BAK&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>此命令行把每个文件显示出来 (因为 -print 操作运算值总是为真) ，然后再对文件类型以及特定的文件扩展名进行匹配检查。</li></ol><h4 id="用户自定义操作"><a href="#用户自定义操作" class="headerlink" title="用户自定义操作"></a>用户自定义操作</h4><ol><li>除了已有的预定义操作命令，同样也可以任意调用用户想要执行的操作命令，传统的方法就是像以下命令行使用 -exec 操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">exec</span> <span class="built_in">command</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li>该格式中的 command 表示要执行的操作命令名，{} 花括号代表的是当前路径，而分号作为必需的分隔符表示命令结束。使用 -exec 完成 -delete 操作示例如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">exec</span> <span class="built_in">rm</span> <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure></li><li>同样，由于括号和分号字符在 shell 环境下有特殊含义，所以在输入命令行时，要将它们用引号引起来或者转义符隔开。</li><li>当然，交互式地执行用户自定义操作也不是不可能。通过使用 -ok 操作取代原来的 -exec 操作，每一次指定命令执行之前系统都会询问用户。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -ok <span class="built_in">ls</span> -l <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">&lt; <span class="built_in">ls</span> ... /home/me/binfoo &gt; ? y</span><br><span class="line">-rwxr-xr-x 1 me me 224 2011-10-29 18:44 /home/me/foo</span><br><span class="line">&lt; <span class="built_in">ls</span> ... /home/me/foo.txt &gt; ? y</span><br><span class="line">-rw-r--r-- 1 me me 0 2012-09-19 12:53 /home/me/foo.txt</span><br></pre></td></tr></table></figure></li><li>上例中，查找文件名以 foo 字符串开始的文件，并且每次找到匹配文件后执行 ls -l 命令。 -ok 操作会在 ls 命令执行之前询问用户是否执行。</li></ol><h4 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h4><ol><li>当使用 -exec 操作时，每次查找到匹配文件后都会调用执行一次指定命令。但有时用户更希望只调用一次命令就完成所有匹配文件的操作。例如，多数人可能更喜欢这样的命令执行方式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l file1</span><br><span class="line"><span class="built_in">ls</span> -l file2</span><br></pre></td></tr></table></figure></li><li>而不是以下这样的方式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l file1 file2</span><br></pre></td></tr></table></figure></li><li>第一种方式只需要执行命令一次而第二种方式则要多次重复执行。实现这样的一次操作的两种方法：一种方式比较传统，使用外部命令 xarges ；另一种则是使用 find 本身自带的新特性。首先介绍下第二方法。</li><li>通过将命令行末尾的分号改为加号，便可将 find 命令所搜索到匹配结果作为指定命令的输入，从而一次完全对所有文件操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br></pre></td></tr></table></figure></li><li>上面的例子，每次找到匹配文件后就执行一次 ls 命令。将上述命令行改成下面的命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">-rwxr-xr-x 1 me me 224 2011-10-29 18:44 /home/me/bin/foo</span><br><span class="line">-rw-r--r-- 1 me me 0 2012-09-19 12:53 /home/me/foo.txt</span><br></pre></td></tr></table></figure></li><li>我们也能得到相同的结果，但是系统整体只执行一次 ls 命令。</li><li>同样我们可以使用 xargs 命令获得相同的效果，xargs 输入， xargs 反过来将其转换成了 ls 命令的输入参数列表，最后执行 ls 操作。</li><li>虽然一个命令行中可允许输入的参数有很多，但这并不表示可以无限输入，也存在命令行过长而使得 shell 编辑器无法承受的情况。</li><li>如果命令行中包含的输入参数太多而超过了系统支持的最大长度， xargs 只会尽可能对最大数量的参数执行指定操作，并不断重复这一过程知道所有标准输入全部处理完毕。</li><li>在 xargs 命令后面添加 –show-limits 选项，即可知道命令行最大能承受的参数数量。</li></ol><h3 id="返回到-playground-文件夹"><a href="#返回到-playground-文件夹" class="headerlink" title="返回到 playground 文件夹"></a>返回到 playground 文件夹</h3><ol><li>现在可以实际应用 find 命令了。首先让我们创建一个包含很多子目录及文件的 playground 文件夹平台。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> -p playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125;</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..9&#125;,100&#125;/file-&#123;A..Z&#125;</span><br></pre></td></tr></table></figure></li><li>不得不惊叹于 Linux 命令行的威力！简单的两行命令，就创建了一个包含 100 个子目录的 playground 文件夹，并且每个子目录中又包含 26 个空文件。</li><li>我们用来创造这个奇迹的方法包含一个熟悉的命令 mkdir、一个奇异的 shell 花括号扩展以及一个新命令 touch 。</li><li>mkdir 命令结合 -p 选项 (-p 选项是的 mkdir 命令按指定的路径创建父目录) 的同时用花括号扩展，便完成了 100 个目录的创建。</li><li>touch 命令一般用于设定或是更新文件的修改时间。然而，当文件名参数是一个不存在的文件时，那么该命令就会创建一个空文件。</li><li>playground 文件夹里，总共创建了 100 个叫做 file-A 的文件。现在，我们可以查找它们。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -name <span class="string">&#x27;file-A&#x27;</span></span><br></pre></td></tr></table></figure></li><li>请注意，与 ls 命令不同，find 命令不会产生有排列顺序的结果，其输出顺序是由在存储设备中的布局决定的。</li><li>下面的命令行验证了该文件夹确实有 100 个 file-A 文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -name <span class="string">&#x27;file-A&#x27;</span> | <span class="built_in">wc</span> -l</span><br><span class="line">100</span><br></pre></td></tr></table></figure></li><li>下面来看一个根据文件的修改时间查找文件的例子，在这创建备份文件以及按时间顺序排列文件时非常有用。首先需要创建一个用作比较修改时间的参照文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/timestamp</span><br></pre></td></tr></table></figure></li><li>该命令行创建了一个名为 timestamp 的空文件，并将当前时刻设为该文件的修改时间。我们可以使用另外一个便捷的命令 stat 来检验执行效果，stat 命令可以说是 ls 的增强版，该命令会将系统所掌握文件的所有信息及属性全部显示出来。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">stat</span> playground/timestamp</span><br><span class="line">File:<span class="string">&#x27;playground、timestamp&#x27;</span></span><br><span class="line">Size: 0     Blocks: 0  IO Block: 4096 regular empty file</span><br><span class="line">Device: 803h/2051d Inode: 14265061 Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--) Uid: (1001/me) Gid:(1001/me)</span><br><span class="line">Acess: (0644/-rw-r--) Uid: (100/me) Gid:(1001/me)</span><br><span class="line">Access:2012-10-08 15:15:39.00000000 -0400</span><br><span class="line">Modify: 2012-10-08 15:15:39.00000000 -0400</span><br><span class="line">Change: 2012-10-08 15:15:39.00000000 -0400</span><br></pre></td></tr></table></figure></li><li>接下来，我们便可以用 find 命令更新 playground 文件夹里的一些文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -newer playground/timestamp</span><br></pre></td></tr></table></figure></li><li>命令行的运行结果包含 100 个文件名为 file-B 的文件。由于我们是在对 timestamp 文件执行了 touch 命令之后，才对 playground 文件夹对名为 file-B 的所有文件执行了 touch 操作，所以它们现在要比 timestamp 文件新，从而我们可选用 -newer test 选项查找。</li><li>最后，回顾之前讨论的查找不安全访问权限文件的例子，并将其用于 playground 目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground \(-<span class="built_in">type</span> f -not -perm 0600 \) -or \(-<span class="built_in">type</span> d -not -perm 0700 \)</span><br></pre></td></tr></table></figure></li><li>该命令行列出了 playground 目录下的下的所有的 100 个子目录以及 2600 个文件 (再加上 timestamp 文件和 playground 自身，总共 2072 个) ，之所以全部列出是因为 playground 里面没有一个文件满足安全访问权限的要求。</li><li>运用前面所学 find 命令的 operator 选项和 action 选项的知识，我们可以在命令后面增加 action 参数选项来改变 playground 目录下文件或目录的访问权限。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground \( -<span class="built_in">type</span> f -not -perm 0700 -<span class="built_in">exec</span> <span class="built_in">chmod</span> 0700 <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span> \)</span><br></pre></td></tr></table></figure></li><li>依据日常经验，大家可能会觉得用两条命令-分别针对目录和文件，比用这样一个长而复杂的命令容易的多。不过知道这一知识点总比不知道好，此处的重点是，要了解如何结合使用操作符选项与行为选项，来执行一些有用的任务。</li></ol><h3 id="option-选项"><a href="#option-选项" class="headerlink" title="option 选项"></a>option 选项</h3><ol><li>基本介绍</li></ol><ul><li>最后，我们谈一个 find 命令的 option 选项。 option 选项用于控制 find 命令的搜索范围。</li><li>在构成 find 命令的表达式时，他们可能包含在其他测试选项或行为选项之中。</li></ul><ol start="2"><li>find 命令的 option 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-depth</td><td align="center">引导 find 程序处理目录前先处理目录内文件。当指定 -delete 操作时，该参数选项会自动调用</td></tr><tr><td align="center">-maxdepth levels</td><td align="center">当执行测试条件行为时，设置 find 程序陷入目录数的最大级别数</td></tr><tr><td align="center">-mindepth levels</td><td align="center">在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数</td></tr><tr><td align="center">-mount</td><td align="center">引导 find 不去遍历挂载在其他文件系统上的目录</td></tr><tr><td align="center">-noleaf</td><td align="center">指导 find 程序不要基于正在搜索 UNIX 文件系统的假设来优化它的搜索。当扫描 DOS&#x2F;Windows 文件系统和 CD 时，会用到该选项</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十章 文本处理</title>
      <link href="/post/cf2b821b.html"/>
      <url>/post/cf2b821b.html</url>
      
        <content type="html"><![CDATA[<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>由于所有类 UNIX 操作系统都严重依赖于文本文件来进行某些数据类型的存储，所以需要有很多可以进行文本操作的工具。</li><li>本章主要介绍一些与切割文本有关的命令，第 21 章会进一步探讨文本处理工具，并重点讲解那些用于格式化输出以及其他满足人类需求的程序。</li><li>本章首先会回顾之前讲过的一些命令，然后讲解一些新的命令。</li></ol><ul><li>cat: 连接文件并打印到标准输出</li><li>sort: 对文本排序</li><li>uniq: 报告并省略重复行</li><li>cut: 从每一行中移除文本区域</li><li>paste: 合并文件文本行</li><li>join: 基于某个共享字段来联合两个文件的文本行</li><li>comm: 逐行比较两个已经排好序的文件</li><li>diff: 逐行比较文件</li><li>patch: 对原文件打补丁</li><li>tr: 转换或删除字符</li><li>sed: 用于过滤和转换文本的流编辑器</li><li>aspell: 交互式拼写检查器</li></ul><h2 id="文本应用程序"><a href="#文本应用程序" class="headerlink" title="文本应用程序"></a>文本应用程序</h2><ol><li>基本介绍</li></ol><ul><li>到目前为止，我们总共介绍了两种文本编辑 (nano 和 vim) ，看过一堆配置文件，并且目睹了许多命令的输出都是文件格式。</li></ul><ol start="2"><li>文件</li></ol><ul><li>许多人都采用纯文本格式编辑文件。虽然大家都知道用一些较小的文本文件进行一些简单的笔记很方便、很实用，但同样，我们也可以用文本格式编辑较大的文档。</li><li>有一种常用的方法，即首先在文本编辑器中编辑大型文档的内容，然后使用标记语言描述文件格式。</li></ul><ol start="3"><li>网页</li></ol><ul><li>网页可以说是世界上最常见的电子文档。网页属于文本文档，一般使用 HTML (Hypertext Markup Language) 或者 XML (eXtensible Markup Language) 等标记语言描述内容的可视化形式。</li></ul><ol start="4"><li>电子邮件</li></ol><ul><li>电子邮件本质上是一种基本文本的媒介，即便是非文本附近，在传输的时候也会被转成文本格式。</li></ul><ol start="5"><li>打印机输出</li></ol><ul><li>在类 UNIX 系统中，准备向打印机传送的信息是以纯文本格式传送的。如果该页包含图像，则将其转换成 PostScript 文本格式页面描述语言后再送至指定程序以打印图像像素。</li></ul><ol start="6"><li>程序源代码</li></ol><ul><li>类 UNIX 系统中的许多命令行程序都是为了支持系统管理和软件开发而编写的，文本处理程序也不例外。</li><li>文本处理对软件开发者如此重要，是因为所有的软件都是从文本开始的，程序员所编写的源代码，也总是以文本的形式编辑。</li></ul><h2 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>在第 6 章，我们学习了一些既支持命令行参数输入也支持标准输入的命令。不过当时只是泛泛而谈，现在我们详细讨论这些命令如何用于文本处理。</li></ol><h3 id="cat-进行文件之间的拼接并且输出到标准输出"><a href="#cat-进行文件之间的拼接并且输出到标准输出" class="headerlink" title="cat - 进行文件之间的拼接并且输出到标准输出"></a>cat - 进行文件之间的拼接并且输出到标准输出</h3><ol><li>cat 命令有许多有趣的参数选项，而其中多数则是用于提高文本内容的可视化效果。</li><li>-A 选项就是一个例子，它用于显示文本中的非打印字符。</li><li>例如，用户有时候会想知道可见文本中是否嵌入了控制字符，其中最为常见的就是制表符 (而不是空格) 以及回车符，在 MS-DOS 风格的文本文件中，回车符经常作为结束符出现。另一种常见情况是文件中包含末尾带有空格的文件行。</li><li>我们创建一个测试文件，用 cat 程序作为一个简单的文字处理器。</li><li>为此，只需要输入 cat 命令 (随后指定了用于重定向输出的文件) 再输入文本内容，按 Enter 键结束行输入，最后按 Ctrl-D 告诉 cat 到达文件末尾。</li><li>下例中，我们输入了一个以 Tab 制表符开头、空格符结尾的文本行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown jumped over the lazy dog.</span><br><span class="line">[me@linux ~]$</span><br></pre></td></tr></table></figure></li><li>下面，我们利用带有 -A 选项的 cat 命令显示文本内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">cat</span> -A foo.txt</span><br><span class="line">^IThe quick brown jumped over the lazy dog. $</span><br><span class="line">[me@linux ~]$</span><br></pre></td></tr></table></figure></li><li>输出结果表明，文本中 Tab 制表符由符号 ^I 表示。这是一种常见的表示方法，意思是 Ctrl-I ，结果证明，它等同于 Tab 制表符。同时，在文件末尾出现的 $ 符说明行末尾存在空格。</li><li>cat 也有很多用于修改文本的参数选。最著名的两个选项：-n ，对行编号；-s ，禁止输出多个空白行。示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jumped over the lazy dog.</span><br><span class="line">[me@linux ~]$ <span class="built_in">cat</span> -ns foo.txt</span><br><span class="line">    1The quick brown fox</span><br><span class="line">    2</span><br><span class="line">    3jumped over the lazy dog.</span><br><span class="line">[me@linux ~]$</span><br></pre></td></tr></table></figure></li><li>本例中，我们创建了一个 foo.txt 测试文件的新版本，该文件内容为两个文本行，并以空白行隔开。</li><li>用 cat 加 -ns 选项对其操作后，多余的空白行便被移除，并对剩余的行进行了编号。</li><li>然而这并不是多个进程在操作这个文本，只有一个进程。</li></ol><h3 id="sort-对文本行进行排序"><a href="#sort-对文本行进行排序" class="headerlink" title="sort - 对文本行进行排序"></a>sort - 对文本行进行排序</h3><ol><li>sort 基本介绍</li></ol><ul><li>sort 是一个排序程序，它的操作对象为标准输入或是命令行中指定的一个或多个文件后将结果送至标准输出。与 cat 用法类似，如下所示，我们将直接使用键盘演示标准输入内容的处理过程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> &gt; foo.txt</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></li><li>输入 sort 命令后，输入字母 c、b、a ，最后按下 Ctrl-D 结束输入。然后查看处理结果，会发现这些行都以排好的顺序出现。</li><li>由于 sort 命令允许多个文件作为其输入参数，所以可以将多个文件融合为一个已排序的整体文件。</li><li>例如，我们有三个文本文件，并期望将它们拼接为一个已排序的整体文件。我们可以用下面的命令行去执行。</li></ul><ol start="2"><li>常见的 sort 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">全局选项表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-b</td><td align="center">--ignore-leading-blanks</td><td align="center">默认情况下，整个行都会进行排序操作；也就是从行的第一个字符开始。添加该选项后，sort 会忽略行开头的空格，并且从第一个非空白字符开始排序</td></tr><tr><td align="center">-f</td><td align="center">--ignore-case</td><td align="center">排序时不区分字符大小写</td></tr><tr><td align="center">-n</td><td align="center">--numeric-sort</td><td align="center">基于字符串的长度进行排序。该选项是的文件按数值顺序而不是按字母表顺序进行排序</td></tr><tr><td align="center">-r</td><td align="center">--reverse</td><td align="center">逆序排序。输出结果按照降序排列而不是升序。</td></tr><tr><td align="center">-k</td><td align="center">--key&#x3D;field1,[field2]</td><td align="center">对 field1 与 field2 之间的字符排序，而不是整个文件行</td></tr><tr><td align="center">-m</td><td align="center">--merge</td><td align="center">将每个输入参数当作已排好序的文件名。将多个文件合并为一个排好序的文件，而不执行额外的排序操作</td></tr><tr><td align="center">-o</td><td align="center">--output&#x3D;file</td><td align="center">将排序结果输出到文件而不是标准输出</td></tr><tr><td align="center">-t&#96;</td><td align="center">--field-separator&#x3D;char</td><td align="center">定义字段分隔符。默认情况下，字段是由空格或制表符分开的</td></tr></tbody></table><ol start="3"><li>案例一</li></ol><ul><li>作为演示，我们可将 du 命令的输出结果进行排序，以确定最大的硬盘空间用户。</li><li>正常情况下，du 命令会列出一个以路径名顺序排序的列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">du</span> -s /usr/share/* | <span class="built_in">head</span></span><br><span class="line">8   /usr/share/CSI</span><br><span class="line">48   /usr/share/CoreDuetDaemonConfig.bundle</span><br><span class="line">0   /usr/share/ans2_dummy_dir</span><br><span class="line">1016   /usr/share/applecare</span><br><span class="line">512   /usr/share/calendar</span><br><span class="line">40   /usr/share/com.apple.languageassetd</span><br><span class="line">1552   /usr/share/cracklib</span><br><span class="line">8904   /usr/share/cups</span><br><span class="line">2928   /usr/share/dict</span><br><span class="line">9944   /usr/share/doc</span><br></pre></td></tr></table></figure></li><li>本例中，我们把结果管道到 head 命令，把输出结果限制为只显示前 10 行。</li><li>我们能够产生一个按数值排序的列表，来显示 10 个最大空间消费者。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">du</span> -s /usr/share/* | <span class="built_in">sort</span> -nr | <span class="built_in">head</span></span><br><span class="line">132104/usr/share/tokenizer</span><br><span class="line">70152/usr/share/man</span><br><span class="line">46400/usr/share/firmware</span><br><span class="line">28864/usr/share/vim</span><br><span class="line">27896/usr/share/icu</span><br><span class="line">26048/usr/share/langid</span><br><span class="line">20352/usr/share/terminfo</span><br><span class="line">13896/usr/share/morphun</span><br><span class="line">10592/usr/share/zsh</span><br><span class="line">9944/usr/share/doc</span><br></pre></td></tr></table></figure></li><li>通过使用 -nr 参数选项，我们便可以产生一个逆向的数值排序，它使得最大数值排列在第一位。</li><li>这种排序起作用是因为数值出现在每一行的开头。</li></ul><ol start="4"><li>案例二</li></ol><ul><li>但是如果我们想要基于文本行中的某个数值排序，又会怎么样呢？<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | <span class="built_in">head</span></span><br><span class="line">total 184736</span><br><span class="line">lrwxr-xr-x  1 root   wheel        74  1  1  2020 2to3- -&gt; ../../System/Library/Frameworks/Python.framework/Versions/2.7/bin/2to3-2.7</span><br><span class="line">lrwxr-xr-x  1 root   wheel        74  1  1  2020 2to3-2.7 -&gt; ../../System/Library/Frameworks/Python.framework/Versions/2.7/bin/2to3-2.7</span><br><span class="line">-rwxr-xr-x  1 root   wheel    206512  1  1  2020 AssetCacheLocatorUtil</span><br><span class="line">-rwxr-xr-x  1 root   wheel    264704  1  1  2020 AssetCacheManagerUtil</span><br><span class="line">-rwxr-xr-x  1 root   wheel    204096  1  1  2020 AssetCacheTetheratorUtil</span><br><span class="line">-rwxr-xr-x  1 root   wheel    137536  1  1  2020 BuildStrings</span><br><span class="line">-rwxr-xr-x  1 root   wheel    137536  1  1  2020 CpMac</span><br><span class="line">-rwxr-xr-x  1 root   wheel    137536  1  1  2020 DeRez</span><br><span class="line">-rwxr-xr-x  1 root   wheel    137536  1  1  2020 GetFileInfo</span><br></pre></td></tr></table></figure></li><li>此刻，忽略 ls 命令自有的根据文件大小排序的功能，而用 sort 程序依据文件大小进行排序。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | <span class="built_in">sort</span> -nr -k 5 | <span class="built_in">head</span></span><br><span class="line">-rwxr-xr-x  1 root   wheel  28133808  1  1  2020 php</span><br><span class="line">-rwxr-xr-x  1 root   wheel  11266800  1  1  2020 fileproviderctl</span><br><span class="line">-r-xr-xr-x  1 root   wheel   6455408  1  1  2020 parl5.30</span><br><span class="line">-r-xr-xr-x  1 root   wheel   6077168  1  1  2020 parl5.28</span><br><span class="line">-rwxr-xr-x  1 root   wheel   4672160  1  1  2020 kmutil</span><br><span class="line">-rwxr-xr-x  1 root   wheel   4548272  1  1  2020 vim</span><br><span class="line">-rwxr-xr-x  1 root   wheel   4303584  1  1  2020 ssh</span><br><span class="line">-rwxr-xr-x  1 root   wheel   3781856  1  1  2020 ssh-keyscan</span><br><span class="line">-rwxr-xr-x  1 root   wheel   3779728  1  1  2020 ssh-keygen</span><br><span class="line">-rwxr-xr-x  1 root   wheel   3766736  1  1  2020 dig</span><br></pre></td></tr></table></figure></li><li>sort 的许多用法都与表格数据处理有关，比如上面 ls 命令的输出结果。</li><li>如果我们把数据库这个术语应用到上面的表格中，我们会说每一行就是一项记录，而每一个记录又包含多个字段，诸如文件属性、链接数、文件名、文件大小等。</li><li>sort 能够处理独立的字段，在数据库术语中，我们可以指定一个或多个关键字段作为排序的关键值。在上面的例子中，指定了 n 和 r 选项进行数值的逆序排序，并指定 -k 5 让 sort 程序使用第 5 个字段作为排序的关键值。</li><li>k 这个参数选项非常有趣，并且有很多特性，但是首先我们需要了解 sort 是如何定义字段的。让我们考虑一个非常简单的文本文件，它只有一行，并且该行只包含了该作者的名字。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">William Shotts</span><br></pre></td></tr></table></figure></li><li>默认情况下，sort 程序会把该行看作有两个字段。第一个字段包含 William 字符串，第二个字段则是 Shotts 。这意味着空白字符 (空格和制表符) 用作字段之间的界定符，并且在排序时，这些界定符是包括在字段中的。</li><li>重新回到前面的 ls 例子，我们可以看到 ls 的输出行包含 8 个字段，并且第五个字段指的是文件大小。</li></ul><ol start="5"><li>案例三</li></ol><ul><li>让我们考虑用下面的文件。该文件包含从 2006 年 ~ 2008 年三款流行的 Linux 发行版的发行历史。文件每行都有 3 个字段：发行版本、版本号和 MM&#x2F;DD&#x2F;YYYY 格式的发行日期。使用文本编辑器 Vim , 输入此数据并将其保存为 distros.txt 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SUSE        10.2        12/07/2006</span><br><span class="line">Fedora      10          11/25/2008</span><br><span class="line">SUSE        11.0        06/19/2008</span><br><span class="line">Ubuntu      8.04        04/24/2008</span><br><span class="line">Fedora      8           11/08/2007</span><br><span class="line">SUSE        10.3        10/04/2007</span><br><span class="line">Ubuntu      6.10        10/26/2006</span><br><span class="line">Fedora      7           05/31/2007</span><br><span class="line">Ubuntu      7.10        10/18/2007</span><br><span class="line">Ubuntu      7.04        04/19/2007</span><br><span class="line">SUSE        10.1        05/11/2006</span><br><span class="line">Fedora      6           10/24/2006</span><br><span class="line">Fedora      9           05/13/2008</span><br><span class="line">Ubuntu      6.06        06/01/2006</span><br><span class="line">Ubuntu      8.10        10/30/2008</span><br><span class="line">Fedora      5           03/20/2006</span><br></pre></td></tr></table></figure></li><li>接下来，我们试着对该文件进行排序并观察其输出结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> distros.txt</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">Fedora503/20/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Ubuntu8.1010/30/2008</span><br></pre></td></tr></table></figure></li><li>Fedora 的版本号排序时却出现了问题。因为字符集中，字符 1 是在字符 5 前面的，所以导致版本 10 位于第一行而版本 9 却在最后。</li><li>为了解决这个问题，我们必须依据多个键值进行排序。首先我们对第一个字段进行字母排序，然后再对第二个点进行数值排序。</li><li>sort 支持 -k 选项的多个实例，所以可以指定多个排序键值。事实上，一个键值可能是一个字段范围，如果没有指定任何范围，sort 会使用一个键值，该键值始于指定的字段，一直扩展到行尾。</li><li>如下便是采用多键值进行排序的语法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> --key=1,1 --key=2n distros.txt</span><br><span class="line">Fedora503/20/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Ubuntu8.1010/30/2008</span><br></pre></td></tr></table></figure></li><li>虽然为了清晰，我们使用了选项的长格式，但是 -k1、-k 2n 格式是等价的。</li><li>在第一个 key 选项的实例中，指定了一个字段范围。因为我们只想对第一个字段排序，所以指定了 1，1 ，它意味着始于并且结束与第一个字段。在第二个实例中，我们指定了 2n ，表示第二个字段是排序的键值，并且按照数值排序。</li><li>一个选项的字母可能包含在一个键值说明符的末尾，用来指定排序的种类。这些选项字母与 sort 命令的全局选项一样：b (忽略开头空白字符) 、n (数值排序) 、r (逆序排序) 等。</li><li>以上列表的第三个字段包含的日期形式并不利于排序。在计算机中，日期通常以 YYYY-MM-DD 的形式存储，以方便按时间顺序排序，但该文本中的时间则是以美国形式 MM&#x2F;DD&#x2F;YYYY 存储。</li></ul><ol start="6"><li>案例四</li></ol><ul><li>幸好 sort 提供了一种解决方法。sort 的 key 选项允许在字段中指定偏移，所以我们可以在字段内定义键值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">Ubuntu8.1010/30/2008</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">Fedora503/20/2006</span><br></pre></td></tr></table></figure></li><li>通过指定 -k 3.7 ，我们告诉 sort 从第三个字段的第 7 个字符开始排序，也就是从年份开始排序。同样，指定 -k 3.1 和 -k 3.4 选项以区分日其中的月和日，另外我们利用 n、r 选项进行逆序数值排序。同时添加的 b 选项用来删除日期字段中开头的空格 (行与行之间的空格字符数量不同，因此会影响排序结果) 。</li></ul><ol start="7"><li>案例五</li></ol><ul><li>有些文件并不是使用制表符或空格符作为字段定界符，例如这个 &#x2F;etc&#x2F;passwd 文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/bin/sh</span><br><span class="line">man:x:6:12:man:/var/cache/man:/bin/sh</span><br><span class="line">lp:x:7:7:lp:var/spool/lpd:/bin/sh</span><br><span class="line">mail:x:8:8::mail:var/mail:bin/sh</span><br><span class="line">news:x:9:9:news:var/spool/news:bin/sh</span><br></pre></td></tr></table></figure></li><li>该文件的字段之间以冒号 : 作为分界符，那么该如何利用关键字段对此文件进行排序呢？sort 提供了 -t 选项定义字段分隔符，根据 passwd 文件的第 7 个字段内容进行排序 (用户默认的 shell 环境) ，如下面命令行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -t <span class="string">&#x27;:&#x27;</span> -k 7 /etc/passwd | <span class="built_in">head</span></span><br><span class="line">me:x:1001:1001:Myself,,,:/home/me:/bin/bash</span><br><span class="line">root:x:0:0:root:/root:/root:bin/bash</span><br><span class="line">dhcp:x:101:102::/nonexistent:/bin/bash</span><br><span class="line">gdm:x:106:114:Gnome Display Manager:var/lib/gdm:bin/false</span><br><span class="line">hplip:x:104:7:HPLIP system user,,,:/var/run/hplip:/bin/false</span><br><span class="line">klog:x:103:104::/home/klog:bin/false</span><br><span class="line">messagebus:x:108:119::/var/run/dbus:/bin/false</span><br><span class="line">polkituser:x:110:122:PolicyKit,,,:/var/run/PolicyKit:/bin/false</span><br><span class="line">pulse:x:107:116:PulseAudio daemon,,,:/var/run/pulse:/bin/false</span><br></pre></td></tr></table></figure></li><li>指定冒号字符作为字段分隔符，便实现了依据第 7 个字段进行排序的目的。</li></ul><h3 id="uniq-停止或省略重复的行"><a href="#uniq-停止或省略重复的行" class="headerlink" title="uniq - 停止或省略重复的行"></a>uniq - 停止或省略重复的行</h3><ol><li>基本介绍</li></ol><ul><li>与 sort 相比，uniq 算是一个轻量级的命令。uniq 执行的是一个看似简单的任务，给定一个已排好序的文件 (包括标准输入) 后，uniq 会删除任何重复的行并将结果输出到标准输出中。</li><li>uniq 通常与 sort 结合使用以删除 sort 输出内容中重复的行。</li><li>创建一个文本文件以验证此特性。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo,txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></li><li>此刻，如果运行 uniq，文件内容并没有很大改动，重复的行也并没有被删除。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">uniq</span> foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></li><li>uniq 只有对已经排好序的文本才有用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> foo.txt | <span class="built_in">uniq</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></li><li>这是因为 uniq 只能移除相邻的重复行。</li></ul><ol start="2"><li>常见的 uniq 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">输出重复行列表，并且在重复行前面加上其出现的次数</td></tr><tr><td align="center">-d</td><td align="center">只输出重复行，而不包括单独行</td></tr><tr><td align="center">-fn</td><td align="center">忽略每行前 n 个字段。字段之间以空格分开，这与 sort 类似，但与 sort 不同的是，uniq 没有提供参数设置可选择的字段分隔符</td></tr><tr><td align="center">-i</td><td align="center">行与行之间比较是忽略大小写</td></tr><tr><td align="center">-sn</td><td align="center">跳过 (忽略) 每行的前 n 个字符</td></tr><tr><td align="center">-u</td><td align="center">仅输出不重复的行，该选项是默认的</td></tr></tbody></table><ol start="3"><li>uniq 补充说明</li></ol><ul><li>使用 uniq 的 -c 选项，可输出文本中重复行的数量，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> foo.txt | <span class="built_in">uniq</span> -c</span><br><span class="line">   2 a</span><br><span class="line">   2 b</span><br><span class="line">   2 c</span><br></pre></td></tr></table></figure></li></ul><h2 id="切片和切块"><a href="#切片和切块" class="headerlink" title="切片和切块"></a>切片和切块</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>下面讨论的 3 个命令，他们的作用是剥离文本文件的列，并将它们以期待的方式重组。</li></ol><h3 id="cut-删除文本行中的部分内容"><a href="#cut-删除文本行中的部分内容" class="headerlink" title="cut - 删除文本行中的部分内容"></a>cut - 删除文本行中的部分内容</h3><ol><li>cut 基本介绍</li></ol><ul><li>cut 命令用于从文本行中提取一段文字并将其输出至标准输出。它可以接受多个文件和标准输入作为输入参数。</li></ul><ol start="2"><li>cut 选择选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-c char_list</td><td align="center">从文本行中提取 char_list 定义的部分内容。此列表可能会包含一个或更多冒号分开的数值范围</td></tr><tr><td align="center">-f field_list</td><td align="center">从文本行中提取 field_list 定义的一个或多个字段。该列表可能会包含由冒号分隔的一个、多个字段或字段范围</td></tr><tr><td align="center">-d delim_char</td><td align="center">指定 -f 选项后，使用 delim_char 作为字段的分界符。默认时，字段必须以单个 Tab 制表符隔开</td></tr><tr><td align="center">--complement</td><td align="center">从文本中提取整行，除了那些由 -c 和&#x2F;或 -f 指定的部分</td></tr></tbody></table><ol start="3"><li>案例一</li></ol><ul><li>正如大家所看到的，cut 提取文本的方式非常不灵活。cut 适合从其他命令的输出结果中提取文本内容，而不是直接从输入文本中提取。</li><li>我们可以判断下面的 distros.txt 文件是否达到了 cut 的提取要求，利用 cat 的 -A 选项，可以检查该文件是否用了 Tab 作为字段的分隔符的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -A distros.txt</span><br><span class="line">SUSE^I10.2^I12/07/2006$</span><br><span class="line">Fedora^I10^I11/25/2008$</span><br><span class="line">SUSE^I11.0^I06/19/2008$</span><br><span class="line">Ubuntu^I8.04^I04/24/2008$</span><br><span class="line">Fedora^I8^I11/08/2007$</span><br><span class="line">SUSE^I10.3^I10/04/2007$</span><br><span class="line">Ubuntu^I6.10^I10/26/2006$</span><br><span class="line">Fedora^I7^I05/31/2007$</span><br><span class="line">Ubuntu^I7.10^I10/18/2007$</span><br><span class="line">Ubuntu^I7.04^I04/19/2007$</span><br><span class="line">SUSE^I10.1^I05/11/2006$</span><br><span class="line">Fedora^I6^I^I10/24/2006$</span><br><span class="line">Fedora^I9^I^I05/13/2008$</span><br><span class="line">Ubuntu^I6.06^I06/01/2006$</span><br><span class="line">Ubuntu^I8.10^I10/30/2008$</span><br><span class="line">Fedora^I5^I03/20/2006$</span><br></pre></td></tr></table></figure></li><li>鉴于文件使用的是制表符而不是空格，所以可以使用 -f 选项提取字段内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros.txt</span><br><span class="line">12/07/2006</span><br><span class="line">11/25/2008</span><br><span class="line">06/19/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/04/2007</span><br><span class="line">10/26/2006</span><br><span class="line">05/31/2007</span><br><span class="line">10/18/2007</span><br><span class="line">04/19/2007</span><br><span class="line">05/11/2006</span><br><span class="line">10/24/2006</span><br><span class="line">05/13/2008</span><br><span class="line">06/01/2006</span><br><span class="line">10/30/2008</span><br><span class="line">03/20/2006</span><br></pre></td></tr></table></figure></li><li>由于 distros 文件是以制表符作为分界符的，所以用 cut 提取字段而不是字符在合适不过了。这是因为用 Tab 作为分界符的文件，一般每行不会包含相同的字符数，所以计算字符在行内的位置很苦难或是根本不可能。</li><li>然而，在上例中，我们已经提取好了包含相同长度数据的字段，从而可以拿此字段作为字符提取实例。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros.txt | <span class="built_in">cut</span> -c 7-10</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br></pre></td></tr></table></figure></li><li>对输出结果再进行一次 cut 操作，便可以将字段中与年份相对应的第 7 至第 10 个字符提取出来，命令行中的符号 7-10 指范围。</li><li>cut 的 man 手册页包含了关于范围指定的完整描述。</li></ul><ol start="4"><li>案例二</li></ol><ul><li>当处理字段时，我们可以指定非 Tab 字符作为分界符，如下所示例子演示的是从 &#x2F;etc&#x2F;passwd 文件中提取了每一行的第一个字段。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -d <span class="string">&quot;:&quot;</span> -f 1 /etc/passwd | <span class="built_in">head</span></span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">games</span><br><span class="line">man</span><br><span class="line">lp</span><br><span class="line">mail</span><br><span class="line">news</span><br></pre></td></tr></table></figure></li><li>此处我们还使用了 -d 选项指定冒号作为字段的分界符。</li></ul><h3 id="paste-合并文本行"><a href="#paste-合并文本行" class="headerlink" title="paste - 合并文本行"></a>paste - 合并文本行</h3><ol><li>paste 基本介绍</li></ol><ul><li>paste 命令是 cut 的逆操作，它不是文本文件中提取列信息，而是向文件中增加一个或更多文本列。</li><li>paste 命令读取多个文件并将每个文件中提取的字段结合为一个整体的标准输出流。</li><li>与 cut 类似，paste 也可以接受多个文件输入参数和标准输入。</li></ul><ol start="2"><li>paste 案例</li></ol><ul><li>至于 paste 是如何运行的，我们可以通过下面的例子进行了解。如下所示，我们描述了一个使用 paste 对 distros.txt 文件按照发行版本的时间顺序而排序。</li><li>首先，我们用前面所学的 sort 命令，得到一个依据日期进行排序的 distros 列表，并将输出结果存储于文件 distros-by-date.txt 中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt &gt; distros-by-date.txt</span><br></pre></td></tr></table></figure></li><li>接下来，我们使用 cut 提取文件中前两个字段 (distros 的名字和发行版本) ，并将结果存于文件 distros-versions.txt 中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ linux <span class="built_in">cut</span> -f 1,2 distros-by-date.txt &gt; distros-versions.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-versions.txt</span><br><span class="line">Fedora10</span><br><span class="line">Ubuntu8.10</span><br><span class="line">SUSE11.0</span><br><span class="line">Fedora9</span><br><span class="line">Ubuntu8.04</span><br><span class="line">Fedora8</span><br><span class="line">Ubuntu7.10</span><br><span class="line">SUSE10.3</span><br><span class="line">Fedora7</span><br><span class="line">Ubuntu7.04</span><br></pre></td></tr></table></figure></li><li>最后一步准备工作就是提取发行版本日期，并将结果存于 distros-date.txt 文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros-by-date.txt &gt; distros-dates.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-dates.txt</span><br><span class="line">11/25/2008</span><br><span class="line">10/30/2008</span><br><span class="line">06/19/2008</span><br><span class="line">05/13/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/18/2007</span><br><span class="line">10/04/2007</span><br><span class="line">05/31/2007</span><br><span class="line">04/19/2007</span><br></pre></td></tr></table></figure></li><li>作为例子的最后一步，我们使用 paste 将提取的日期这一列内容置于 distro 中操作系统名称和发行版本号这两列之前，于是便生成了一个按时间排列的发行版本列表。</li><li>这一过程只是简单地使用 paste 命令来将各参数按指定顺序进行排列。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-versions.txt</span><br><span class="line">11/25/2008  Fedora10</span><br><span class="line">10/30/2008  Ubuntu8.10</span><br><span class="line">06/19/2008  SUSE        11.0</span><br><span class="line">05/13/2008  Fedora9</span><br><span class="line">04/24/2008  Ubuntu8.04</span><br><span class="line">11/08/2007  Fedora8</span><br><span class="line">10/18/2007  Ubuntu7.10</span><br><span class="line">10/04/2007  SUSE        10.3</span><br><span class="line">05/31/2007  Fedora7</span><br><span class="line">04/19/2007  Ubuntu7.04</span><br></pre></td></tr></table></figure></li></ul><h2 id="join-连接两文件中具有相同字段的行"><a href="#join-连接两文件中具有相同字段的行" class="headerlink" title="join - 连接两文件中具有相同字段的行"></a>join - 连接两文件中具有相同字段的行</h2><ol><li>join 基本介绍</li></ol><ul><li>从某种程度上来说， join 与 paste 类似，因为它也是向文件增加列信息，只是实现方式有些不同。</li><li>join 操作符通常与关联数据库联系在一起，它在关联数据库中把共享关键字段多个表格的数据组合成一个期望结果。</li><li>join 是一个基于共享关键字段将多个文件的数据拼接在一起的操作。</li></ul><ol start="2"><li>join 案例</li></ol><ul><li>作为演示，我们需要创建两个具有共有字段的文件，于是便可以使用 distros-by-date.txt 文件。 </li><li>利用 distros-by-date.txt 文件，可以生成两个附属文件，其中一个文件包含的内容是发行时间和发行版本名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 1,1 distros-by-date.txt &gt; distros-names.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-names.txt &gt; distros-key-names.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-key-names.txt</span><br><span class="line">11/25/2008  Fedora</span><br><span class="line">10/30/2008  Ubuntu</span><br><span class="line">06/19/2008  SUSE</span><br><span class="line">05/13/2008  Fedora</span><br><span class="line">04/24/2008  Ubuntu</span><br><span class="line">11/08/2007  Fedora</span><br><span class="line">10/18/2007  Ubuntu</span><br><span class="line">10/04/2007  SUSE</span><br><span class="line">05/31/2007  Fedora</span><br><span class="line">04/19/2007  Ubuntu</span><br></pre></td></tr></table></figure></li><li>第二个文件的内容则包含发行时间和发行版本号。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 2,2 distros-by-date.txt &gt; distros-vernums.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-vernums.txt &gt; distros-key-vernums.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-key-vernums.txt</span><br><span class="line">11/25/2008  10</span><br><span class="line">10/30/2008  8.10</span><br><span class="line">06/19/2008  11.0</span><br><span class="line">05/13/2008  9</span><br><span class="line">04/24/2008  8.04</span><br><span class="line">11/08/2007  8</span><br><span class="line">10/18/2007  7.10</span><br><span class="line">10/04/2007  10.3</span><br><span class="line">05/31/2007  7</span><br><span class="line">04/19/2007  7.04</span><br></pre></td></tr></table></figure></li><li>此刻，两个具有公共字段 (发行时间作为共有字段) 的文件便准备妥当。此处需要重点强调的是，文件必须事先依据共有关键字段排好序，因为只有这样 join 才能正常工作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">join</span> distros-key-names.txt distros-key-vernums.txt | <span class="built_in">head</span></span><br><span class="line">11/25/2008  Fedora10</span><br><span class="line">10/30/2008  Ubuntu8.10</span><br><span class="line">06/19/2008  SUSE11.0</span><br><span class="line">05/13/2008  Fedora9</span><br><span class="line">04/24/2008  Ubuntu8.04</span><br><span class="line">11/08/2007  Fedora8</span><br><span class="line">10/18/2007  Ubuntu7.10</span><br><span class="line">10/04/2007  SUSE10.3</span><br><span class="line">05/31/2007  Fedora7</span><br><span class="line">04/19/2007  Ubuntu7.04</span><br></pre></td></tr></table></figure></li><li>同样请注意，默认情况下，join 会把空格当作输入字段的分界符，而以单个空格作为输出字段的分界符，当然我们也可以通过指定参数选项改变这一默认属性。我们可以查看 join 的 man 手册页获取更详细信息。</li></ul><h2 id="文本比较"><a href="#文本比较" class="headerlink" title="文本比较"></a>文本比较</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>比较文本文件的版本号通常很有用，尤其对系统管理者以及软件开发者而言。</li><li>例如，一个系统的管理者可能需要将已存在的配置文件与原先的配置文件相比较，以检查出系统的漏洞，与此类似，程序员也会经常需要查看程序代码所经历的变化。</li></ol><h3 id="comm-逐行比较两个已排序文件"><a href="#comm-逐行比较两个已排序文件" class="headerlink" title="comm - 逐行比较两个已排序文件"></a>comm - 逐行比较两个已排序文件</h3><ol><li>comm 基本介绍</li></ol><ul><li>comm 命令一般用于文本文件之间的比较，显示两文件中相异的行以及相同的行。</li></ul><ol start="2"><li>comm 案例</li></ol><ul><li>作为演示，我们首先利用 cat 生成两个近乎一样的文本文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; file1.txt</span><br><span class="line">q</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; file2.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure></li><li>接下来，便利用 comm 比较两个文件的差异。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">comm</span> file1.txt file2.txt</span><br><span class="line">a</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br><span class="line">    e</span><br></pre></td></tr></table></figure></li><li>从以上结果可以看出，comm 输出三列的内容。第一列显示的是第一个文件中独有的行，第二列显示的是第二个参数文件中独有的行，第三列显示的则是两个文件所共有的行。</li><li>comm 还支持 -n 形式的参数选项，此处的 n 可以是 1，2 或者3 ，使用时，它表示省略第 n 列的内容。</li><li>例如，如果只想显示两个文件的共同行，便可以省略第 1 列和第 2 列的内容，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">comm</span> -12 file1.txt file2.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure></li></ul><h3 id="diff-逐行比较文件"><a href="#diff-逐行比较文件" class="headerlink" title="diff - 逐行比较文件"></a>diff - 逐行比较文件</h3><ol><li>diff 基本介绍</li></ol><ul><li>与 comm 命令类似， diff 用于检测文件之间的不同。然而，diff 比 comm 更复杂，它支持多种输出形式，并且具备一次性处理大文件集的能力。</li><li>diff 通常被软件开发者用于检查不同版本的源代码之间的差异，因为它能够递归检查源代码目录 (通常成为源树) 。</li><li>diff 的常见用法就是创建 diff 文件和补丁，它们可以为诸如 patch 这样的命令所用，从而实现一个版本的文件更新为另一个版本。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff file1.txt file2.txt</span><br><span class="line">1d0</span><br><span class="line">&lt; a</span><br><span class="line">4a4</span><br><span class="line">&gt; e</span><br></pre></td></tr></table></figure></li><li>默认形式中，每一组改动的前面都有一个以 “范围 执行操作 范围” 形式 (range operation range) 表示的改变操作命令，该命令会告诉程序对第一个文件的某个位置进行某种改变，便可实现与第二个文件内容一致。</li></ul><ol start="2"><li>diff 改变命令</li></ol><table><thead><tr><th align="center">改变操作</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">rlar2</td><td align="center">将第二个文件中 r2 位置的行添加到第一个文件夹中的位置 r1 处。</td></tr><tr><td align="center">rlcr2</td><td align="center">用第二个文件 r2 处的行替代第一个文件 r1 处的行。</td></tr><tr><td align="center">rldr</td><td align="center">删除第一个文件 r1 处的行，并且删除的内容作为第二个文件 r2 行范围内容。</td></tr></tbody></table><ol start="3"><li>diff 案例一</li></ol><ul><li>此格式中，范围 range 一般是由冒号隔开的起始行和末尾行组成。虽然，此格式是默认的 (大多数情况下是为了兼容POSIX的同时向后兼容传统 UNIX 版本的 diff) ，但它并没有其他格式的应用广泛，上下文格式和统一格式才是比较普遍使用的格式。</li><li>上下文格式的输出结果如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -c file1.txt file2.txt</span><br><span class="line">*** file1.txt2021-01-14 09:53:35.000000000 +0800</span><br><span class="line">--- file2.txt2021-01-14 09:53:55.000000000 +0800</span><br><span class="line">***************</span><br><span class="line">*** 1,4 ****</span><br><span class="line">- a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">--- 1,4 ----</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">+ e</span><br></pre></td></tr></table></figure></li><li>该结果以两个文件的名字和时间信息开头，第一个文件用星号表示，第二个文件用破折号表示。</li><li>输出结果的其余部分出现的星号和破折号则分别表示各自所代表的的文件。其他的内容便是两个文件之间的差异组，包括文本的默认行号。</li><li>第一组差异，以 *** 1，4 **** 开头，表示第一个文件中的第1行至第 4 行；第二组便以 — 1，4 — 开头，表示第二个文件的第 1 行至第 4 行。</li></ul><ol start="4"><li>diff 上下文格式差异标识符</li></ol><table><thead><tr><th align="center">标识符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">(无)</td><td align="center">该行表示上下文文本。表示两个文件共有的行</td></tr><tr><td align="center">-</td><td align="center">缺少的行。指此行内容只在第一个文件中出现，第二个文件中则没有</td></tr><tr><td align="center">+</td><td align="center">多余的行。此行内容只有第二个文件才有，第一个文件则没有</td></tr><tr><td align="center">!</td><td align="center">改变的行。两个版本的行内容都会显示出来，每一个都各自出现在差异组中相应的部分</td></tr></tbody></table><ol start="5"><li>diff 案例二</li></ol><ul><li>统一格式与上下文格式相似但是更简明，此格式用 -u 选项指定。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -u file1.txt file2.txt</span><br><span class="line">--- file1.txt2021-01-14 09:53:35.000000000 +0800</span><br><span class="line">+++ file2.txt2021-01-14 09:53:55.000000000 +0800</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line">-a</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">+e</span><br></pre></td></tr></table></figure></li><li>上下文格式和统一格式之间最显著的区别就是，统一格式下没有重复的文本行，这使得统一格式的输出结果比上下文格式更精简。</li><li>上例中，也输出了上下文格式中出现的文件时间信息，并且后面紧跟着 @@ -1,4 +1,4 @@ 字符串，它表示差异组描述的两个文件各自的行范围。</li><li>此字符串之后便是行本身，其中包含默认的三行文本内容。</li></ul><ol start="6"><li>diff 统一格式的差异标识符</li></ol><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">(无)</td><td align="center">两个文件共有的行</td></tr><tr><td align="center">-</td><td align="center">相对于第二个文件而言，第一个文件中没有的行</td></tr><tr><td align="center">+</td><td align="center">第一个文件多余的行</td></tr></tbody></table><h3 id="patch-对原文件进行-diff-操作"><a href="#patch-对原文件进行-diff-操作" class="headerlink" title="patch - 对原文件进行 diff 操作"></a>patch - 对原文件进行 diff 操作</h3><ol><li>patch 基本介绍</li></ol><ul><li>patch 命令用于更新文本文件。它利用 diff 命令的输出结果将较旧版本的文本升级成较新版本。</li><li>下面看一个众所周知的例子：Linux 内核是由一个很大的、阻止松散的志愿者团队开发的，其源代码处于持续不断更新中。Linux 内核包含几百万行代码，所以相比而言，某位开发成员每次所做的修改是如此微不足道。</li><li>因此，对于每位开发者来说，每对代码改动一次就得向其他开发者发送整个内核源代码树多么不切实际。</li><li>事实上，一般只要发送 diff 补丁文件即可。 diff 补丁的内容是内核从比较旧版本转变为较新版本所经历的改变，接收者然后使用 patch 命令将这些改变应用于自身的源代码树。</li><li>diff&#x2F;patch 有两个重要的优点。<ul><li>与源代码树的大小相比，diff 文件很小。</li><li>diff 文件非常简洁地描述了文件所做的改变，便于补丁的接收者快速对其进行评价。</li></ul></li><li>当然，diff&#x2F;patch 不仅仅局限于源代码，它适用于任何文本文件。因此，它同样适用于配置文件以及其他文本文件。</li><li>生成供 patch 使用的 diff 文件，GNU 文件系统建议采用如下方式使用 diff 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -Naur old_file new_file &gt; diff_file</span><br></pre></td></tr></table></figure></li><li>此处 old_file 和 new_file 既可以是单独文件也可以是包含文件的目录，使用 -r 参数选项则是为了进行递归目录数搜索。</li><li>一旦创建了 diff 文件，便可以将其用于修补原文件 old_file ，从而升级为新文件 new_file 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch &lt; diff_file</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>patch 案例</li></ol><ul><li>以前面的测试文件为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -Naur file1.txt file2.txt &gt; patchfile.txt</span><br><span class="line">[me@linuxbox ~]$ patch &lt; patchfile.txt</span><br><span class="line">patching file file1.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure></li><li>本例中，我们创建了一个叫做 patch.file 的 diff 文件，然后使用 patch 命令进行修补。</li><li>请注意该命令中，并没有给 patch 命令指定目标文件，因为 diff 文件 (统一形式) 已经在页面中包含了文件名，可以发现修补后，file1.txt 便与 file2.txt 一致了。</li><li>patch 有很多参数选项，而且有很多额外的工具命令可以分析并编辑这些补丁文件。</li></ul><h2 id="非交互式文本编辑"><a href="#非交互式文本编辑" class="headerlink" title="非交互式文本编辑"></a>非交互式文本编辑</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>之前所描述的文本编辑大多数是交互式，也就是说只要手动移动鼠标然后输入需要进行的改变，然而，也可以用非交互的方式进行文本编辑。例如，可以用一个简单的命令一次性更改多个文件。</li></ol><h3 id="tr-替换或删除字符"><a href="#tr-替换或删除字符" class="headerlink" title="tr - 替换或删除字符"></a>tr - 替换或删除字符</h3><ol><li>tr 基本介绍</li></ol><ul><li>tr 是替换字符命令，可以将其看作一种基于字符的查找和替换操作。所谓替换，实际是指将字符从一个字母更换为其他字母。</li><li>例如，将小写字母转变为大写字母。如下便是一个利用 tr 进行大小写字母替换的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">echo</span> <span class="string">&quot;lowercase letters&quot;</span> | <span class="built_in">tr</span> a-z A-Z</span><br><span class="line">LOWERCASE LETTERS</span><br></pre></td></tr></table></figure></li><li>该输出结果表明，tr 可对标准输入进行操作并且将结果以标准形式输出。 </li><li>tr 有两个参数：等待转换的字符集和与之相对应的替换字符集。字符集的表示方法可以是下面三种方法中任选一种。<ul><li>枚举列表：例如，ABCDEFGHIJKLMNOPQRSTUVXYZ 。</li><li>字符范围：例如，A-Z 。请注意，这种方法有时会与其他命令一样受限于同一个问题 (由于不同系统的排序顺序) ，因此使用时要小心。</li><li>POSIX字符类：例如，[:upper:] 。</li></ul></li><li>多数情况下，这两个字符集应该是同等长度：然而，第一个字符集比第二个字符长也是有可能的，如下便是一个将多个字符替换为单个字符的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">echo</span> <span class="string">&quot;lowercase letters&quot;</span> | <span class="built_in">tr</span> [:lower:] A</span><br><span class="line">AAAAAAAAA AAAAAAA</span><br></pre></td></tr></table></figure></li><li>除了替换，tr 还可以直接从输入流中删除字符。</li><li>本章前篇，讨论了将 MS-DOS 类型的文本文件向 UNIX 类型转换的问题。要进行这样的转换，需要移除每行末尾的回车符，如此便可以用 tr 命令解决，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; dos_file &gt; unix_file</span><br></pre></td></tr></table></figure></li><li>这里的 dos_file 是待转换的文件，而 unix_file 则是转换的结果文件。此命令形式使用了转义字符 \r 代替回车符。</li><li>如若想了解 tr 支持的所有转义符号和字符类，请查看 tr 的帮助手册。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">tr</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li><li>tr 还有另外一个奇妙的用法。使用 -s 选项，tr 可以挤兑 (删除) 重复出现的字符，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | <span class="built_in">tr</span> -s ab</span><br><span class="line">abccc</span><br></pre></td></tr></table></figure></li><li>本例字符串中含有重复字符，通过给 tr 指定 ab 字符集，便消除了该字符集重复的 a 和 b 字母，而字母 c 并没有改变，因为 tr 设定的字符集中并没有包含 c 。请注意重复的字符必须是毗邻的，否则该挤兑操作将不起作用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">echo</span> <span class="string">&quot;abcabcabc&quot;</span> | <span class="built_in">tr</span> -s ab</span><br><span class="line">abcabcabc</span><br></pre></td></tr></table></figure></li></ul><h3 id="sed-用于文本过滤和转换的流编辑器"><a href="#sed-用于文本过滤和转换的流编辑器" class="headerlink" title="sed - 用于文本过滤和转换的流编辑器"></a>sed - 用于文本过滤和转换的流编辑器</h3><ol><li>sed 基本介绍</li></ol><ul><li>sed 是 stream editor (流式编辑器) 的缩写，他可以对文本流、指定文件集或标准输出集进行文本编辑。</li><li>sed 功能非常强大，并且从某种程度上来说，他还是一个比较复杂的命令。</li><li>sed 的用法，总的来说，首先给定 sed 某个简单的编辑命令 (在文本行中) 或是包含多个命令的脚本文件名，然后 sed 便对文本流的内容执行给定的编辑命令。</li><li>下面是一个非常简单的 sed 应用实例。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;front&#x27;</span> | sed <span class="string">&#x27;s/front/back/&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure></li><li>该例先利用 echo 生成了只包含一个单词的文本流，然后将该文本流交给 sed 处理，而 sed 则对文本流执行 s&#x2F;front&#x2F;back&#x2F; 指令，最后输出 back 作为运行结果。</li><li>所以可以认为，本例中的 sed 与 vi 中的替代 (查看与替换) 命令相似。</li><li>sed 中的命令总是以单个字母开头。上例中，替换命令便是由字母 s 代替，其后紧跟替换字符，替换字符由作为分界符的斜线字符分开。</li><li>分界符的选择是随意的，习惯上一般使用斜线，但是 sed 支持任意字符作为分界符。</li><li>sed 会默认紧跟在 sed 的命令之后的字符作为分界符，下面的命令行能得到相同的效果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;front&#x27;</span> | sed <span class="string">&#x27;s_front_back_&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure></li><li>由于下划线是紧跟在命令字符 s 之后的，所以它便是分界符。由此可见，这种自动设定分界符的能力增强了命令行的可读性。</li><li>sed 中的多数命令允许在其添加一个地址，该地址用来指定输入流的哪一行被编辑。 </li><li>如果该地址省略了，便会默认对输入流的每一行执行该编辑命令。 </li><li>最简单的地址形式就是一个行号。例如，在上例中增加一个 1 ，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;front&#x27;</span> | sed <span class="string">&#x27;1s/front/back/&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure></li><li>增加的 1 表示此替换操作只对输入流的第一行起作用。当然也可以指定其他行号，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;front&#x27;</span> | sed <span class="string">&#x27;2s/front/back/&#x27;</span></span><br><span class="line">front</span><br></pre></td></tr></table></figure></li><li>结果显示此替换明并未执行，这是因为该输入流中并没有第二行。地址可以有多种方式表达。</li></ul><ol start="2"><li>sed 的地址表达法</li></ol><table><thead><tr><th align="center">地址</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">n 是正整数表示行号</td></tr><tr><td align="center">$</td><td align="center">最后一行</td></tr><tr><td align="center">&#x2F;regexp&#x2F;</td><td align="center">用 POSIX 基本正则表达式描述的行。请注意，这里的正则表达式用的是斜线作为分界符，当然，也可以自己选择分界符，只要用 \cregexpc 选项指定即可，这里用 c 就是用于取代斜杠的分界符</td></tr><tr><td align="center">addr1, addr2</td><td align="center">行范围，表示从 addr1 至 addr2 的所有行。地址可以是上面所述形式的任何一种</td></tr><tr><td align="center">first-step</td><td align="center">代表行号从 first 行开始，以 step 为间隔的所有行。例如，1-2 是指所有奇数行，而 5-5 是指第 5 行和以及随后的所有是 5 的倍数的行</td></tr><tr><td align="center">addr1,+n</td><td align="center">addrc1 行及其之后的 n 行</td></tr><tr><td align="center">addr!</td><td align="center">出了 addrc 行之外的所有行，addr 可以用上面的任何一种形式表达</td></tr></tbody></table><ol start="3"><li>sed 案例一</li></ol><ul><li>接下来，我们会用本章前面所使用的  distros.txt 文件演示多种不同形式的地址表达。首先，用行号范围的表达式如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;1,5p&#x27;</span> distros.txt</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Fedora811/08/2007</span><br></pre></td></tr></table></figure></li><li>此例显示了 distros.txt 文件中第1行到第5行的内容，利用 p 命令输出指定匹配行的内容，从而完成上述操作。然而，想要得到正确结果，就必须添加选项 -n (不会自动打印选项) 以防 sed 会默认输出每一行的内容。</li><li>下面尝试使用正则表达式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/p&#x27;</span> distros.txt</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">SUSE10.105/11/2006</span><br></pre></td></tr></table></figure></li><li>此处用的是以斜杠隔开的正则表达式 &#x2F;SUSE&#x2F; ，查找包含 SUSE 字符串的文本行，该用法与 grep 的用法类似。</li><li>最后尝试在地址前添加表示否定意义的感叹号 ! ，用法如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/!p&#x27;</span> distros.txt</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">Ubuntu8.1010/30/2008</span><br><span class="line">Fedora503/20/2006</span><br></pre></td></tr></table></figure></li><li>这样我们得到了理想输出的结果，即除了那些与正则表达式匹配的行，其他所有行都显示出来了。</li><li>到目前为止，我们已经介绍了 sed 的两个编辑命令 - s 和 p 。</li></ul><ol start="4"><li>sed 基本编辑指令</li></ol><table><thead><tr><th align="center">命令</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">输出当前行号</td></tr><tr><td align="center">a</td><td align="center">在当前行后附加文本</td></tr><tr><td align="center">d</td><td align="center">删除当前行</td></tr><tr><td align="center">i</td><td align="center">在当前行前输入文本</td></tr><tr><td align="center">p</td><td align="center">打印当前行。默认情况下， sed 会输出每一行并且只编辑文件内那些匹配指定地址的行。当指定 -n 选项是，默认操作会被覆盖。</td></tr><tr><td align="center">q</td><td align="center">退出 sed 不再处理其他行，如果没有指定 -n 选项，就会输出当前行</td></tr><tr><td align="center">Q</td><td align="center">直接退出 sed 不再处理行</td></tr><tr><td align="center">s&#x2F;regex&#x2F;replacement</td><td align="center">将 regexp 的内容替换为 replacement 代表的内容。 replacement 可能会包含特殊字符 &amp; ，它代表的其实就是 regexp 所表示的内容。除此之外，replacement 也可能包含 \1 到 \9 的序列，他们代表的是 regexp 中相应位置的描述内容。跟在 replacement 后面的反斜杠，可以指定一个可选择的标志以修改 s 命令的行为。</td></tr><tr><td align="center">y&#x2F;set1&#x2F;set2</td><td align="center">将字符集 set1 转换为字符集 set2 。请注意，与 tr 不同， sed 要求这两个字符集等长。</td></tr></tbody></table><ol start="5"><li>sed 案例二</li></ol><ul><li>s 命令是目前为止使用最普遍的编辑命令。接下来，我们通过编辑 distros.txt 文件来演示其强大的功能的一小部分。</li><li>之前，讨论过 distros.txt 文件中的时间字段并不是以计算机友好的形式存储，因为此时间形式是 MM&#x2F;DDD&#x2F;YYYY ，YYYY-MM-DD 这样的形式会方便很多 (更容易排序) 。</li><li>但如果手动更改文件，不仅浪费时间而且容易出错，而 sed 可以一步完成这样的操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed <span class="string">&#x27;s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/&#x27;</span> distros.txt</span><br><span class="line">SUSE10.22006-12-07</span><br><span class="line">Fedora102008-11-25</span><br><span class="line">SUSE11.02008-06-19</span><br><span class="line">Ubuntu8.042008-04-24</span><br><span class="line">Fedora82007-11-08</span><br><span class="line">SUSE10.32007-10-04</span><br><span class="line">Ubuntu6.102006-10-26</span><br><span class="line">Fedora72007-05-31</span><br><span class="line">Ubuntu7.102007-10-18</span><br><span class="line">Ubuntu7.042007-04-19</span><br><span class="line">SUSE10.12006-05-11</span><br><span class="line">Fedora62006-10-24</span><br><span class="line">Fedora92008-05-13</span><br><span class="line">Ubuntu6.062006-06-01</span><br><span class="line">Ubuntu8.102008-10-30</span><br><span class="line">Fedora52006-03-20</span><br></pre></td></tr></table></figure></li><li>我们还是先来分析它各组成部分的含义。首先，sed 命令有其基本结构，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/regexp/replacement&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure></li><li>接下来我们需要理解将日期分隔开来的正则表达式。由于它是以 MM&#x2F;DD&#x2F;YYYY 的形式存在，并且出现在行末尾，是以使用如下的表达式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;2&#125;/[0-9]&#123;2&#125;/[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure></li><li>该表达式的匹配格式：两位数字、斜杠、两位数字、斜杠、4 位数字以及行尾标志。所以这代表了 regexp 表达式的形式，但是怎么处理 replacement 的表达式 ？</li><li>解决这一问题，我们必须引进正则表达式的一个新特性，该特性一般存在那些使用 BRE 的应用中。</li><li>此特性称为回参考，并且工作方式类似于此，即如果 replacement 中出现转义 \n 转义字符，并且这里的 n 是 1-9 之间的任意数字，那么此转义字符就是指前面正则表达式中与之相对应的子表达式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([0-9]&#123;2&#125;)/([0-9]&#123;2&#125;)/([0-9]&#123;4&#125;)$</span><br></pre></td></tr></table></figure></li><li>现在，我们便有了三个子表达式。第一个的内容是月份，第二个内容是具体的日，第三个则是之年份。于是便可用如下命令行构建替换字符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\3-\1-\2</span><br></pre></td></tr></table></figure></li><li>该表达式表示的书信如下：年份、斜杠、月份、斜杠和具体的日。</li><li>于是，整个命令行如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/([0-9]&#123;2&#125;)/([0-9]&#123;2&#125;)/([0-9]&#123;4&#125;)$/\3-\1-\2&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure></li><li>但是仍有两个遗留问题<ul><li>当 sed 试图编译 s 命令时，正则表达式中多余的斜杠会令 sed 混淆。</li><li>sed 默认情况下只接受基本正则表达式，所有正则表达式中的部分元字符会被当成文字字符。我们可以易用反斜杠来避免这些冒犯字符，从而一次性解决这两个问题。</li></ul></li><li>这样便大功告成了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>sed 案例三</li></ol><ul><li>s 命令的另外一个特点，就是替换字符串后面可以紧跟可选择标志符。其中最重要的标志符就是 g ，该标志告诉 sed 对每行的所有匹配项进行替换操作，而不是默认的只替换第一个匹配项。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;aaabbbccc&#x27;</span> | sed <span class="string">&#x27;s/b/B/&#x27;</span></span><br><span class="line">aaaBbbccc</span><br></pre></td></tr></table></figure></li><li>我们可以看到执行了替换操作，但只是对第一个字母 b 有效，剩下的字母并没有改变。通过增加 g 标志符，便可以对所有的 b 进行替换操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;aaabbbccc&#x27;</span> | sed <span class="string">&#x27;s/b/B/g&#x27;</span></span><br><span class="line">aaaBBBccc</span><br></pre></td></tr></table></figure></li><li>到目前为止，我们只使用了命令行方式向 sed 传送操作命令，其实也可以用 -f 选项建立更复杂的命令行脚本。</li><li>作为演示实例，我们运用 distros.txt 文件结合 sed 创建一个报告。该报告的构成有顶端标题、修改时间和大写字母组成的所有发行版本名。</li><li>进行这些操作之前，我们需要编写一个脚本文件所以启动文本编辑器并输入如下内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed script to produce Linux distributions report</span></span><br><span class="line"></span><br><span class="line">1 i\</span><br><span class="line">\</span><br><span class="line">Linux Distributions Report\</span><br><span class="line"></span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure></li><li>将此 sed 脚本保存为 distros.sed distros.txt，并且照如下方式运行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -f distros.sed distros.txt</span><br><span class="line"></span><br><span class="line">Linux Distributions Report</span><br><span class="line"></span><br><span class="line">SUSE10.22006-12-07</span><br><span class="line">FEDORA102008-11-25</span><br><span class="line">SUSE11.02008-06-19</span><br><span class="line">UBUNTU8.042008-04-24</span><br><span class="line">FEDORA82007-11-08</span><br><span class="line">SUSE10.32007-10-04</span><br><span class="line">UBUNTU6.102006-10-26</span><br><span class="line">FEDORA72007-05-31</span><br><span class="line">UBUNTU7.102007-10-18</span><br><span class="line">UBUNTU7.042007-04-19</span><br><span class="line">SUSE10.12006-05-11</span><br><span class="line">FEDORA62006-10-24</span><br><span class="line">FEDORA92008-05-13</span><br><span class="line">UBUNTU6.062006-06-01</span><br><span class="line">UBUNTU8.102008-10-30</span><br><span class="line">FEDORA52006-03-20</span><br></pre></td></tr></table></figure></li><li>让我们再次查看脚本，并且使用 cat 将行号都标注出来。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 <span class="comment"># sed script to produce Linux distributions report</span></span><br><span class="line">2</span><br><span class="line">3 1 i\</span><br><span class="line">4 \</span><br><span class="line">5 Linux Distributions Report\</span><br><span class="line">6</span><br><span class="line">7 s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure></li><li>第一行只是一个声明，与 Linux 系统中的许多配置文件和编程语言一样，生命一般都是以 # 符号开头。剩下的则是一些人类可理解的文本。</li><li>声明可以放于脚本文件的任何位置 (只要不在命令行中) ，并且对于任何一个需要验或是维护该脚本的人都很有用。 </li><li>第二行是空白行。与声明一样，空白行也是为了增加可读性。 </li><li>多数 sed 命令都支持行地址，这些行地址用于指定哪些输入行执行指定操作。行地址可以用简单的符号来描述，也可以用行号范围以及 $ 表示，$ 是一个表示文本最后一行的特殊符号。 </li><li>第 3 ~ 6 行包含的则是要插入文本中第一行的内容。i 命令后面紧跟转义回车符，转义回车符由反斜杠和回车组成，亦称为行继续符。 </li><li>此种先反斜杠后回车符的顺序，可以用于包括 shell 脚本在内的很多场合，可确保文本流中嵌入回车符但不会告诉编辑器 (在这个例子中) 已经到行末尾。 </li><li>i 命令、a 命令 (追加文本) 、以及 c 命令 (替换文本) 能作用于多个文件行，只要除了最后一行的每行都以行继续符结尾。 </li><li>该脚本文件的第 6 行确实是所输入文本的末尾行，并且标注 i 命令结尾的符号是一个简单的回车符而不再是行继续符。 </li><li>行继续符是由反斜杠后紧跟回车符组成，两者之间不容许有任何空格。 </li><li>第 7 行是查找和替换命令。由于该命令前并未指定地址，所以该命令将对输入流的每一行进行操作。 </li><li>第 8 行则实现小写字母向大写字母的转变。注意，与 tr 不同，sed 总的 y 命令并不支持字符范围 (例如 [a-z] ) ，也不支持 POSIX 字符类。同样，由于 y 命令前并没有指定地址，所以将对输入流的每一行执行操作。</li></ul><h3 id="aspell-交互式拼写检查工具"><a href="#aspell-交互式拼写检查工具" class="headerlink" title="aspell - 交互式拼写检查工具"></a>aspell - 交互式拼写检查工具</h3><ol><li>aspell 基本介绍</li></ol><ul><li>aspell 是交互式的拼写检查工具，aspell 命令继承的是早期的ispell 命令，并且多数情况下，可以直接去带 ispell 。</li><li>虽然 aspell 命令通常为那些需要进行拼写检查的程序所有，但它同样可以作为一个独立于命令行的工具发挥其效用。</li><li>aspell 可以智能地检查不同类型文本文件的错误，包括 HTML 文件、C&#x2F;C++程序、email 消息以及其他专业的文本文件。</li></ul><ol start="2"><li>aspell 案例</li></ol><ul><li>检查一篇简单散文的拼写错误，可以用如下方式使用 aspell 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aspell check textfile</span><br></pre></td></tr></table></figure></li><li>此处的 test.file 是要进行检查的文件名。作为实例进行讲解，下面创建了一个简单的 foo.txt 文本文件，它包含一些故意的拼写错误。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox jimped over the laxy dog.</span><br></pre></td></tr></table></figure></li><li>接下来使用 aspell 检查文件中的拼写错误。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell check foo.txt</span><br></pre></td></tr></table></figure></li><li>由于 aspell 在检查模式下是与用户交互的，显示内容的顶部，被怀疑错误的字符是以高亮的形式显示的。中间部分，有 10 个标号从 0 ~ 9 的替换拼写建议以及其他可能的动作选项。最后，末端有一个提示框用户进行操作选择。</li><li>假定我们输入 1 ，则 aspell 会将错误的单词用 jumped 取代并且继续处理下一个错误单词 laxy 。如果选择替代单词 lazy ，aspell 便执行此替换操作然后终止程序。</li><li>aspell 命令检查结束后，可以再次查看文件，会发现那些拼写错误的单词已经改正过来，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> foo.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>除非额外指定了命令行选项 --done-backup ，不然 aspell 将会创建一个包含原文本内容的备份文件，此备份文件文件名则由原文件名加上后缀 .bak 组成。</li><li>sed 其实有更强大的编辑功能，恢复 foo.txt 文件中原有的拼写错误以便再次利用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -i <span class="string">&#x27;s/lazy/laxy/;s/jumped/jimped/&#x27;</span> foo.txt</span><br></pre></td></tr></table></figure></li><li>sed 选项 -i 告诉 sed 原地编辑文件，这表示 sed 不会将编辑结果送至标准输出，而是将改变后的文本重新写入文件中。同样可以看出，一个命令行中可以输入多个编辑命令，只要用分号将它们隔开即可。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十三章 编译程序</title>
      <link href="/post/b2b5d2f0.html"/>
      <url>/post/b2b5d2f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章将介绍如何通过源代码生成可执行程序。开放源代码是 Linux 自由开源的必要因素，整个 Linux 系统的开发依赖于开发人员之间的自由交流。</li><li>需要编译软件的原因：</li></ol><ul><li>可用性：尽管有些发行版已经包含了版本库中一些预编译程序，但并不会包含用户所有可能需要的应用程序。这种情况下，用户获取所需要软件的唯一方式就是编译源代码。</li><li>及时性：虽然有些发行版本专注于一些前沿的程序版本，但是多数并不会。这就意味着想要获取最新版本的程序，编译必不可少的。</li></ul><ol start="3"><li>编译软件源代码是一项非常复杂并且有技术性的任务，这远远超出了多数用户的能力范围。</li><li>本章将会介绍一个新的命令：</li></ol><ul><li>make: 维护程序的工具</li></ul><h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><ol><li>编译就是一个将源代码 (由程序员编写的人类可读的程序描述) 编译成计算机处理器能识别的语言的过程。</li></ol><h2 id="是不是所有的程序都需要编译"><a href="#是不是所有的程序都需要编译" class="headerlink" title="是不是所有的程序都需要编译"></a>是不是所有的程序都需要编译</h2><ol><li>Shell 脚本可以直接运行而不需要编译，这些文件都是用脚本或解释型语言编写的。</li><li>这些语言越来越受欢迎，其中就有 Perl、Python、PHP、Ruby 以及其他多种语言等。</li><li>脚本语言由一个称为解释器的特殊程序来执行，解释器负责输入程序文件并执行其所包含的所有指令。</li><li>通常来讲，解释型程序要比编译后的程序执行起来慢。这是因为在解释型程序中，每条源代码指令在执行时，都要重新翻译一次该源代码指令。</li><li>然而，在编译后的程序中，每条源代码指令只翻译一次，并且该翻译结果将永久地记录到最后的可执行文件中。</li><li>其实对于许多日常的编程工作，解释型程序的执行速度也是足够的，而其真正的优点在于开发解释型程序比要开发编译程序简单而迅速得多。</li></ol><h2 id="编译一个-C-程序"><a href="#编译一个-C-程序" class="headerlink" title="编译一个 C 程序"></a>编译一个 C 程序</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>在执行编译操作之前，需要一些工具，诸如编译器、链接器以及 make 等。</li><li>gcc (GNU C 编译器) 是 Linux 环境中通用的 C 编译器，最初由 Richard Stallman 编写的。</li><li>多数 Linux 发行版本并不会默认安装 gcc ，我么可以用下面的命令行查看系统是否安装了该编译器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">which</span> gcc</span><br><span class="line">/usr/bin/gcc</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><ol><li>从一个叫做 diction 的 GNU 项目中选择一个程序进行编译练习，这个方便短小的程序一般用于检查文本文件的质量和写作风格，它非常小并且容易生成。 </li><li>依据惯例，我们首先创建一个 src 目录用于存放源代码，然后使用 ftp 下载源代码至该目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> src &amp;&amp; <span class="built_in">cd</span> src</span><br><span class="line">[me@linuxbox src]$ ftp ftp.gnu.org</span><br><span class="line">Connected to ftp.gnu.org.</span><br><span class="line">220 GNU FTP server ready.</span><br><span class="line">Name (ftp.gnu.org:me): anonymous</span><br><span class="line">230-NOTICE (Updated October 13 2017):</span><br><span class="line">230-</span><br><span class="line">230-Because of security concerns with plaintext protocols, we still</span><br><span class="line">230-intend to <span class="built_in">disable</span> the FTP protocol <span class="keyword">for</span> downloads on this server</span><br><span class="line">230-(downloads would still be available over HTTP and HTTPS), but we</span><br><span class="line">230-will not be doing it on November 1, 2017, as previously announced</span><br><span class="line">230-here. We will be sharing our reasons and offering a chance to</span><br><span class="line">230-comment on this issue soon; watch this space <span class="keyword">for</span> details.</span><br><span class="line">230-</span><br><span class="line">230-If you maintain scripts used to access ftp.gnu.org over FTP,</span><br><span class="line">230-we strongly encourage you to change them to use HTTPS instead.</span><br><span class="line">230-</span><br><span class="line">230----</span><br><span class="line">230-</span><br><span class="line">230-Due to U.S. Export Regulations, all cryptographic software on this</span><br><span class="line">230-site is subject to the following legal notice:</span><br><span class="line">230-</span><br><span class="line">230-    This site includes publicly available encryption <span class="built_in">source</span> code</span><br><span class="line">230-    <span class="built_in">which</span>, together with object code resulting from the compiling of</span><br><span class="line">230-    publicly available <span class="built_in">source</span> code, may be exported from the United</span><br><span class="line">230-    States under License Exception <span class="string">&quot;TSU&quot;</span> pursuant to 15 C.F.R. Section</span><br><span class="line">230-    740.13(e).</span><br><span class="line">230-</span><br><span class="line">230-This legal notice applies to cryptographic software only. Please see</span><br><span class="line">230-the Bureau of Industry and Security (www.bxa.doc.gov) <span class="keyword">for</span> more</span><br><span class="line">230-information about current U.S. regulations.</span><br><span class="line">230 Login successful.</span><br><span class="line">ftp&gt; <span class="built_in">cd</span> gnu/diction</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">200 PORT <span class="built_in">command</span> successful. Consider using PASV.</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 3003     65534       68940 Aug 28  1998 diction-0.7.tar.gz</span><br><span class="line">-rw-r--r--    1 3003     65534       90957 Mar 04  2002 diction-1.02.tar.gz</span><br><span class="line">-rw-r--r--    1 3003     65534      141062 Sep 17  2007 diction-1.11.tar.gz</span><br><span class="line">-rw-r--r--    1 3003     65534         189 Sep 17  2007 diction-1.11.tar.gz.sig</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; get diction-1.11.tar.gz</span><br><span class="line">200 PORT <span class="built_in">command</span> successful. Consider using PASV.</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> diction-1.11.tar.gz (141062 bytes).</span><br><span class="line">WARNING! 554 bare linefeeds received <span class="keyword">in</span> ASCII mode</span><br><span class="line">File may not have transferred correctly.</span><br><span class="line">226 Transfer complete.</span><br><span class="line">141062 bytes received <span class="keyword">in</span> 1.3 seconds (106 kbytes/s)</span><br><span class="line">ftp&gt; <span class="built_in">bye</span></span><br><span class="line">221 Goodbye.</span><br><span class="line">[me@linuxbox src]$ <span class="built_in">ls</span></span><br><span class="line">diction-1.11.tar.gz</span><br></pre></td></tr></table></figure></li><li>我们可以看到，源代码通常以一个压缩的 tar 文件的形式存在，有时被称为 tarball，该文件包含了源代码数树，即构成该源代码的目录及文件的组织框架。</li><li>连接 FTP 站点后，我们便可以查看可用的 tar 文件列表并挑选其中最新的版本进行下载。</li><li>在 ftp 中使用 get 命令，即可将文件从 FTP 服务器复制到本地主机。</li><li>下载了该 tar 文件后，就必须对其进行解压缩，这是通过 tar 程序来完成的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox src]$ tar xzf diction-1.11.tar.gz</span><br><span class="line">[me@linuxbox src]$ <span class="built_in">ls</span></span><br><span class="line">diction-1.11        diction-1.11.tar.gz</span><br></pre></td></tr></table></figure></li></ol><h3 id="检查源代码树"><a href="#检查源代码树" class="headerlink" title="检查源代码树"></a>检查源代码树</h3><ol><li>解压 tar 文件会产生一个新的目录：diction-1.11 。</li><li>该目录包含了源文件树，具体内容如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox src]$ <span class="built_in">cd</span> diction-1.11</span><br><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span></span><br><span class="line">config.guess    diction.c   getopt.c    <span class="built_in">nl</span></span><br><span class="line">config.h.in     diction.pot     getopt.h    nl.po               </span><br><span class="line">config.sub      diction.spec    getopt_int.h    README</span><br><span class="line">configure       diction.spec.in INSTALL         sentence.c</span><br><span class="line">configure.in    diction.texi.in install-sh      sentence.h</span><br><span class="line">COPYING         en              Makefile.<span class="keyword">in</span>     style.1.in</span><br><span class="line">de              en_GB           misc.c          style.c         de.po           en_GB.po        misc.h          <span class="built_in">test</span></span><br><span class="line">diction.1.in    getopt1.c       NEWS</span><br></pre></td></tr></table></figure></li><li>此目录下的其他有趣文件便是这些以 .c 和 .h 结尾的文件，<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> *.c</span><br><span class="line">diction.c   getopt1.c   getopt.c    misc.c sentence.c    style.c</span><br><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> *.h</span><br><span class="line">getopt.h    getopt_int.h    misc.h      sentence.h</span><br></pre></td></tr></table></figure></li><li>软件包提供的两个 C 程序 (style 和 diction) 便是以 .c 结尾，并且他们都被分成了多个模块。</li><li>这些源代码文件都是普通的文本文件，可以用 less 查看。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ less diction.c</span><br></pre></td></tr></table></figure></li><li>.h 文件是大家熟知的头文件。这些文件，同样也是普通的文本文件。</li><li>头文件中包含了对源代码文件或库中的例程的描述。编译器在链接这些例程模块时，必须给它提供一个其所用的所有模块的描述。</li><li>因此，在 diction.c 的开头，可一看到如下文本行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include &quot;getopt.h&quot;</span></span><br></pre></td></tr></table></figure></li><li>该文本行会指示编译器在读取 diction.c 中的源代码内容时，先读取文件 getopt.c 中内容。</li><li>getopt.c 文件包含的是由 style 和 diction 程序所共享的例程模块。</li><li>在 getopt.h 的 include 语句上面，还可以看到一些其他 include 语句，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include &lt;regex.h&gt;</span></span><br><span class="line"><span class="comment"># include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"># include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment"># include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment"># include &lt;unisted.h&gt;</span></span><br></pre></td></tr></table></figure></li><li>这些都是用来引用头文件，但是它们引用的是那些不存在当前源目录的头文件。它们由系统提供，为每个程序的编译提供支持。如果查看&#x2F;usr&#x2F;include 目录。便会看到如下内容。</li></ol><h3 id="生成程序"><a href="#生成程序" class="headerlink" title="生成程序"></a>生成程序</h3><ol><li>大多数程序都是使用一个简单的两行命令来生成的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li>configure 程序其实是源代码树下的一个 Shell 脚本，它的任务就是分析生成环境。</li><li>多数源码都设计成可移植的。也就是说，源代码可以在多种类型的 UNIX 系统上生成，只是源代码在生成时可能需要经过细微的调整以适应各系统之间的不同。</li><li>configure 同样会检查系统是否已经安装了必要的外部工具和组件。</li><li>由于 configure 并不是存放于 shell 通常期望程序所在的目录下，所以必须显式告知 shell 有关 configure 的位置，我们可以在命令前添加 .&#x2F; 目录符来实现目的。</li><li>该符号表示 configure 程序位于在当前的工作目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ ./configure</span><br></pre></td></tr></table></figure></li><li>configure 会在检查以及配置 build 程序的同时输出很多相关信息。</li><li>需要注意的是，如果没有错误信息表示成功，如果有，该 configure 操作将以失败告终，并且不会生成可执行程序，直到所有的错误都被纠正过来。</li><li>configure 在源目录中创建了几个新文件，其中最重要的就是 Makefile 。</li><li>Makefiles 是指导 make 命令如何生成可执行程序的配置文件，如果没有该文件， make 便无法运行。</li><li>Makefile 也是一个普通的文本文件，所以我们可以用 less 查看其内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ less Makefile</span><br></pre></td></tr></table></figure></li><li>make 程序的作用其实就是输入 makefile (通常叫做 Makefile) ，该文件描述了生成最后可执行程序时各部件之间的练习及依赖关系。</li><li>makefile 的第一部分内容定义了一些变量，这些变量在 makefile 的后面部分将会被替换掉。</li><li>make 程序运行时，会使用 Makefile 文件中的内容指导其操作，其间会产生许多信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ make</span><br></pre></td></tr></table></figure></li><li>make 能够智能地仅生成需要指定 building 操作的目标文件。</li></ol><h3 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h3><ol><li>打包好的源代码一般包含一个特殊的 make 目标程序，他便是 install。</li><li>该目标程序将会在系统目录下安装最后生成的可执行程序。通常，会安装在目录 &#x2F;usr&#x2F;local&#x2F;bin 下，该目录是本地主机上生成软件的常用安装目录。</li><li>然而，对于普通用户，该目录通常不可写的，所以必须转换成超级用户才可以运行安装。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ sudo make install</span><br></pre></td></tr></table></figure></li><li>安装结束后，就可以查看该程序是否可以运行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">which</span> diction</span><br><span class="line">/usr/local/bin/diction</span><br><span class="line">[me@linuxbox diction-1.11]$ man diction</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十一章 格式化输出</title>
      <link href="/post/a0304c57.html"/>
      <url>/post/a0304c57.html</url>
      
        <content type="html"><![CDATA[<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章继续讨论与文本相关的工具，重点将一些用于格式文本输出而非改变文本自身内容的命令。</li><li>这些命令通常用于文本的打印，而打印这一主题将在下一章介绍。</li><li>本章将要讨论的命令如下所示：</li></ol><ul><li>nl: 对行进行标号</li><li>fold: 设定文本行长度</li><li>fmt: 简单的文本格式化工具</li><li>pr: 格式化打印文本</li><li>printf: 格式化并打印数据</li></ul><h2 id="简单的格式化工具"><a href="#简单的格式化工具" class="headerlink" title="简单的格式化工具"></a>简单的格式化工具</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>首先让我们看一些简单的格式化工具，他们多数都是单目的程序，且一般执行一些不复杂的操作，他们一般用于一些小的任务，并作为管道传输和脚本的一部分。</li></ol><h3 id="nl-对行进行标号"><a href="#nl-对行进行标号" class="headerlink" title="nl - 对行进行标号"></a>nl - 对行进行标号</h3><ol><li>nl 基本介绍</li></ol><ul><li>nl 命令是一个非常神秘的工具，用于完成一个非常简单的任务；对行进行编号。就其最简单用法，与 cat -n 很相似。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">nl</span> distros.txt | <span class="built_in">head</span></span><br><span class="line">     1SUSE10.212/07/2006</span><br><span class="line">     2Fedora10.011/25/2008</span><br><span class="line">     3SUSE11.006/19/2008</span><br><span class="line">     4Ubuntu8.0404/24/2008</span><br><span class="line">     5Fedora8.0011/08/2007</span><br><span class="line">     6SUSE10.310/04/2007</span><br><span class="line">     7Ubuntu6.1010/26/2006</span><br><span class="line">     8Fedora7.0005/31/2007</span><br><span class="line">     9Ubuntu7.1010/18/2007</span><br><span class="line">    10Ubuntu7.0404/19/2007</span><br></pre></td></tr></table></figure></li><li>和 cat 命令一样，nl 既支持多个文件名作为命令行参数，也支持标准输入，然而，nl 可以进行多种复杂的编号，因为它有许多参数选项，且支持原始形式的标记。</li><li>nl 进行标号时支持一个叫做逻辑页的概念，所以它可以重置数值序列。</li><li>通过合理运用参数选项，nl 可以设置起始编码为特定的值，并在有限的范围内设置其格式，逻辑页可以进一步分解为逻辑页标题、正文和页脚。</li><li>在每一个部分中，行号都可以重置并&#x2F;或分配不同的风格。</li><li>如果 nl 的输入参数是多个文件，那么 nl 会把它们当做一个文本流整体。</li><li>文本流中的每一个部分都由一些看起来非常奇怪的标记来区别。</li></ul><ol start="2"><li>nl 标记</li></ol><table><thead><tr><th align="center">标记</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\:\:\:</code></td><td align="center">逻辑页页眉开头</td></tr><tr><td align="center"><code>\:\:</code></td><td align="center">逻辑页正文开头</td></tr><tr><td align="center"><code>\:</code></td><td align="center">逻辑页页脚开头</td></tr></tbody></table><ol start="3"><li>常用的 nl 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-b style</td><td align="center">按照 style 对正文进行编号，这里的 style 是下面类型中的一个：a 对每行编号； t 仅仅对非空白行编号，此选项是默认的； n 不对任何行进行编号； pregexp 只对与基本正则表达式匹配的行进行编号</td></tr><tr><td align="center">-f style</td><td align="center">以 style 的格式对页脚进行编号。默认选项是 n (无)</td></tr><tr><td align="center">-h style</td><td align="center">以 style 的格式对标题进行编号。默认选项是 n (无)</td></tr><tr><td align="center">-i number</td><td align="center">设置页编号的步进值为 number。默认值为 1 。</td></tr><tr><td align="center">-n format</td><td align="center">设置编号格式为 format，此处的 format 可以是如下表示中的一种：ln 左对齐，无缩进；rn 右对齐， 无缩进，这是默认选项；rz 右对齐，有缩进</td></tr><tr><td align="center">-p</td><td align="center">在每个逻辑页的开始不再进行页编码重置</td></tr><tr><td align="center">-s string</td><td align="center">在每行行号后面增加 string 作为分隔符。默认的情况下是一个简单的 tab 制表符。</td></tr><tr><td align="center">-w width</td><td align="center">设置行号字段的宽度为 width 。默认值是 6 。</td></tr></tbody></table><ol start="4"><li>nl 补充说明</li></ol><ul><li>不得不承认，用户可能并不会那么频繁地进行行编号，但是，用户可以利用 nl 结合其他工具进行更复杂的任务。</li></ul><h3 id="fold-将文本的行长度设定为指定长度"><a href="#fold-将文本的行长度设定为指定长度" class="headerlink" title="fold - 将文本的行长度设定为指定长度"></a>fold - 将文本的行长度设定为指定长度</h3><ol><li>fold 是一个将文本行以指定长度分解的操作。与命令行类似，fold 支持一个或多个文本文件或是标准输入作为输入参数。向 fold 输入一个简单的文本流，便可了解其工作方式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span> | <span class="built_in">fold</span> -w 12</span><br><span class="line">The quick br</span><br><span class="line">own fox jump</span><br><span class="line">ed over the</span><br><span class="line">lazy dog.</span><br></pre></td></tr></table></figure></li><li>这样，我们便能明白 fold 到底完成了什么操作。 echo 命令输出的文本被指定了 -w 选项的 fold 分解成了片段。</li><li>本例中，指定了行的宽度为 12 个字符。如果没有指定行宽，则默认是 80 个字符宽。</li><li>请注意，fold 在断行时并不会考虑单词边界。而增加 -s 选项，可使 fold 到达 width 字符数前的最后一个有效空格将原文本行断开，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span> | <span class="built_in">fold</span> -w 12 -s</span><br><span class="line">The quick</span><br><span class="line">brown fox</span><br><span class="line">jumped over</span><br><span class="line">the lazy</span><br><span class="line">dog.</span><br></pre></td></tr></table></figure></li></ol><h3 id="fmt-简单的文本格式化工具"><a href="#fmt-简单的文本格式化工具" class="headerlink" title="fmt - 简单的文本格式化工具"></a>fmt - 简单的文本格式化工具</h3><ol><li>fmt 基本介绍</li></ol><ul><li>fmt 命令同样会折叠文本，另外还包括更多的其他功能。它既可以处理文件也可以处理标准输入，并对文本流进行段落格式化。 </li><li>就其基本功能而言，它可以在保留空白行和缩进的同时对文本进行填充和连接。 </li><li>作为演示的文本内容，不如从 fmt 帮助手册中复制一些内容吧。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The fmt utility is a simple text formatter which reads the concatenation of input files (or standard input if none are given) and produces</span><br><span class="line">     on standard output a version of its input with lines as close to the goal length as possible without exceeding the maximum.  The goal</span><br><span class="line">     length defaults to 65 and the maximum to 10 more than the goal length.  Alternatively, a single width parameter can be specified either by</span><br><span class="line">     prepending a hyphen to it or by using -w.  For example, ``fmt -w 72&#x27;&#x27;, ``fmt -72&#x27;&#x27;, and ``fmt 72 72&#x27;&#x27; all produce identical output.  The</span><br><span class="line">     spacing at the beginning of the input lines is preserved in the output, as are blank lines and interword spacing.  Lines are joined or</span><br><span class="line">     split only at white space; that is, words are never joined or hyphenated.</span><br><span class="line"></span><br><span class="line">     The options are as follows:</span><br></pre></td></tr></table></figure></li><li>将这段文字复制到文本编辑器中，并将其存为 fmt-info.txt 文本文件。</li><li>现在，假定我们需要重新格式化该文本，以满足每行 50 个字符宽的规则。那么我们可以输入 fmt 结合 -w 选项完成这样的格式化。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -w 50 fmt-info.txt | <span class="built_in">head</span></span><br><span class="line">The <span class="built_in">fmt</span> utility is a simple text formatter <span class="built_in">which</span> reads the concatenation of input files (or standard input <span class="keyword">if</span> none are given) and produces</span><br><span class="line">     on standard output a version of its input with lines as close to the goal length as possible without exceeding the maximum. </span><br><span class="line">     </span><br><span class="line">     The goal</span><br><span class="line">     length defaults to 65 and the maximum to 10 more than the goal length.  Alternatively, a single width parameter can</span><br></pre></td></tr></table></figure></li><li>这个输出结果还真奇怪。也许，实际上我们应该认真地阅读一遍下面的文字，因为它解释了事情发生的原委。</li><li>默认情况下，空白行、单词之间的空格和缩进都保留在输出结果中；不同缩进量的连续输入行并不进行拼接，制表符会在输入中扩展并直接输出。</li><li>所以，fmt 保留了第一行的缩进。幸运的是，fmt 提供了一个参数选项以修正这一问题。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -cw 50 fmt-info.txt | <span class="built_in">head</span></span><br><span class="line">The <span class="built_in">fmt</span> utility is a simple text formatter <span class="built_in">which</span> reads the concatenation of input files (or standard input <span class="keyword">if</span> none are given) and produces</span><br><span class="line">on standard output a version of its input with lines as close to the goal length as possible without exceeding the maximum.  The goal</span><br><span class="line">length defaults to 65 and the maximum to 10 more than the goal length.  Alternatively, a single width parameter can be specified either by</span><br><span class="line">prepending a hyphen to it or by using -w.  For example, ``<span class="built_in">fmt</span> -w 72<span class="string">&#x27;&#x27;</span>, ``<span class="built_in">fmt</span> -72<span class="string">&#x27;&#x27;</span>, and ``<span class="built_in">fmt</span> 72 72<span class="string">&#x27;&#x27;</span> all produce identical output.  The</span><br><span class="line">spacing at the beginning of the input lines is preserved <span class="keyword">in</span> the output, as are blank lines and interword spacing.  Lines are joined or</span><br><span class="line"><span class="built_in">split</span> only at white space; that is, words are never joined or hyphenated.</span><br></pre></td></tr></table></figure></li><li>由此可见，通过增加 -c 选项，我们便得到了理想的输出结果。</li></ul><ol start="2"><li>fmt 有一些有趣的选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">在冠边缘模式下运行，此模式保留段落前两行的缩进，随后的行都与第二行的缩进对齐</td></tr><tr><td align="center">-p string</td><td align="center">只格式化以前缀字符串 string 开头的行。格式化后，string 的内容仍然会作为每一个格式化的前缀，该选项可以用于格式化内容是源代码的文本，例如，任何以 # 号作为生命开头的编程语言或是配置文件都可以通过指定 -p、# 选项进行格式化，指定该选项后可以保证只格式化声明中的内容。</td></tr><tr><td align="center">-s</td><td align="center">仅截断行模式。在此模式下，将会只根据指定的列宽截断行，而断行并不会与其他行结合，此模式适用于格式化文本单不需要行拼接的场合。</td></tr><tr><td align="center">-u</td><td align="center">字符间隔的统一，采取传统的打字机风格模式格式化文本，这意味着字符之间间隔一个空格字符，句子之间间隔两个空格字符。该模式对于删除齐行非常有用，所谓齐行就是指文本行被强迫与左右边缘对齐</td></tr><tr><td align="center">-w width</td><td align="center">格式化文本使每行不超过 width 个字符，默认值是 75 。请注意， fmt 格式化时往往由于要保持的行平衡而使得行实际宽度比指定高度略小</td></tr></tbody></table><ol start="3"><li>fmt 补充说明</li></ol><ul><li>-p 选项尤为有趣，通过它，我们可以选择性地格式化文件内容，前提是要格式化的文本行都以相同的字符序列开头。</li><li>许多编程语言都是用 hash (#) 作为注释的开始，因此可以用此选项只格式化注释文本。</li><li>下面创建一个有注释的类似于程序的文本文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; fmt-code.txt</span><br><span class="line"><span class="comment"># This file contains code with comments</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line is a comment.</span></span><br><span class="line"><span class="comment"># Followed by another comment line.</span></span><br><span class="line"><span class="comment"># And another.</span></span><br><span class="line"></span><br><span class="line">This on the other hand, is a line of code.</span><br><span class="line">And another line of code.</span><br><span class="line">ANd another.</span><br></pre></td></tr></table></figure></li><li>我们的示例文本包含了以 # (# 后紧跟一个空格)字符串开头的注释以及代码行 (虽然并不是真正意义上的代码) 。现在，我们使用 fmt 格式化该注释内容而不改动代码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file contains code with comments</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line is a comment.Followed by another </span></span><br><span class="line"><span class="comment"># comment line.And another.</span></span><br><span class="line"></span><br><span class="line">This on the other hand, is a line of code.</span><br><span class="line">And another line of code.</span><br><span class="line">ANd another.</span><br></pre></td></tr></table></figure></li><li>请注意，毗邻的注释行已经拼接起来，但是保留了空白行以及不是以指定前缀开头的文本行。</li></ul><h3 id="pr-格式化打印文本"><a href="#pr-格式化打印文本" class="headerlink" title="pr - 格式化打印文本"></a>pr - 格式化打印文本</h3><ol><li>Pr 命令用于给出文本标页码。</li><li>打印文本时，通常希望将输出内容分成几页，并且每页的顶部和底部都留出几行空白，这些空白可以用于插入页眉和页脚。</li><li>示例如下，该命令行将 distros.txt 文件格式化为一系列非常短的页 (只显示了前两页) 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">pr</span> -l 15 -w 65 distros.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 1 12 11:09 2021 distros.txt Page 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">Fedora10.011/25/2008</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Fedora8.0011/08/2007</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 1 12 11:09 2021 distros.txt Page 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Fedora7.0005/31/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu7.0404/19/2007</span><br></pre></td></tr></table></figure></li><li>上例中，结合了 -l 选项 (页长) 以及 -w 选项 (页宽) 定义了一页内容包含 15 行，每行包含 65 个字符。</li><li>pr 对 distros.txt 文件的内容进行分页，页与页之间则用几行空白行隔开，并且创建了一个包含文件修改时间、文件名以及页码的默认页眉。</li></ol><h3 id="printf-格式化并打印数据"><a href="#printf-格式化并打印数据" class="headerlink" title="printf - 格式化并打印数据"></a>printf - 格式化并打印数据</h3><ol><li>printf 基本介绍</li></ol><ul><li>与本章中涉及的其他命令不一样，printf 命令并不适用于管道传输 (也就是说它不支持标准输入) ，而且命令行应用中它也不常见 (多用于脚本文件) 。</li><li>printf 起初是为 C 语言开发的，后来许多编程语言也都实现了这一功能，也包括 shell 环境。</li><li>事实上，在 bash 中，printf 是内置的。</li><li>printf 的用法如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;format&quot;</span> arguments</span><br></pre></td></tr></table></figure></li><li>该命令行给出了一个包含格式说明的字符串，然后将该格式应用于 arguments 所代表的输入内容，最后格式化结果送至标准输出。</li><li>下面就是一个简单的例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;I formatted the string: %s\n&quot;</span> foo</span><br><span class="line">I formatted the string: foo</span><br></pre></td></tr></table></figure></li><li>该格式化字符串可以包含文字文本、转义字符以及以 % 开头的表示转换规格的字符序列。</li><li>上例中，转换规格 %s 所代表的转换规格被字符串 foo 取代。</li><li>s 表示格式化字符串数据，其他类型的数据则用其他指定字符表示。</li></ul><ol start="2"><li>常用 printf 数据类型指定符</li></ol><table><thead><tr><th align="center">指定符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">D</td><td align="center">将一个数字格式化为有符号的十进制表示形式</td></tr><tr><td align="center">F</td><td align="center">格式化数字并以浮点数的格式输出</td></tr><tr><td align="center">O</td><td align="center">将一个整数格式化为八进制格式的整数</td></tr><tr><td align="center">s</td><td align="center">格式化字符串</td></tr><tr><td align="center">x</td><td align="center">将一个整数格式化为十六进制的数，并且在使用字母时，用小写字母</td></tr><tr><td align="center">X</td><td align="center">与 x 类似，只是字母用大写字母表示</td></tr><tr><td align="center">%</td><td align="center">打印文字符号 %</td></tr></tbody></table><ol start="3"><li>printf 案例</li></ol><ul><li>下列中，利用字符串 “380” 演示了每个转换说明符的使用效果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;%d, %f, %o, %s, %x, %X\n&quot;</span> 380 380 380 380 380 380</span><br><span class="line">380, 380.000000, 574, 380, 17c, 17C</span><br></pre></td></tr></table></figure></li><li>转换说明符也可以通过增加一些可选组件以对输出效果进行调整。一个完整的转换规格可能会包含如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.precision]conversion_specification</span><br></pre></td></tr></table></figure></li><li>当使用多个可选组件时，这些组件必须按照上面顺序才能被正确编译。</li></ul><ol start="4"><li>printf 转换规范组成部分</li></ol><table><thead><tr><th align="center">组件</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">flags</td><td align="center">总共有 5 个不同的 flag：# 使用替代格式输出。这取决于数据类型。对于 o (八进制数) 类转换，输出结果以 0 开头。对于 x 和 X 类转换，输出则分别以 0x 和 0X 开头；用 0 填充输出。这代表着字段前会填充 0，如 000380 ； - 表示输出左对齐。默认情况下， printf 是右对齐输出的；空格为正数产生一个前导空格； + 表示正数符号。默认情况下， printf 只会输出负数的符号</td></tr><tr><td align="center">width</td><td align="center">一个数字，该数字指定了最小字段宽度</td></tr><tr><td align="center">.precision</td><td align="center">对于浮点数，便是指定小数点后的小数精确度。对于字符串转换，precision 则指定了输出字符的个数</td></tr></tbody></table><ol start="5"><li>printf 转换规范实例</li></ol><table><thead><tr><th align="center">参数</th><th align="center">格式</th><th align="center">转换结果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">380</td><td align="center">“%d”</td><td align="center">380</td><td align="center">对整数进行简单的格式化</td></tr><tr><td align="center">380</td><td align="center">“%#x”</td><td align="center">0x17c</td><td align="center">使用替代格式标记将整数格式化为一个十六进制数</td></tr><tr><td align="center">380</td><td align="center">“%05d”</td><td align="center">00380</td><td align="center">将整数格式化为至少 5 字符宽度的字段，不足位数可在前面填充 0</td></tr><tr><td align="center">380</td><td align="center">“%05.5f”</td><td align="center">380.00000</td><td align="center">将数字格式化为精确到小数点后五位的浮点数，不足位数用 0 填充。由于指定的最小字段宽度 5 要比格式化后实际的数值位数小，所以此处并没有进行填充</td></tr><tr><td align="center">380</td><td align="center">“%010.5f”</td><td align="center">0380.00000</td><td align="center">把最小字段宽度增加为 10 ，并且 0 填充可见</td></tr><tr><td align="center">380</td><td align="center">“%+d”</td><td align="center">+380</td><td align="center">+ 标记符表示此数是正数</td></tr><tr><td align="center">380</td><td align="center">“%-d”</td><td align="center">380</td><td align="center">- 标记符表示左对齐</td></tr><tr><td align="center">abcdefghijk</td><td align="center">“%5s”</td><td align="center">abcdefghijk</td><td align="center">用最小的字段宽度来最小化字符串</td></tr><tr><td align="center">abcdefghijk</td><td align="center">“%.5s”</td><td align="center">abcde</td><td align="center">根据字符串的精确位数截断字符串</td></tr></tbody></table><ol start="6"><li>printf 补充说明</li></ol><ul><li>同样，printf 通常用于脚本文件的表格数据格式化操作，而并不会直接应用于命令行。</li><li>不过，我们仍然可以用其解决各种各样的格式化问题。</li><li>首先我们可以利用 printf 输出一些由制表符隔开的字段。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;%s\t%s\t%s\n&quot;</span> str1 str2 str3</span><br><span class="line">str1    str2    str3</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章 权限</title>
      <link href="/post/30a86786.html"/>
      <url>/post/30a86786.html</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-权限"><a href="#第九章-权限" class="headerlink" title="第九章 权限"></a>第九章 权限</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>传统的 UNIX 操作系统与那些传统的 MS-DOS 操作系统不同，区别在于它们不仅是多重任务处理系统，而且还是多用户系统。</li><li>为了保证多用户功能实际可用，Linux 系统特别设计了一种方案来保护当前用户不受其他用户操作的影响。</li><li>本章将介绍系统安全的基础知识以及如下命令的使用：</li></ol><ul><li>id: 显示用户身份标识</li><li>chmod: 更改文件的模式</li><li>umask: 设置文件的默认权限</li><li>su: 以另一个用户的身份运行shell</li><li>sudo: 以另一个用户的身份来执行命令</li><li>chown: 更改文件所有者</li><li>chgrp: 更改文件所属群组</li><li>passwd：更改用户密码</li></ul><h2 id="所有者、组成员和其他所有用户"><a href="#所有者、组成员和其他所有用户" class="headerlink" title="所有者、组成员和其他所有用户"></a>所有者、组成员和其他所有用户</h2><ol><li>我们在第四章讲解文件系统时，当试图查看类似 &#x2F;etc&#x2F;shadow 的文件时，会遇到下面的问题：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ file /etc/shadow</span><br><span class="line">/etc/shadow: regular file, no <span class="built_in">read</span> permission</span><br><span class="line">[me@linuxbox ~]$ less /etc/shadow</span><br><span class="line">/etc/shadow: Permission denied</span><br></pre></td></tr></table></figure></li><li>产生这种错误信息的原因是，作为一个普通用户，没有读取这个文件的权限。</li><li>在 UNIX 安全模型中，一个用户可以拥有 (own) 文件和目录。当一个用户拥有一个文件或者目录时，它将对该文件或目录的访问权限拥有控制权。</li><li>用户又归属于一个群组 (group) ，该群组由一个或者多个用户组成，组中用户对文件和目录的访问权限由其所有者授予。除了可以授予群组访问权限之外，文件所有者也可以授予所有用户一些访问权限。在 UNIX 术语中，所有用户是指整个世界 (world) 。</li><li>使用 id 命令可以获得用户身份标识的相关信息，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">id</span></span><br><span class="line">uid=500(me) gid=500(me) <span class="built_in">groups</span>=500(me)</span><br></pre></td></tr></table></figure></li><li>查看 id 命令的输出结果。在创建用户账户的时候，用户被分配一个称为用户 ID 或者 uid 的号码。</li><li>为了符合人们的使用习惯，用户 ID 与用户名一一映射。同时用户将被分配一个有效组 ID 或者称为 gid ，而且该用户也可以归属其他用户群组。</li><li>前面的例子是在 Fedora 系统中运行的结果。在其他系统中，比如  Ubuntu 系统，输出结果可能有一些不同。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(me) gid=1000(me)</span><br><span class="line"><span class="built_in">groups</span>=4(adm), 20(dialout), 24(cdrom), 25(floppy), 29(audio), 30(dip), 44(video), 46(plugdev), 108(lpadmin), 114(admin), 1000(me) </span><br></pre></td></tr></table></figure></li><li>我们可以发现，两个系统中用户的 uid 和 gid 号码是不同的。原因很简单，因为在 Fedora 系统中，普通用户账户是从 500 开始编号的，而在 Ubuntu 系统中则是从 1000 开始编号。同时我们也可以发现，Ubuntu 系统中的用户归属于更多的群组。这和 Ubuntu 系统中的用户归属于更多的群组。这和 Ubuntu 系统管理系统设备和服务权限的方式有关。</li><li>用户账户定义在文件 &#x2F;etc&#x2F;passwd 中，用户组定义在文件 &#x2F;etc&#x2F;group 文件中。在创建用户账户和群组时，这些文件随着文件 &#x2F;etc&#x2F;shadow 的变动而修改，文件 &#x2F;etc&#x2F;shadow 中保存了用户的密码信息。</li><li>对于每一个用户账户，文件 &#x2F;etc&#x2F;passwd 中都定义了对应用户的用户 (登录) 名、uid、gid、账户的真实姓名、主目录以及登录 shell 信息。</li><li>如果查看文件 &#x2F;etcpasswd 和文件 &#x2F;etc&#x2F;group 的内容，那么你将会发现除了普通用户账户信息之外，文件中还有对应于超级用户 (uid&#x3D;0) 和其他不同种类的系统用户的账户信息。</li><li>许多类 UNIX 系统会把普通用户分配到一个公共群组中 (比如，users) ，然而现在的 Linux 操作则是创建一个独一无二的，只有一个用户的群组，而且组名和用户的名字相同。这使得特定类型的权限分配变得更加容易。</li></ol><h2 id="读取、写入和执行"><a href="#读取、写入和执行" class="headerlink" title="读取、写入和执行"></a>读取、写入和执行</h2><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><ol><li>基本介绍</li></ol><ul><li>对文件和目录的访问权限是按照读访问、写访问以及执行访问来定义的。 </li><li>当我们查看 ls 命令的输出结果时，可以得到一些线索，了解其实现方式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2012-03-03 14:52 foo.txt</span><br></pre></td></tr></table></figure></li><li>列出输出结果中的前 10 个字符表示的是文件属性 (file attribute) ，其中第一个字符表示文件类型 (file type) 。</li><li>文件属性中剩下的 9 个字符称为文件模式 (file mode) ，分别表示文件所有者、文件所属群组以及其他所有用户对该文件的读取、写入和执行权限。</li><li>在文件属性中，第一部分代表文件类型、第二部分代表所有者权限、第三部分代表组权限、第四部分代表其他用户权限。</li></ul><ol start="2"><li>文件属性</li></ol><table><thead><tr><th align="center">第一部分</th><th align="center">第二部分</th><th align="center">第三部分</th><th align="center">第四部分</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">rwx</td><td align="center">rw-</td><td align="center">r–</td></tr></tbody></table><ol start="3"><li>文件类型</li></ol><table><thead><tr><th align="center">属性</th><th align="center">文件类型</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">普通文件</td></tr><tr><td align="center">d</td><td align="center">目录文件</td></tr><tr><td align="center">l</td><td align="center">符号链接。注意对于符号链接文件，剩下的文件始终是 rwxrwxrwx ，它是一个为属性值。符号链接指向的文件属性才是真正的属性</td></tr><tr><td align="center">c</td><td align="center">字符设备文件。该文件类型表示以字节流形式处理数据的设备，如终端或调制解调器</td></tr><tr><td align="center">b</td><td align="center">块设备文件，该文件类型表示以数据块方式处理数据的设备，如硬盘驱动或者光盘驱动</td></tr></tbody></table><ol start="4"><li>模式属性</li></ol><table><thead><tr><th align="center">属性</th><th align="center">文件</th><th align="center">目录</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">允许打开和读取文件</td><td align="center">如果设置了执行权限，那么允许列出目录下的内容</td></tr><tr><td align="center">w</td><td align="center">允许写入或者截短文件，如果也设置了执行权限，那么目录中的文件允许被创建、被删除以及被重命名</td><td align="center">但是该权限不允许重命名或者删除文件。是否能重命名和删除文件由目录权限决定</td></tr><tr><td align="center">x</td><td align="center">允许把文件当作程序一样执行。用脚本语言写的程序文件必须被设置为可读，以便能被执行</td><td align="center">允许进入目录下</td></tr></tbody></table><ol start="5"><li>权限属性实例</li></ol><table><thead><tr><th align="center">文件属性</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-rwx——</td><td align="center">普通文件，文件所有者具有读取、写入和执行权限。组成员和其他所有用户都没有任何访问权限</td></tr><tr><td align="center">-rw——-</td><td align="center">普通文件，文件所有者具有读取和写入权限。组成员和其他所有用户都没有任何访问权限</td></tr><tr><td align="center">-rw-r–r–</td><td align="center">普通文件，文件所有者具有读取和写入权限。文件所有者所在群组的成员可以读取该文件。该文件对于所有用户来说都是可读的。</td></tr><tr><td align="center">-rwxr-xr-x</td><td align="center">普通文件，文件所有者具有读取、写入和执行权限。其他所有用户也可以读取和执行该文件</td></tr><tr><td align="center">-rw-rw—-</td><td align="center">普通文件，只有文件所有者和文件所有者所在群组的成员具有读取和执行权限</td></tr><tr><td align="center">lrwxrwxrwx</td><td align="center">符号链接。所有的符号链接显示的都是伪权限属性，真正的权限属性由符号链接指向的实际文件决定</td></tr><tr><td align="center">dwxrwx—-</td><td align="center">目录文件。文件所有者和所有者所在群组的成员都可以进入该目录，而且可以创建、重命名和删除该目录下的文件</td></tr><tr><td align="center">drwxr-x—</td><td align="center">目录文件。文件所有者可以进入该目录，而且可以创建、重命名和删除该目录下的文件。所有者所在群组的成员可以进入该目录，但不能创建、重命名和删除该目录下的文件</td></tr></tbody></table><h3 id="chmod-更改文件模式"><a href="#chmod-更改文件模式" class="headerlink" title="chmod - 更改文件模式"></a>chmod - 更改文件模式</h3><ol><li>chmod 基本介绍</li></ol><ul><li>我们可以使用 chmod 命令来更改文件或目录的模式 (权限) 。需要注意的是只有文件所有者和超级用户才可以更改文件或目录的模式。</li><li>chmod 命令支持两种不同的改变文件模式的方法-八进制数字表示法和符号表示法。</li></ul><ol start="2"><li>八进制数字表示法</li></ol><ul><li>八进制数字表示法指的是使用八进制数字来设置所期望的权限模式。因为每个八进制数字对应着 3 个二进制数字，所以这种对应关系正好可以和用来存储文件模式的结构方式一一映射。</li><li>通过使用 3 位八进制数字，我们可以分别设置文件所有者、组成员和其他用户 (world) 的文件模式。</li><li>虽然看起来，要记住八进制和二进制之间的映射关系好像不是那么简单，但是实际上，常用的也就只有这几个而已：7(rwx)、6(rw-)、5(r-x)、4(r–) 和 0(—) 。</li></ul><ol start="3"><li>二进制和八进制方式表示文件模式</li></ol><table><thead><tr><th align="center">八进制</th><th align="center">二进制</th><th align="center">文件模式</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">000</td><td align="center">—</td></tr><tr><td align="center">1</td><td align="center">001</td><td align="center">–x</td></tr><tr><td align="center">2</td><td align="center">010</td><td align="center">-w-</td></tr><tr><td align="center">3</td><td align="center">010</td><td align="center">-wx</td></tr><tr><td align="center">4</td><td align="center">100</td><td align="center">r–</td></tr><tr><td align="center">5</td><td align="center">101</td><td align="center">r-x</td></tr><tr><td align="center">6</td><td align="center">110</td><td align="center">rw-</td></tr><tr><td align="center">7</td><td align="center">111</td><td align="center">rwx</td></tr></tbody></table><ol start="4"><li>符号表示法</li></ol><ul><li>chmod 命令支持一种符号表示法来指定文件模式。</li><li>符号表示法分为三部分：更改会影响谁、要执行哪个操作以及要设置哪种权限。</li><li>可以通过字符 u、g、o 和 a 的组合来指定要影响的对象。</li><li>如果没有指定字符，则假定使用 all 。</li><li>操作符 + 表示添加一种权限，- 表示删除一种权限，&#x3D; 表示只有指定的权限可用，其他所有的权限都被删除。</li></ul><ol start="5"><li>chmod 命令符号表示法</li></ol><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">user 的简写，表示文件或者目录的所有者</td></tr><tr><td align="center">g</td><td align="center">文件所属群组</td></tr><tr><td align="center">o</td><td align="center">others 的简写，表示其他所有用户</td></tr><tr><td align="center">a</td><td align="center">all 的简写，是 u，g 和 o 三者组合</td></tr></tbody></table><ol start="6"><li>chmod 命令符号表示法实例</li></ol><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">u+x</td><td align="center">为文件所有者添加可执行权限</td></tr><tr><td align="center">u-x</td><td align="center">删除文件所有者的可执行权限</td></tr><tr><td align="center">+x</td><td align="center">为文件所有者、所属群组和其他所有用户添加可执行权限，等价于 a+x</td></tr><tr><td align="center">o-rw</td><td align="center">除了文件所有者和所属群组之外，删除其他所有用户的读写权限</td></tr><tr><td align="center">go&#x3D;rw</td><td align="center">除了文件所有者之外，设置所属群组和其他所有用户具有读写权限。如果所属群组或者其他所有用户之前已经具有可执行权限，那么删除他们的可执行权限</td></tr><tr><td align="center">u+x，go&#x3D;rx</td><td align="center">为文件所有者添加可执行权限，同时设置所属群组和其他所有用户具有读权限和可执行权限。指定多种权限时，需用逗号分隔</td></tr></tbody></table><h3 id="umask-设置默认权限"><a href="#umask-设置默认权限" class="headerlink" title="umask - 设置默认权限"></a>umask - 设置默认权限</h3><ol><li>umask 命令控制着创建文件时指定给文件的默认权限。它使用八进制表示法来表示从文件模式属性中删除一个位掩码。参见下面的例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> -f foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">umask</span></span><br><span class="line">0002</span><br><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2012-03-06 14:53 foo.txt</span><br></pre></td></tr></table></figure></li><li>首先删除 foo.txt 文件存在的所有副本，以保证一切都是重新开始。</li><li>下一步，运行不带任何参数的 unmask 命令，查看当前掩码值，得到的值是 0002 (0022 是另一个常用默认值) ，它是掩码的八进制表示形式，接着创建文件 foo.txt 的一个新实例，查看该文件的权限。</li><li>可以发现，文件所有者和组都获得了读写权限，而其他所有用户则只获得读权限。其他所有用户没有写权限的原因在于掩码值。重复执行该实例，不过这次是自己设置掩码值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">umask</span> 0000</span><br><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt</span><br><span class="line">-rw-rw-rw- 1 me me 0 2012-03-06 14:58 foo.txt</span><br></pre></td></tr></table></figure></li><li>在设置掩码为 0000 (实际上是关闭该功能) 时，可以看到其他所有用户也拥有写权限了。</li></ol><h2 id="更改身份"><a href="#更改身份" class="headerlink" title="更改身份"></a>更改身份</h2><ol><li>基本介绍</li></ol><ul><li>在很多时候，我们会发现可以拥有另一个用户的身份是很有必要的。</li><li>我们经常会需要获得超级用户的特权来执行一些管理任务，但是也可以变成另一个普通用户来执行这些任务，就好像是在测试一个账户。</li><li>有三种方法用来转换身份，具体如下：<ul><li>注销系统并以其他用户的身份重新登录系统。</li><li>使用 su 命令。</li><li>使用 sudo 命令。</li></ul></li></ul><ol start="4"><li>因为大家都知道如何操作第一种方法，而且它不如其他两种方法来的方便，所以这里跳过第一种方法。</li><li>在 shell 会话状态下，使用 su 命令将允许你假定为另一个用户的身份，既可以以这个用户的 ID 来启动一个新的 shell 会话，也可以以这个用户的身份来发布一个命令。</li><li>使用 sudo 命令将允许管理者创建一个称为 &#x2F;etc&#x2F;sudoer 的配置文件，并且定义一些特定的命令，这些命令只有赋予为假定身份的特定用户才允许执行。</li><li>选择使用哪个命令在很大程度上取决于使用的 Linux 发行版本。有些发行版本可能对两个命令都支持，但是它的系统配置可能只是偏向于其中一个。</li></ol><h3 id="su-以其他用户和组-ID-的身份来运行-shell"><a href="#su-以其他用户和组-ID-的身份来运行-shell" class="headerlink" title="su - 以其他用户和组 ID 的身份来运行 shell"></a>su - 以其他用户和组 ID 的身份来运行 shell</h3><ol><li>su 命令用来以另外一个用户来启动 shell 。该命令的一般形式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-[l]] [user]</span><br></pre></td></tr></table></figure></li><li>如果包含 -l 选项，那么得到的 shell 会话界面将是用于指定用户的登录 shell (login shell) 界面。这就意味着，该指定用户的运行环境将被加载，而且其工作目录也将更改为该指定用户的主目录。</li><li>如果没有指定用户，那么默认假定为超级用户。需要注意的是，-l 可以缩写为 - ，而且这一形式经常被使用。我们可以通过以下的操作来以超级用户的身份启动 shell 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -</span><br><span class="line">Password:</span><br><span class="line">[root@linuxbox ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li>在输入 su 命令后，系统会提示输入该超级用户的密码。如果密码输入正确，那么将会出现新的 shell 提示符，该提示符表示该 shell 将拥有超级用户的特权 (提示符的末尾字符是 # ，而不是 $ ) ，而且当前的工作目录现在也是用于超级用户的主目录 (通常情况下为 &#x2F;root ) 。</li><li>一旦进入了这个新的 shell 环境，我们就可以以超级用户的身份执行命令了。在使用结束时，输入 exit ，将返回到之前的 shell 环境。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># exit</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>我们也可以使用 su 命令执行单个命令，而不需要开启一个新的交互式命令界面，操作方式如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c <span class="string">&#x27;command&#x27;</span></span><br></pre></td></tr></table></figure></li><li>使用这种格式，单个命令行被传递到一个新的 shell 环境下执行，而是希望在新的 shell 环境下执行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -c <span class="string">&#x27;ls -l /root/*&#x27;</span></span><br><span class="line">Password</span><br><span class="line">-rw------- 1 root root 754 2011-08-11 03:19 /root/anaconda-ks.cfg</span><br><span class="line">/root/Mail:</span><br><span class="line">total 0</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li></ol><h3 id="sudo-以另一个用户的身份执行命令"><a href="#sudo-以另一个用户的身份执行命令" class="headerlink" title="sudo - 以另一个用户的身份执行命令"></a>sudo - 以另一个用户的身份执行命令</h3><ol><li>sudo 命令在很多方面都类似于su命令，但是它另外还有一些重要的功能。管理者可以通过配置 sudo 命令，使系统以一种可控方式，允许一个普通用户以一个不同的用户身份 (通常是超级用户) 执行命令。</li><li>在特定情况下，用户可能被限制为只能执行一条或者几条特定的命令，而对其他命令没有执行权限。另一个重要的区别在于，使用 sudo 命令并不需要输入超级用户密码。</li><li>使用 sudo 命令时，用户只需要输入自己的密码来进行认证。</li><li>比如说，配置 sudo 命令来允许普通用户运行一个虚构的备份程序 (称为 backup_script) ，这个程序需要超级用户权限。</li><li>通过 sudo 命令，该程序将会以如下方式运行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox -]$ sudo backup_script</span><br><span class="line">Password:</span><br><span class="line">System Backup Starting...</span><br></pre></td></tr></table></figure></li><li>在输入 sudo 命令后，系统将提示输入用户自己的密码 (而不是超级用户的密码) ，而且一旦认证通过，指定的命令就被执行。</li><li>su 命令和 sudo 命令之间的一个重要区别在于 sudo 命令并不需要启动一个新的 shell 环境，而且也不需要加载另一个用户的运行环境。</li><li>这意味着，使用 sudo 命令的时候并不需要用单引号把命令引起来。</li><li>需要注意的是，我们可以通过指定不同的选项来改变命令执行的效果。</li><li>查看 sudo 命令的帮助页面可以获得更多的细节内容。</li><li>要想知道 sudo 命令可以授予权限，可以使用 -l 选项来查看，具体如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo -l</span><br><span class="line">User me may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br></pre></td></tr></table></figure></li></ol><h3 id="chown-更改文件所有者和所属群组"><a href="#chown-更改文件所有者和所属群组" class="headerlink" title="chown - 更改文件所有者和所属群组"></a>chown - 更改文件所有者和所属群组</h3><ol><li>chown 基本介绍</li></ol><ul><li>chown 命令用来更改文件或者目录的所有者和所属群组。使用这个命令需要超级用户权限。 </li><li>chown 命令的语法格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [owner][:[group]] file ...</span><br></pre></td></tr></table></figure></li><li>chown 命令更改的是文件所有者还是文件所属群组，或者对两者都更改，取决于该命令的第一个参数。</li></ul><ol start="2"><li>chown 命令参数实例</li></ol><table><thead><tr><th align="center">参数</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">bob</td><td align="center">把文件从当前所有者更改为用户 bob</td></tr><tr><td align="center">bob:users</td><td align="center">把文件所有者从当前所有者更改为用户 bob ，并把文件所述群组更改为 users 组</td></tr><tr><td align="center">:admins</td><td align="center">把文件所属群组更改为 admins 组，文件所有者不变</td></tr><tr><td align="center">bob:</td><td align="center">把文件所有者从当前所有者更改为用户 bob ，并把文件所述群组更改为用户登录时所属的组</td></tr></tbody></table><ol start="3"><li>chown 案例</li></ol><ul><li>假设有两个用户-拥有超级用户权限的 janet 和没有该权限的 tony 。</li><li>用户 janet 想要从她的主目录复制一个文件到用户 tony 的主目录中。</li><li>因为用户 janet 希望 tony 能够编辑该文件，所以 janet 把该文件的所有者从 janet 更改为 tony ，具体操作如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[janet@linux ~]$ sudo <span class="built_in">cp</span> myfile.txt ~tony</span><br><span class="line">Password:</span><br><span class="line">[janet@linux ~]$ sudo <span class="built_in">ls</span> -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- 1 root root 8031 2012-03-20 14:30 /home/tony/myfile.txt</span><br><span class="line">[janet@linux ~]$ sudo <span class="built_in">chown</span> tony: ~tony/myfile.txt</span><br><span class="line">[janet@linux ~]$ sudo <span class="built_in">ls</span> -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- 1 tony tony 8031 2012-03-20 14:30 /home/tony/myfile.txt</span><br></pre></td></tr></table></figure></li><li>这里我们可以看到，用户 janet 首先把文件从她的目录复制到用户 tony 的主目录中。 </li><li>接下来，janet 把该文件的所有者从 root (使用 sudo 命令的结果) 更改为 tony 。 </li><li>通过在第一个参数末尾加上冒号， janet 也把文件的所属群组更改成了 tony 登录系统时所属的组，该组名碰巧也叫 tony 。</li></ul><h3 id="chgrp-更改文件所属群组"><a href="#chgrp-更改文件所属群组" class="headerlink" title="chgrp - 更改文件所属群组"></a>chgrp - 更改文件所属群组</h3><ol><li>在更早的 UNIX 版本中，chown 命令只能更改文件的所有者，而不能改变文件所属群组。</li><li>为了达到这个目的，我们可以使用一个独立的命令 chgrp 来实现。该命令除了限制多一点之外，和 chown 命令使用方式几乎相同。</li></ol><h2 id="权限的使用"><a href="#权限的使用" class="headerlink" title="权限的使用"></a>权限的使用</h2><ol><li>假设有两个用户，分别命名为 bill 和 karen 。他们都有音乐 CD 集，并想要创建一个共享目录，在该目录下他们各自以 Ogg Vorbis 格式或者 MP3 格式存储音乐文件。用户 bill 通过 sudo 命令获得了超级用户的访问权限。</li><li>第一件需要做的事情，就是创建一个 bill 和 karen 为成员的组。通过使用 GNOME 的图形化用户管理工具，bill 创建了一个组，命令为 music ，并且把 bill 和 karen 添加到该组中。</li><li>接下来，bill 创建了存储音乐文件的目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bill@linuxbox ~]$ sudo <span class="built_in">mkdir</span> /usr/local/share/Music</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure></li><li>因为 bill 正在操作的对象是他的主目录之外的文件，所以他需要拥有超级用户的权限。新创建的目录具有以下的所有权和权限。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bill@linuxbox ~]$ <span class="built_in">ls</span> -ld /usr/local/share/Music </span><br><span class="line">drwxr-xr-x 2 root root 4096 2012-03-21 18:05 /usr/local/share/Music</span><br></pre></td></tr></table></figure></li><li>可以看到，这个目录由 root 用户所有，而且权限值为 775 。要使得该目录可共享，bill 需要更改该目录的所有群组，而且该组需要具有写入权限。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bill@linuxbox ~]$ sudo <span class="built_in">chown</span> :music /usr/local/share/Music</span><br><span class="line">[bill@linuxbox ~]$ sudo <span class="built_in">chmod</span> 775 /usr/local/share/Music</span><br><span class="line">arwxrwxr-x 2 root music 4096 2012-03-21 18:05 /usr/local/share/Music</span><br></pre></td></tr></table></figure></li><li>它意味着当前我们已经有了 &#x2F;usr&#x2F;local&#x2F;share&#x2F;Music 目录，该目录由 root 用户所有，而且 music 组拥有该目录的读写权限。 music 组的成员为 bill 和 karen ，因此 bill 和 karen 都可以在目录 &#x2F;usr&#x2F;local&#x2F;share&#x2F;Music 下创建文件。其他用户列出了该目录下的内容，但不能在该目录下创建文件。</li><li>在当前的权限下，在 Music 目录下创建的文件和目录拥有目录 bill 和 karen 的常规权限。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file</span><br><span class="line">[bill@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/local/share/Music</span><br><span class="line">-rw-r--r-- 1 bill bill 0 2012-03-24 20:03 test_file</span><br></pre></td></tr></table></figure></li><li>第一个问题是，系统中默认掩码是 0022 ，这将不会允许组成员对属于组内其他成员的文件执行写入操作。</li><li>如果共享目录中只包含文件，那么这倒不是问题，但是因为该目录下将存放音乐文件，而音乐文件一般都是按照艺术家和唱片集的层次结构来组织分类的，所以组成员需要拥有能在同组其他成员创建的目录下创建文件和目录权限。需要把 bill 和 karen 使用的掩码值更改成 0002 。</li><li>第二个问题是，由成员创建的每一个文件和目录都将设置为归属于该用户的有效组，而不归属 music 组。可以通过对该目录设置 setgid 位来修复这个问题。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bill@linuxbox ~]$ sudo <span class="built_in">chmod</span> g+s /usr/local/share/Music</span><br><span class="line">[bill@linuxbox ~]$ sudo -ld /usr/local/share/Music</span><br><span class="line">drwxrwxr-x 2 root music 4096 2012-03-24 20:03 /usr/local/share/Music</span><br></pre></td></tr></table></figure></li><li>现在来测试一下，看看是否新的权限修复了这个问题。bill 把它的掩码值设置为 0002 ，删除了之前的测试文件，又创建了一个新的测试文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[bill@linuxbox ~]$ <span class="built_in">umask</span> 0002</span><br><span class="line">[bill@linuxbox ~]$ <span class="built_in">rm</span> /usr/local/share/Music/test_file</span><br><span class="line">[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_dir</span><br><span class="line">[bill@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/local/share/Music</span><br><span class="line">drwxrwxr-x 2 bill music 4096 2012-03-24 20:24 test_dir</span><br><span class="line">-rw-rw-r-- 1 bill music 0 2012-03-24 20:22 test_file</span><br><span class="line">[bill@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>当前创建的文件和目录都具有正确的权限，允许 music 组内的所有成员在 Music 目录下创建文件和目录。</li><li>最后剩下的一个问题是关于 umask 命令的。umask 命令设置的掩码值只能在当前 shell 会话中生效，在当前 shell 会话结束后，则必须重新设置。</li></ol><h2 id="更改用户密码"><a href="#更改用户密码" class="headerlink" title="更改用户密码"></a>更改用户密码</h2><ol><li>本章的最后一个主题就是用户如何为自己设置密码 (如果拥有超级用户权限，那么也可以为其他的用户设置密码) 。</li><li>使用 passwd ，可以设置或者更改密码。该命令的语法格式如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [user]</span><br></pre></td></tr></table></figure></li><li>如果更改的是用户自己的密码，那么只需要输入 passwd 命令。接下来 shell 将会提示用户输入旧密码和新密码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ passwd</span><br><span class="line">(current) UNI password:</span><br><span class="line">New UNIX password:</span><br></pre></td></tr></table></figure></li><li>passwd 命令会试着强迫用户使用强密码。也就是说，它会拒绝接受太短的密码、与之前的密码相似的密码、字典中的单词作为密码或者是太容易猜到的密码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ passwd</span><br><span class="line">(current) UNIX password:</span><br><span class="line">New UNIX password:</span><br><span class="line">BAD PASSWORD: is too similar to the old one</span><br><span class="line">New UNIX password:</span><br><span class="line">BAD PASSWORD: it is WAY too short</span><br><span class="line">New UNIX password:</span><br><span class="line">BAD PASSWORD: it is based on a dictionary word</span><br></pre></td></tr></table></figure></li><li>如果你具有超级用户的权限，那么可以通过指定一个用户名作为 passwd 命令的参数来为另一个用户设置密码。</li><li>对于超级用户，你还可以使用该命令的其他选项来设置账户锁定、密码失效等功能。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 高级键盘技巧</title>
      <link href="/post/fbd34a1b.html"/>
      <url>/post/fbd34a1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-高级键盘技巧"><a href="#第八章-高级键盘技巧" class="headerlink" title="第八章 高级键盘技巧"></a>第八章 高级键盘技巧</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>UNIX 被称为它是为喜欢敲键盘的人设计的系统。当然，UNIX 中存在命令行的这一事实充分证明了一点。</li><li>用户使用命令行时往往不喜欢敲入太多字，所以命令行中存在类似 cp、ls、mv 和 rm 的短命令。</li><li>事实上，省事 (即用最少的击键次数执行最多的任务) 是命令行最希望达到的目标之一。</li><li>命令行的另一个目标是，用户在执行任务时手指无需离开键盘，不使用鼠标。</li><li>我们将使用到以下命令：</li></ol><ul><li>clear: 清屏</li><li>history: 显示历史列表的记录</li></ul><h2 id="编辑命令行"><a href="#编辑命令行" class="headerlink" title="编辑命令行"></a>编辑命令行</h2><ol><li>基本介绍</li></ol><ul><li>bash 使用了一个名为 Readline 的库 (供不同的应用程序共享使用的线程集合) 来实现命令行的编辑。</li></ul><ol start="2"><li>光标移动</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl-A</td><td align="center">移动光标到行首</td></tr><tr><td align="center">Ctrl-E</td><td align="center">移动光标到行尾</td></tr><tr><td align="center">Ctrl-F</td><td align="center">光标向前移动一个字符；和右箭头键作用一样</td></tr><tr><td align="center">Ctrl-B</td><td align="center">光标向前移动一个字符；和左箭头键作用一样</td></tr><tr><td align="center">Alt-F</td><td align="center">光标向前移动一个字</td></tr><tr><td align="center">Alt-B</td><td align="center">光标向后移动一个字</td></tr><tr><td align="center">Ctrl-l</td><td align="center">清屏并把光标移到左上角；clear 命令可以完成相同工作</td></tr></tbody></table><ol start="3"><li>修改文本</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl-D</td><td align="center">删除光标处的字符</td></tr><tr><td align="center">Ctrl-T</td><td align="center">使光标处的字符和它前面的字符对调位置</td></tr><tr><td align="center">Alt-T</td><td align="center">使光标处的字符和它前面的字对调位置</td></tr><tr><td align="center">Alt-L</td><td align="center">把光标到字尾的字符换成小写字母形式</td></tr><tr><td align="center">Alt-U</td><td align="center">把光标到字尾的字符换成大写字母形式</td></tr></tbody></table><ol start="4"><li>剪切和粘贴文本</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl+K</td><td align="center">剪切从光标到行尾的文本</td></tr><tr><td align="center">Ctrl+U</td><td align="center">剪切从光标到行尾的文本</td></tr><tr><td align="center">Alt-D</td><td align="center">剪切从光标到当前词尾的文本</td></tr><tr><td align="center">Alt-Backspace</td><td align="center">剪切从光标到词头的文本。如果光标在一个单词，则剪切前一个单词</td></tr><tr><td align="center">Ctrl-Y</td><td align="center">把 kill-ring 缓冲区的文本粘贴到光标的位置</td></tr></tbody></table><h2 id="自动补齐功能"><a href="#自动补齐功能" class="headerlink" title="自动补齐功能"></a>自动补齐功能</h2><ol><li>基本介绍</li></ol><ul><li>shell 的一种称为自动补齐的机制为用户提供了很大的帮助。在输入命令时，按 Tab 键将触发自动补齐功能。 </li><li>假设用户目录如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop ls-output.txt Pictures Templates Videos</span><br><span class="line">Documents Music Public</span><br></pre></td></tr></table></figure></li><li>输入如下命令，但是不要按 Enter 键。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> l</span><br></pre></td></tr></table></figure></li><li>此时按 Tab 键：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> ls-output.txt</span><br></pre></td></tr></table></figure></li><li>再看另一个例子，同样也不要按 Enter 键。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> D</span><br></pre></td></tr></table></figure></li><li>按下 Tab 键：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> D</span><br></pre></td></tr></table></figure></li><li>没有自动补齐–只有哔哔声。这是因为字母 D 和目录一个以上的名称匹配。要让自动补齐功能生效，要保证输入的内容不模棱两可，即必须是确定性的。</li><li>如果我们继续输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> Do</span><br></pre></td></tr></table></figure></li><li>此时按下 Tab 键：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">ls</span> Documents </span><br></pre></td></tr></table></figure></li><li>自动补齐功能这次生效了。</li><li>自动补齐也可以针对变量 (如果单词是以 $ 开头) 、用户名 (如果单词以 ~ 开头) 、命令 (如果单词是命令行的第一个单词) 和主机名 (如果单词以 @ 开头) 起作用。</li><li>主机名的自动补齐只对 &#x2F;etc&#x2F;hosts 目录下的主机名生效。</li></ul><ol start="2"><li>自动补全命令</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Alt-$</td><td align="center">显示所有可能的自动补全列表。在大多数系统中，可通过按两次 Tab 键实现，而且也会更容易一些</td></tr><tr><td align="center">Alt-*</td><td align="center">插入所有可能的匹配项。当需要用到一个以上的匹配项时候，将比较有用</td></tr></tbody></table><h2 id="使用历史命令"><a href="#使用历史命令" class="headerlink" title="使用历史命令"></a>使用历史命令</h2><ol><li>基本介绍</li></ol><ul><li>第一章我们已经提到，bash 会保存使用过命令的历史记录。这些命令的历史记录列表保存在用户主目录的 .bash_history 文件中。</li><li>这些历史记录非常有用，可以大大减少用户敲打键盘的次数，特别是和命令行编辑结合使用的时候。</li></ul><ol start="2"><li>搜索历史命令</li></ol><ul><li>任何情况下，我们都可以通过如下命令查看历史记录内容列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure></li><li>bash 默认会保存用户最近使用过的 500 个命令。其中，500 是个默认值，关于如何改变这个默认值在第十一章介绍。</li><li>假设我们想找到用来列出 &#x2F;usr&#x2F;bin 目录下内容的命令，我们可以这样做：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">history</span> | grep /usr/bin</span><br></pre></td></tr></table></figure></li><li>假设得到的搜索结果中有一行包含如下有趣的命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88 <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>数字 88 表示这个命令行在历史记录列表中所处的行号，我们可以通过使用名为历史记录扩展 (history expansion) 的扩展类型来立即使用它。</li><li>为了使用我们发现的命令行，可以如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ !88</span><br></pre></td></tr></table></figure></li><li>bash 将把 !88 扩展为历史列表中的 88 行的内容。</li><li>bash 也支持以递增方式搜索历史记录。也就是说，当搜索历史记录时，随着输入字符数的增加，bash 会相应地改变搜索范围。</li><li>按下 Ctrl-R 键，接着输入你要查找的内容时，按 Enter 键表示执行此命令，而按 Ctrl-J 将把搜索到的内容从历史记录列表中复制到当前命令行。当要查找下一个匹配项时 (即向前搜索历史记录) ，再次按下 Ctrl-R 键。</li><li>请看下面例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>首先按下 Ctrl-R<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(reverse-i-search) <span class="string">&#x27;&#x27;</span>:</span><br></pre></td></tr></table></figure></li><li>提示符发生改变，提示正在进行逆向递增式搜索。称为逆向是因为查的是从现在到过去的某个时间之间的操作。</li><li>接下来，输入要查找的内容，这个例子中是查找 &#x2F;usr&#x2F;bin 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(reverse-i-search) <span class="string">&#x27;/usr/bin&#x27;</span>: <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt </span><br></pre></td></tr></table></figure></li><li>很快搜索操作返回了结果。此时我们可按 Enter 键执行搜索结果，也可按下 Ctrl-J 把搜索结果复制到当前命令行以便做进一步的编辑。</li><li>假定按下 Ctrl-J ，把搜索结果复制到当前命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>shell 将实时响应，命令行将被加载，准备运行。</li></ul><ol start="3"><li>历史记录命令</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl-p</td><td align="center">移动到前一条历史记录。相当于向上箭头键</td></tr><tr><td align="center">Ctrl-N</td><td align="center">移动到后一条历史记录。相当于向下箭头键</td></tr><tr><td align="center">Alt-&lt;</td><td align="center">移动到历史记录列表的开始处</td></tr><tr><td align="center">Alt-&gt;</td><td align="center">移动到历史记录列表的结尾处。即当前命令行</td></tr><tr><td align="center">Ctrl-R</td><td align="center">逆向递增地搜索。从当前命令行向前递增搜索</td></tr><tr><td align="center">Alt-P</td><td align="center">逆向非递增地搜索。按下这个组合键，接着输入待搜索的字符串，在按 Enter 键后，搜索才真正执行</td></tr><tr><td align="center">Alt-N</td><td align="center">向前非递增地搜索</td></tr><tr><td align="center">Ctrl-O</td><td align="center">执行历史记录列表中的当前项，执行完跳到下一项。若要把历史记录中的一系列命令重新执行一遍，使用该组合键将很方便</td></tr></tbody></table><ol start="4"><li>历史记录扩展命令</li></ol><table><thead><tr><th align="center">序列</th><th align="center">行为</th></tr></thead><tbody><tr><td align="center">!!</td><td align="center">重复最后一个执行的命令。按向上箭头再按 Enter 键也可以实现相同的功能，而且操作更简单</td></tr><tr><td align="center">!number</td><td align="center">重复历史记录中第 number 行的命令</td></tr><tr><td align="center">!string</td><td align="center">重复最近的以 string 开头的历史记录</td></tr><tr><td align="center">!？string</td><td align="center">重复最近的包含 string 的历史记录</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 透过 Shell 看世界</title>
      <link href="/post/ffbaef4b.html"/>
      <url>/post/ffbaef4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-透过-Shell-看世界"><a href="#第七章-透过-Shell-看世界" class="headerlink" title="第七章 透过 Shell 看世界"></a>第七章 透过 Shell 看世界</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在本章，我们将介绍在按下 Enter 键时，命令行中发生的一些神奇事情。</li><li>虽然我们会介绍 shell 的几个有趣而复杂的特性，但是我们只使用一条新命令来处理。</li></ol><ul><li>echo: 显示一行文本</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>每次输入命令行按下 Enter 键时，bash 都会执行之前的对文本进行多重处理。</li><li>前面已经见过一个简单的字符序列 (比如 * ) 在 shell 中被识别为多种意思的例子。产生这个结果的处理过程称为扩展 (expansion) 。</li><li>有了扩展功能，再输入内容后，这些内容将在 Shell 对其执行之前被扩展成其他内容。</li><li>echo 是 shell 的一个内置命令，它执行的任务非常简单，即把文本参数内容打印到标准输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li>上面例子相当简单，传递 echo 的任何参数都将显示出来。</li><li>我们可以看看另一个例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">echo</span> *</span><br><span class="line">Desktop Documents ls-output.txt Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure></li><li>* 字符意味着匹配文件名中的任意字符，shell 会在执行 echo 命令前把 * 扩展成其他内容 (在这个例子中，扩展为当前工作目录下的所有文件名) 。</li><li>在按下 Enter 键的时候，shell 会在执行命令前自动扩展命令行中所有符合条件的字符，因此，echo 命令将不可能看到 * 字符，只能看到 * 字符扩展后的结果。</li></ol><h3 id="路径名拓展"><a href="#路径名拓展" class="headerlink" title="路径名拓展"></a>路径名拓展</h3><ol><li>通过使用通配符来实现扩展机制称为路径名扩展 (pathname expansion) 。</li><li>尝试前面章节中使用过的一些技术，将会发现它们实际上就是扩展。下面给定一个主目录，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop ls-output.txt Pictures Templates</span><br><span class="line">Documents Music Public Videos</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> D*</span><br><span class="line">Desktop Documents</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> *s</span><br><span class="line">Documents Pictures Temolates Videos</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> [[:upper:]]*</span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> /usr/*/share</span><br><span class="line">/usr/kerberos/share /usr/local/share</span><br></pre></td></tr></table></figure></li></ol><h3 id="波浪线扩展"><a href="#波浪线扩展" class="headerlink" title="波浪线扩展"></a>波浪线扩展</h3><ol><li>回顾前面对 cd 命令的介绍，你会发现波浪线字符 ~ 具有特殊的含义。</li><li>如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户命名，则扩展为当前用户的主目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有指定用户</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> ~</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> ~foo</span><br><span class="line">/home/foo</span><br></pre></td></tr></table></figure></li></ol><h3 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h3><ol><li>基本介绍</li></ol><ul><li>shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $((<span class="number">2</span>+<span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li>算术扩展使用如下格式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$((expression))     <span class="comment">#  其中，expression 是包含数值和算术操作符的算术表达式</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>算术扩展操作符</li></ol><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">除 (但是记住，因为扩展只支持整数运算，所以结果也是整数)</td></tr><tr><td align="center">%</td><td align="center">取余，即余数</td></tr><tr><td align="center">**</td><td align="center">取幂</td></tr></tbody></table><ol start="3"><li>算术扩展使用细节</li></ol><ul><li>空格在算术表达式中是没有意义的，而且表达式是可以嵌套的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(($((<span class="number">5</span>**<span class="number">2</span>))*3))</span><br></pre></td></tr></table></figure></li><li>你可以使用一对括号来组合多个子表达式。通过该技术，可以把上面的例子重写，用一个扩展来替代两个，可以得到同样的结果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(((<span class="number">5</span>**<span class="number">2</span>)*<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li><li>下面的例子使用了除运算符和取余运算符，注意整数相除的结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> Five divided by two equals $((<span class="number">5</span>/<span class="number">2</span>))</span><br><span class="line">Five divided by two equals 2</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> with $((<span class="number">5</span>%<span class="number">2</span>)) left over.</span><br><span class="line">with 1 left over.</span><br></pre></td></tr></table></figure></li></ul><h3 id="花括号扩展"><a href="#花括号扩展" class="headerlink" title="花括号扩展"></a>花括号扩展</h3><ol><li>花括号扩展 (brace expansion) 可能算是最奇怪的扩展方式了。有了它，你可以按照花括号里面的模式创建多种文本字符串。实例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br></pre></td></tr></table></figure></li><li>用于花括号扩展的模式信息可以包含一个称为前导字符 (preamble) 的开头部分和一个称为附言 (postscript) 的结尾部分。</li><li>花括号表达式本身可以包含一系列逗号分隔符的字符串，也可以包含一系列整数或者单个字符。这里的模式信息不能包含内嵌的空白。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br></pre></td></tr></table></figure></li><li>下面输出一系列逆序排列的字母。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> &#123;Z..A&#125;</span><br><span class="line">Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br></pre></td></tr></table></figure></li><li>花括号最普遍的应用是创建一系列的文件或者目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> Pics</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> Pics</span><br><span class="line">[me@linuxbox Pics]$ <span class="built_in">mkdir</span> &#123;2009..2010&#125;-0&#123;1..9&#125; &#123;2009..2010&#125;-&#123;10..12&#125;</span><br><span class="line">[me@linuxbox Pics]$ <span class="built_in">ls</span></span><br><span class="line">2009-01 2009-07 2010-01 2010-07</span><br><span class="line">2009-02 2009-08 2010-02 2010-08</span><br><span class="line">2009-03 2009-09 2010-03 2010-09</span><br><span class="line">2009-04 2009-10 2010-04 2010-10</span><br><span class="line">2009-05 2009-11 2010-05 2010-11</span><br><span class="line">2009-06 2009-12 2010-06 2010-12</span><br></pre></td></tr></table></figure></li></ol><h3 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a>参数扩展</h3><ol><li>参数扩展用在 shell 脚本中比直接用在命令行中更为有用。</li><li>它的许多特性与系统存储小块数据以及给每小块数据命令的性能有关。很多这样的小块数据 (称为变量 [variable] 会更合适) 可用于扩展。</li><li>例如，命名为 USER 的变量包含你的用户名，为了触发参数扩展，并显示出 USER 的内容，你可以进行如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">me</span><br></pre></td></tr></table></figure></li><li>想要查看可用的变量列表，试试如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printenv</span> | less</span><br></pre></td></tr></table></figure></li><li>对于其他的扩展类型来说，如果你误输入了一个模式，就不会发生扩展，这时 echo 命令将只是显示这些误输入的模式信息。但是对于参数扩展来说，如果变量名拼写错误，仍然会进行扩展，只不过结果是输出一个空字符串而已，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$SUER</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li></ol><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><ol><li>命令替换可以把一个命令的输出作为一个扩展模式使用，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(<span class="built_in">ls</span>)</span><br><span class="line">Desktop Documents ls-output.txt Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure></li><li>另外一种用法：<br>[me@linuxbox ~]$ ls -l $(which cp)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp</span><br></pre></td></tr></table></figure></li><li>这里，把 which cp 命令的运行结果作为 ls 命令的一个参数，因此我们无需知道 cp 程序的完整路径就能获得 cp 程序对应的列表。</li><li>这个功能并不只是局限于简单的命令，也可以应用于整个管道中 (只不过只显示部分输出内容) 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ file $(<span class="built_in">ls</span> /usr/bin* | grep zip)</span><br><span class="line">/usr/bin/bunzip2: symbolic <span class="built_in">link</span> to <span class="string">&#x27;bzip2&#x27;</span></span><br><span class="line">/usr/bin/bzip2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs)，<span class="keyword">for</span> GNU/Linux 2.69, stripped</span><br></pre></td></tr></table></figure></li><li>在早期的 shell 程序中，存在命令替换的另一种语法，bash 也支持这种格式。它用反引号替代美元符号和括号，具体如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l `<span class="built_in">which</span> <span class="built_in">cp</span>`</span><br><span class="line">-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp</span><br></pre></td></tr></table></figure></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>shell 有多种方式可以执行扩展，现在我们来学习如何控制扩展。先看下面的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> this  is a <span class="built_in">test</span></span><br><span class="line">this is <span class="built_in">test</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> The total is <span class="variable">$100</span>.00</span><br><span class="line">The total is 00.00</span><br></pre></td></tr></table></figure></li><li>在第一个例子，shell 会对 echo 命令的参数列表进行单词分割 (word splitting) ，去除多余的空白。在第二个例子中，因为 $1 是一个未定义的变量，所以参数扩展把 $1 的值替换为空字符串。</li><li>shell 提供了一种称为引用 (quoting) 的机制，用来选择性地避免不想要的扩展。</li></ol><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><ol><li>我们要看的第一种引用类型是双引号 (double quote) 。</li><li>如果把文本放在双引号中，那么 shell 使用的所有特殊字符都将失去他们的特殊含义，而被看成普通字符。字符 $(美元符号)、(反斜杠)、&#96;(反引号) 除外。</li><li>这就意味着单词分割、路径名扩展、波浪线扩展和花括号扩展都将失效，但是参数扩展、算术扩展、命令替换仍然生效。</li><li>使用双引号能够处理文件名中包含空白的情况。</li><li>假设不幸地有一个名为 two words.txt 的文件，如果在命令行中使用该文件名，那么单词分割功能将把它当成两个独立的参数，而不是当成我们希望的单个参数，具体运行结果如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l two words.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access two: No such file or directory</span><br><span class="line"><span class="built_in">ls</span>: cannot access words.txt: No such file or directory</span><br></pre></td></tr></table></figure></li><li>使用双引号可以阻止单词分割，得到预期的效果。另外，使用双引号甚至可以修复破损的文件名，参考下面的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l <span class="string">&quot;two words.txt&quot;</span></span><br><span class="line">-rw-rw-r-- 1 me me 18 2012-02-20 13:03 two words.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> <span class="string">&quot;two words.txt&quot;</span> <span class="string">&quot;two_words.txt&quot;</span></span><br></pre></td></tr></table></figure></li><li>参数扩展、算术扩展和命令替换在双引号中依然生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$USER</span> <span class="subst">$((2+2)</span>) <span class="subst">$(cal)</span>&quot;</span></span><br><span class="line">me 4 February 2012</span><br><span class="line">Su  Mo Tu We Th Fr Sa</span><br><span class="line">           1  2  3  4</span><br><span class="line"> 5   6  7  8  9 10 11</span><br><span class="line"> 12 13 14 15 16 17 18</span><br><span class="line"> 19 20 21 22 23 24 25</span><br><span class="line"> 26 27 28 29</span><br></pre></td></tr></table></figure></li><li>默认情况下，单词分割会先查找是否存在空格、制表符以及换行 (换行字符) ，然后把它们当作单词见的界定符 (delimiter) 。这就意味着没有用引号包含起来的空格、制表符和换行字符都不会被当成文本的一部分，而只是被当成分割符。</li><li>单词分割机制会把换行字符当成界定符，这一点在命令替换将会产生微妙有趣的效果。参考下面例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(cal)</span><br><span class="line">February 2012 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cal)</span>&quot;</span></span><br><span class="line">    February 2012</span><br><span class="line">Su  Mo Tu We Th Fr Sa</span><br><span class="line">           1  2  3  4</span><br><span class="line"> 5   6  7  8  9 10 11</span><br><span class="line"> 12 13 14 15 16 17 18</span><br><span class="line"> 19 20 21 22 23 24 25</span><br><span class="line"> 26 27 28 29</span><br></pre></td></tr></table></figure></li><li>在第一个例子中，没有加上引号的命令替换将导致命令行被识别为命令后面跟 38 个参数；而在第二个例子中加了双引号，使得命令行被识别为命令后面只跟一个参数，这个参数包含着嵌入空格和换行字符。</li></ol><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><ol><li>如果我们希望抑制所有扩展，那么应使用单引号。下面是不使用引号、使用双引号和使用单引号的情况对比。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> text ~/*.txt &#123;a,b&#125; $(<span class="built_in">echo</span> foo) $((<span class="number">2</span>+<span class="number">2</span>)) <span class="variable">$USER</span></span><br><span class="line">text /home/me/ls-output.txt a b foo 4 me</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;text ~/*.txt &#123;a,b&#125; <span class="subst">$(echo foo)</span> <span class="subst">$((2+2)</span>) <span class="variable">$USER</span>&quot;</span></span><br><span class="line">text ~/*.txt &#123;a,b&#125; foo 4 me</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;</span></span><br><span class="line">text ~/*.txt &#123;a,b&#125; $(<span class="built_in">echo</span> foo) $((<span class="number">2</span>+<span class="number">2</span>)) <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li><li>可以看到，随着引用级别的加强，越来越多扩展将被抑制。</li></ol><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ol><li>基本介绍</li></ol><ul><li>有时候我们只是想要引用单个字符，这种情况可以通过在该字符前加上反斜杠来实现。这里的反斜杠称为转义字符。</li><li>转义字符经常在双引号中用来有选择性地组织扩展。如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The balance for user <span class="variable">$USER</span> is: \$5.00&quot;</span></span><br><span class="line">The balance <span class="keyword">for</span> user <span class="variable">$USER</span> is: <span class="variable">$5</span>.00</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>转义字符也常用来消除文件名中某个字符的特殊含义。</li><li>比如，文件名中可以使用在 shell 中通常具有特殊含义的字符。这些字符包括 $、!、&amp;、空格等。想要在文件名中包含特殊字符，可执行如下操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> bad\&amp;filename good_filename</span><br></pre></td></tr></table></figure></li><li>如果想要显示反斜杠字符，可以通过使用两个反斜杠 \\ 来实现。</li></ol><ul><li>反斜杠转义字符序列</li></ul><table><thead><tr><th align="center">转义字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">响铃 (警告声-计算机发出哔哔声音)</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\n</td><td align="center">新的一行 (在类 UNIX 系统中，产生的是换行效果)</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\t</td><td align="center">制表</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 重定向</title>
      <link href="/post/544753df.html"/>
      <url>/post/544753df.html</url>
      
        <content type="html"><![CDATA[<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章我们将要探讨命令行最酷的功能- I&#x2F;O 重定向。</li><li>I&#x2F;O 是输入&#x2F;输出 (input&#x2F;output) 的缩写。这个功能可以把命令行的输入的重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中。</li><li>如果我们将多个命令行关联起来，将形成非常强大的命令-管道。</li><li>本章的主要命令：</li></ol><ul><li>cat: 合并文件</li><li>sort: 对文本进行排序</li><li>uniq: 报告或删除文件中的重复的行 </li><li>wc: 打印文件中的换行符、字和字节的个数 </li><li>grep: 打印匹配行 </li><li>head: 输出文件的第一部分内容 </li><li>tail: 输出文件的最后一部分内容 </li><li>tee: 读取标准输入的数据，并将其内容输出到标准输出和文件中</li></ul><h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>目前为止，我们使用过的很多程序生成不同种类的输出。</li><li>这些输出通常包含两种类型。一种是程序运行的结果，即该程序生成的数据；另一种是状态和错误信息，表示程序当前的运行情况。</li><li>比如输入 ls 命令，屏幕上将显示它的运行结果以及它的相关错误信息。</li><li>与 UNIX 系统一切都是文件的思想一致，类似 ls 的程序实际上把它们的运行结果发送到一个称为标准输出 (standard output，通常称为 stdout) 的特殊文件中，它们的状态信息则发送到另一个成为标准错误 (standard error，表示为 stderr) 的文件中。</li><li>默认情况下，标准输出和标准错误都将被链接到屏幕上，并且不会被保存在磁盘文件中。</li><li>另外，许多程序从一个称为标准输入 (standard input，表示为 stdin) 的设备来输入。默认情况下，标准输入连接到键盘。</li><li>I&#x2F;O 重定向功能可以改变输出内容发送的目的地，也可以改变输入内容的来源地。</li><li>通常来说，输出内容显示在屏幕上，输入内容来自于硬盘，但是使用 I&#x2F;O 重定向功能可以改变这一惯例。</li></ol><h3 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h3><ol><li>I&#x2F;O 重定向功能可以重新定义标准输出内容发送到哪里。</li><li>使用重定向操作符 &gt; ，后面接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上。它主要用于把命令的输出内容保存到一个文件中</li><li>比如，我们可以按照下面的形式把 ls 命令的输出保存到 ls-output.txt 文件中，而不是输出到屏幕上<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>这里，我们将创建 &#x2F;usr&#x2F;bin 目录的一个长列表信息，并把这个结果输出到 ls-output.txt 文件中。</li><li>检查下该命令被重定向的输出内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 167878 2012-02-01 15:07 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>如果使用 less 命令查看这个文件，我们可以看到 ls-output.txt 文件确定包含了 ls 命令的执行结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less ls-output.txt</span><br></pre></td></tr></table></figure></li><li>现在，让我们重复重定向测试，但是这次做一点变换。我们把目录名称换成一个不存在的目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr &gt; ls-output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access /bin/usr: No such file or directory</span><br></pre></td></tr></table></figure></li><li>我们会收到一条错误信息。因为我们指定的是一个不存在的目录 &#x2F;bin&#x2F;usr&#x2F; ，所以这个错误信息是正确的。</li><li>这个错误信息显示在屏幕上，而不是重定向到 ls-output.txt 文件中的原因：ls 程序并不会把它运行的错误信息发送到标准输出文件中。</li><li>而是与大多数写得很好的 UNIX 程序一样，它把错误信息发送到标准错误文件中。因为我们只重定向了标准输出，并没有重定向标准错误，所以这个错误信息仍然输出在屏幕上。</li><li>我们首先看看这个输出文件发生的变化。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2012-02-01 15:08 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>当前这个文件大小为零。这是因为当使用重定向符 &gt; 来重定向标准输出时，目的文件通常会从文件开头部分重新改写。由于 ls 命令执行后没有输出任何内容，只显示一条错误信息，所以重定向操作开始重新改写这个文件，并在出现错误的情况下停止操作，最终导致了该文件内容被删除。</li><li>事实上，如果我们需要删除一个文件内容 (或创建一个新的空文件) ，可以采用这样的方式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>仅仅使用了重定向符，并在它之前不加任何命令，就可以删除一个已经存在的文件内容或者创建一个新的空文件。</li><li>如果我们想不从文件的首位置开始覆盖文件，而是从文件的尾部开始添加输出内容，可以使用重定向符 &gt;&gt; 来实现，比如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>使用重定向符 &gt;&gt; 将使得输出内容添加在文件的尾部。如果这个文件并不存在，将与操作符 &gt; 的作用一样创建这个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 503634 2012-02-01 15:45 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>重复执行这条命令三次，系统将最终生成一个为原来三倍大小的输出文件。</li></ol><h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><ol><li>标准错误的重定向并不能简单地使用一个专用的重定向符来实现。要实现标准错误的重定向，不得不提到它的文件描述符 (file descriptor) 。</li><li>一个程序可以把生成的输出内容发送任意文件流中。</li><li>如果把这些文件流中的前三个分别对应标准输入文件、标准输出文件和标准错误文件，那么 shell 将在内部用文件描述符分别索引它们为 0 ，1 和 2 。</li><li>shell 提供了使用文件描述编号来重定向文件的表示法。由于标准错误等同于文件描述符 2 ，所以可以使用这种表示法来重定向标准错误。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure></li><li>文件描述符 2 紧放在重定向符之前，将标准错误重定向到 ls-error.txt 文件中。</li></ol><h3 id="将标准输出和标准错误重定向到同一个文件"><a href="#将标准输出和标准错误重定向到同一个文件" class="headerlink" title="将标准输出和标准错误重定向到同一个文件"></a>将标准输出和标准错误重定向到同一个文件</h3><ol><li>在许多情况下，我们会希望把一个命令的所有输出内容都放在同一个独立的文件中。为此，我们必须同时重定向标准输出和标准错误。</li><li>有两种方法可以满足要求，第一种是传统的方法，在旧版本的 shell 中使用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li><li>使用这种方法，将执行两个重定向操作。首先重定向标准输出和标准输出到 ls-output.txt 文件中，然后使用标记符 2&gt;&amp;1 把文件描述符 2(标准错误) 重定向到文件描述符 1(标准输出) 中。</li><li>注意：这些重定向操作的顺序是非常重要的。标准错误的重定向通常发生在标准输出重定向之后，否则它将不起作用。</li><li>在上面的例子中，&gt;ls-output.txt 2&gt;&amp;1 把标准错误重定向到 ls-output.txt 文件中，但是如果顺序改变为 2&gt;&amp;1 &gt;ls-output.txt ，那么标准错误将会重定向到屏幕上。</li><li>最近的 bash 版本提供了效率更高的第二种方法来实现这一联合的重定向操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>这个例子中，只使用一个标记符 &amp;&gt; 就把标准输出和标准错误都重定向到了 ls-output.txt 文件中。</li></ol><h3 id="处理不想要的输出"><a href="#处理不想要的输出" class="headerlink" title="处理不想要的输出"></a>处理不想要的输出</h3><ol><li>有时候沉默是金，命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。</li><li>系统提供了一种方法，即通过把输出重定向到一个称为 &#x2F;dev&#x2F;null 的特殊文件中来实现它。</li><li>这个文件是一个称为位桶 (bit bucket) 的系统设备，它接受输入但是不对输入进行任何处理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure></li></ol><h3 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h3><ol><li>cat - 合并文件</li></ol><ul><li>cat 命令读取一个或多个文件，并把它们复制到标准输出文件中，格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [file...]</span><br></pre></td></tr></table></figure></li><li>在大多数情况下，你可以认为 cat 命令和 DOS 中的 TYPE 命令类似。使用它显示文件而不需要分页，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox]$ <span class="built_in">cat</span> ls-output.txt</span><br></pre></td></tr></table></figure></li><li>上面命令将显示 ls-output.txt 文件的内容。cat 经常用来显示短的文本文件</li><li>由于 cat 可以接受多个文件作为输入参数，所以它也可以用来把文件连接在一起</li><li>假设我们下载了一个很大的文件，它已被拆分为多个部分 (Usenet 上的多媒体文件经常采用拆分是这种方式) ，现在我们想要把各部分连接在一起，并还原为原来文件</li><li>如果这些文件命名为 moive.mpeg.001 movie.mpeg.002…movie.mpeg.099 ，我们可以使用这个命令让它们重新连接在一起<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></table></figure></li><li>通配符一般都是按照顺序来扩展的，因此这些参数将正确的顺序来排序</li><li>如果输入 cat 命令却不带任何参数，它将从标准输入读取内容。由于标准输入在默认情况下是连接到键盘，所以实际上它正在等待着从键盘输入内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span></span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>下一步，按下 Ctrl-D (按住 Ctrl 键同时按下 D) ，告知 cat 命令它已经达到了标准输入的文件尾 (end-of-file, EOF) <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span></span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>在缺少文件名参数的情况下，cat 把标准输入内容复制到标准输出文件中，因此我们将可以看到文本行重复显示。用这种方法我们可以创建短的文本文件</li><li>如果想要创建一个名叫 lazy_dog.txt 的文件，文件中包含之前例子中的文本内容，我们可以这样做：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>在 cat 命令后输入想要放在文件中的文本内容。记住在文件结束时按下 Ctrl-D 。为了看到结果，我们可以使用 cat 命令再次把文件复制到标准输出文件中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>现在我们已经知道 cat 命令除了接受文件名参数之外，是如何接受标准输入的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &lt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>使用重定向符 &lt; ，我们把标准输入的源从键盘变成 lazy_dog.txt 文件</li><li>可以看到，得到的结果和只传递单个文件名参数结果一样。和传输一个文件名参数的方式作对比，这种方式并不是特别有用，但是可以用来说明把一个文件作为标准输入的源文件</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>命令从标准输入到读取数据，并将数据发送到标准输出的能力，是使用了名为管道的 shell 特性。</li><li>使用管道操作符 | (竖线) 可以把一个命令的标准输出传送到另一个命令的标准输入中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command1 | Command2</span><br></pre></td></tr></table></figure></li><li>使用 less 命令可以分页显示任意命令的输入，该命令将它的结果发送到标准输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | less</span><br></pre></td></tr></table></figure></li><li>通过使用该技术，可以很方便地检查任意一条生成标准输出的命令的运行结果。</li></ol><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ol><li>管道功能经常用来对数据执行复杂的操作。也可以多条命令合在一起构成一个管道。这种方式中用到的命令通常被称为过滤器 (filter) 。</li><li>过滤器接受输入，按照某种方法对输入进行改变，然后输出它。</li><li>第一个要用到的命令是 sort 。假设要把 &#x2F;bin 和 &#x2F;usr&#x2F;bin 目录下的所有可执行程序合并成一个列表，并且按照顺序排列，最后再查看这个列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span> | less</span><br></pre></td></tr></table></figure></li><li>由于我们指定了两个目录 (&#x2F;bin 和 &#x2F;usr&#x2F;bin) ， ls 的输出将包含两个排好序的列表，每个对应一个目录。</li><li>通过在管道中包含 sort 命令，我们改变输出数据，从而产生一个排好序的列表。</li></ol><h3 id="uniq-报告或忽略文件中的重复行"><a href="#uniq-报告或忽略文件中的重复行" class="headerlink" title="uniq - 报告或忽略文件中的重复行"></a>uniq - 报告或忽略文件中的重复行</h3><ol><li>uniq 命令经常和 sort 命令结合使用。</li><li>uniq 可以接受来自于标准输入或者一个单一文件名参数对应的已排好序的数据列表 (可以查看 uniq 命令的 man 页面获取详细信息) 。默认情况下，该命令删除列表中的所有重复行。</li><li>因此，在管道中添加 uniq 命令，可以确保所有列表都没有重复行(即在 &#x2F;bin 和 &#x2F;usr&#x2F;bin 目录下都出现的相同名字的任意程序)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> | less</span><br></pre></td></tr></table></figure></li><li>在这个例子中，我们使用了 uniq 命令来删除来自 sort 命令输出内容中的任意重复行。</li><li>如果反过来想要查看重复行的列表，可以再 uniq 命令后面添加 -d 选项，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> -d | less</span><br></pre></td></tr></table></figure></li></ol><h3 id="wc-打印行数、字数和字节数"><a href="#wc-打印行数、字数和字节数" class="headerlink" title="wc - 打印行数、字数和字节数"></a>wc - 打印行数、字数和字节数</h3><ol><li>wc (字数，word count) 命令用来显示文件中包含的行数、字数和字节数。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">wc</span> ls-output.txt</span><br><span class="line">7902 64566 503634 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>上面例子中，我们打印输出了三个数据，即 ls-output.txt 文件中包含的行数、字数和字节数。</li><li>和前面的命令一样，如果在执行 wc 时没有输入命令行参数，它将接受标准输入内容。</li><li>-l 选项限制命令只报告行数，把它添加在管道中可以很方便地实现计数功能。</li><li>如果我们要查看已排序的列表中的条目数，可以按照以下方式输入。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li></ol><h3 id="grep-打印匹配行"><a href="#grep-打印匹配行" class="headerlink" title="grep - 打印匹配行"></a>grep - 打印匹配行</h3><ol><li>grep 是一个功能强大的程序，它用来在文件中查找匹配文本，其使用方式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern [file...]</span><br></pre></td></tr></table></figure></li><li>当 grep 在文件中遇到模式的时候，就打印出包含该模式的行。 </li><li>grep 能够匹配的模式内容可以是非常复杂的，不过这里，我们只关注简单文本的匹配。</li><li>如果想我们从列出的程序中搜索出文件中包含 zip 的所有文件，该搜索将获悉系统中与文件压缩的相关程序，操作如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br></pre></td></tr></table></figure></li><li>grep 存在一对的选项：-i ，该选项使得 grep 在搜索时忽略大小写 (通常情况下，搜索区分大小写) ；-v ，该选项使得 grep 只是输出和模式不匹配的行。</li></ol><h3 id="head-x2F-tail-打印文件的开头部分"><a href="#head-x2F-tail-打印文件的开头部分" class="headerlink" title="head&#x2F;tail - 打印文件的开头部分"></a>head&#x2F;tail - 打印文件的开头部分</h3><ol><li>有的时候，你并不需要命令输出的所有内容，可能只是需要开头几行或者最后几行。</li><li>head 命令将输出文件的前 10 行，tail 命令则输出文件的最后 10 行。默认情况下，这两条命令都是输出文件的 10 行内容，不过可以使用 -n 选项来调整输出的行数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> -n 5 <span class="built_in">ls</span> ls-output.txt</span><br><span class="line">total 343496</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2011-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2011-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2011-11-26 14:27 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2010-10-06 20:16 a52dec</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">tail</span> -n 5 ls-output.txt</span><br><span class="line">-rwxr-xr-x 1 root root 5234 2011-06-27 10:56 znew</span><br><span class="line">-rwxr-xr-x 1 root root 691 2009-09-10 04:21 zonetab2pot.py</span><br><span class="line">-rw-r--r-- 1 root root 930 2011-11-01 12:23 zonetab2pot.pyc</span><br><span class="line">-rw-r--r-- 1 root root 930 2011-11-01 12:23 zonetab2pot.pyo</span><br><span class="line">1rwxrwxrwx 1 root root 6 2012-01-31 05:22 zsoelim -&gt; soelim</span><br></pre></td></tr></table></figure></li><li>这些命令选项也可以应用在管道中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">tail</span> -n 5</span><br><span class="line">zonetab2pot.py</span><br><span class="line">zonetab2pot.pyc</span><br><span class="line">zonetab2pot.pyo</span><br><span class="line">zsoelim</span><br></pre></td></tr></table></figure></li><li>tail 中有一个选项用来实时查看文件，该选项在观察正在被写入的日志文件的进展状态时很有用。</li><li>在下面的例子中，我们将观察 &#x2F;var&#x2F;log 目录下的 messages 文件。</li><li>因为 &#x2F;var&#x2F;log&#x2F;messages 文件可能包含安全信息，所以在一些 Linux 发行版本中，需要有超级用户的权限才能执行该操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure></li><li>使用 -f 选项，tail 将持续监视这个文件，一旦添加了新行，新行就会立即显示在屏幕上。该动作在按下 Ctrl-c 命令后停止。</li></ol><h3 id="tee-从-stdin-读取数据，并同时输出到-stdout-和文件"><a href="#tee-从-stdin-读取数据，并同时输出到-stdout-和文件" class="headerlink" title="tee - 从 stdin 读取数据，并同时输出到 stdout 和文件"></a>tee - 从 stdin 读取数据，并同时输出到 stdout 和文件</h3><ol><li>为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令。就好像安装了一个 T 在管道上。</li><li>tee 程序读取标准输入，再把读到的内容复制到标准输出 (允许数据可以继续向下传递到管理中) 和一个或多个的文件中去。</li><li>当在某个中间处理阶段来捕获一个管道中的内容时，会很有用。我们使用 tee 命令来获取整个目录列表并输出到 ls.txt 文件中，具体操作如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">tee</span> ls.txt | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 命令的使用</title>
      <link href="/post/e0f4dded.html"/>
      <url>/post/e0f4dded.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-命令的使用"><a href="#第五章-命令的使用" class="headerlink" title="第五章 命令的使用"></a>第五章 命令的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章中介绍的命令如下：</li></ol><ul><li>type: 说明如何解释命令名</li><li>which: 显示会执行哪些可执行程序</li><li>man: 显示命令的手册页</li><li>apropos: 显示一系列合适的命令</li><li>info: 显示命令的info条目</li><li>whatis: 显示一条命令的简述</li><li>alias: 创建一条命令的别名</li></ul><h2 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h2><ol><li>可执行程序</li></ol><ul><li>可执行程序就像在 &#x2F;usr&#x2F;bin 目录里看到的所有文件一样。</li><li>在该程序类别中，程序可以编译为二进制文件，比如 C、C++ 语言编写的程序，也可以是 Shell、Perl、Python、Ruby 等脚本语言编写的程序。</li></ul><ol start="2"><li>shell 内置命令</li></ol><ul><li>bash 支持许多在内部称之为 shell builtin 的内置命令。</li></ul><ol start="3"><li>shell 函数</li></ol><ul><li>shell 函数是合并到环境变量中的小型 shell 脚本。</li></ul><ol start="4"><li>alias 命令</li></ol><ul><li>我们可以在其他命令的基础上定义自己的命令。</li></ul><h2 id="识别命令"><a href="#识别命令" class="headerlink" title="识别命令"></a>识别命令</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>能够准确地识别我们使用的命令是上述 4 种命令类型中的哪一种是很有用的。</li></ul><h3 id="type-显示命令的类型"><a href="#type-显示命令的类型" class="headerlink" title="type - 显示命令的类型"></a>type - 显示命令的类型</h3><ol><li><p>type 命令是一个 shell 内置命令，可根据指定的命令名显示 shell 将要执行的命令类型。格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>这里的 command 是想要查看的命令名。一些实例如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">type</span> <span class="built_in">type</span></span><br><span class="line"><span class="built_in">type</span> is s shell <span class="built_in">builtin</span></span><br><span class="line">[me@linux ~]$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is aliased to <span class="string">&#x27;ls --color=tty&#x27;</span></span><br><span class="line">[me@linux ~]$ <span class="built_in">type</span> <span class="built_in">cp</span></span><br><span class="line"><span class="built_in">cp</span> is /bin/cp</span><br></pre></td></tr></table></figure></li></ol><h3 id="which-显示可执行程序的位置"><a href="#which-显示可执行程序的位置" class="headerlink" title="which - 显示可执行程序的位置"></a>which - 显示可执行程序的位置</h3><ol><li>有时候，系统可能会安装了一个可执行程序的多个版本。这种现象虽然在桌面系统中不常见，但是在大型服务器中却是很常见。</li><li>使用 which 命令可以确定一个给定可执行文件的准确位置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">which</span> <span class="built_in">ls</span></span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure></li><li>which 命令只适用于可执行程序，而不适用于内置命令和命令别名 (真正可执行程序的替代物) 。</li><li>试图在 shell 内置命令中使用 which 命令时，要么没有响应，要么得到一条错误信息。</li></ol><h2 id="获得命令文档"><a href="#获得命令文档" class="headerlink" title="获得命令文档"></a>获得命令文档</h2><h3 id="help-获得-shell-内置命令的帮助文档"><a href="#help-获得-shell-内置命令的帮助文档" class="headerlink" title="help - 获得 shell 内置命令的帮助文档"></a>help - 获得 shell 内置命令的帮助文档</h3><ol><li>bash 为每一个 shell 内置命令提供了一个内置的帮助工具。输入 help ，然后输入 shell 内置命令的名称即可使用该帮助工具<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">help</span> <span class="built_in">cd</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="man-显示程序的手册页"><a href="#man-显示程序的手册页" class="headerlink" title="man - 显示程序的手册页"></a>man - 显示程序的手册页</h4><ol><li>man 基本介绍</li></ol><ul><li>大多数供命令行使用的可执行文件，提供了一个称之为 manual 或者是 man page 的正式文档。 </li><li>该文档可以用一种称为 man 的特殊的分页程序来查看，用法如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man program </span><br></pre></td></tr></table></figure></li><li>手册文档在格式上会有所不同，但通常都包括标题、命令句法的摘要、命令用途的描述、命令选项列表以及每个命令选项的描述。 </li><li>例如，尝试查看 ls 命令的手册文档<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li>在大多数 Linux 系统中，man 命令调用 less 命令来显示手册文档。所以，当显示手册文档时，你熟悉的所有 less 命令都能奏效</li><li>man 命令显示的手册文档被分成多个部分，它不仅包括用户命令，也包括系统管理命令、程序接口、文件格式等</li></ul><ol start="2"><li>man 手册文档的组织结构</li></ol><table><thead><tr><th align="center">部分</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">用户命令</td></tr><tr><td align="center">2</td><td align="center">内核系统调用的程序接口</td></tr><tr><td align="center">3</td><td align="center">C 库函数程序接口</td></tr><tr><td align="center">4</td><td align="center">特殊文件，如设备节点和驱动程序</td></tr><tr><td align="center">5</td><td align="center">文件格式</td></tr><tr><td align="center">6</td><td align="center">游戏和娱乐，例如屏幕保护程序</td></tr><tr><td align="center">7</td><td align="center">其他杂项</td></tr><tr><td align="center">8</td><td align="center">系统管理命令</td></tr></tbody></table><h3 id="apropos-显示合适的命令"><a href="#apropos-显示合适的命令" class="headerlink" title="apropos - 显示合适的命令"></a>apropos - 显示合适的命令</h3><ol><li>我们有可能会搜索参考手册列表，才进行基于某个搜索条目的匹配。尽管有些粗糙，但是这种方法又是还是很有用的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ apropos floppy</span><br></pre></td></tr></table></figure></li></ol><h3 id="whatis-显示命令的简要描述"><a href="#whatis-显示命令的简要描述" class="headerlink" title="whatis - 显示命令的简要描述"></a>whatis - 显示命令的简要描述</h3><ol><li>whatis 程序显示匹配具体关键字的手册页的名字和一行描述。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ whatis <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="info-显示程序的-info-条目"><a href="#info-显示程序的-info-条目" class="headerlink" title="info - 显示程序的 info 条目"></a>info - 显示程序的 info 条目</h3><ol><li>info 基本介绍</li></ol><ul><li>GNU 项目提供了 info 页面来替代手册文档。 </li><li>info 页面可通过 info 阅读器来显示。 </li><li>info 页面使用超链接，这与网页结构很相似。 </li><li>info 程序读取 info 文件，该文件是树形结构，分为各个单独的节点，每一个节点包含一个主题。 </li><li>info 文件包含的超链接可以实现节点间的跳转。 </li><li>通过前置星号可以识别超链接，将光标放在超链接上并按 Enter 键，可以激活它。 </li><li>可以通过输入 info 以及程序名来调用 info 。 </li><li>到目前为止，我们讨论的大部分命令行程序都是 GNU 项目 coreutils 包的一部分，输入以下内容可以看到更多信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ info coreutils</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>info 页面控制指令</li></ol><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">显示命令帮助</td></tr><tr><td align="center">PAGE UP or BACKSPACE</td><td align="center">返回上一页</td></tr><tr><td align="center">PAGE DOWN or Space</td><td align="center">翻到下一页</td></tr><tr><td align="center">n</td><td align="center">Next - 显示下一个节点</td></tr><tr><td align="center">p</td><td align="center">Previous - 显示上一个节点</td></tr><tr><td align="center">u</td><td align="center">Up - 显示目前显示节点的父节点</td></tr><tr><td align="center">ENTER</td><td align="center">进入光标所指的超链接</td></tr><tr><td align="center">q</td><td align="center">退出</td></tr></tbody></table><h3 id="README-和其他程序文档文件"><a href="#README-和其他程序文档文件" class="headerlink" title="README 和其他程序文档文件"></a>README 和其他程序文档文件</h3><ol><li>系统中安装的很多软件包都有自己的文档文件，它们存放在 &#x2F;usr&#x2F;share&#x2F;doc 目录中。</li><li>其中大部分文档文件是以纯文本格式存储的，因此可以用 less 命令来查看。有些文件是 HTML 格式，并且可以用 Web 浏览器来查看。</li><li>我们可能会遇到一些以 .gz 扩展名结尾的文件。这表明它们是使用 gzip 压缩程序压缩过。</li><li>gzip 包包含一个特殊的 less 版本，称之为 zless 。</li><li>zless 可以显示由 gzip 压缩的文本文件的内容。</li></ol><h2 id="使用别名创建自己的命令"><a href="#使用别名创建自己的命令" class="headerlink" title="使用别名创建自己的命令"></a>使用别名创建自己的命令</h2><ol><li>alias 基本介绍</li></ol><ul><li><p>我们可以通过使用分号来分隔多条命令，就可以将多条命令输入在一行中。其工作方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1;command2;command3...</span><br></pre></td></tr></table></figure></li><li><p>我们将要使用的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr;<span class="built_in">ls</span>;<span class="built_in">cd</span> -</span><br><span class="line">bin games kerberos lib64 <span class="built_in">local</span> share tmp</span><br><span class="line">etc include lib libexec sbin src</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li><p>可以看到，我们将 3 条命令放置在同一行中。首先我们将当前目录改变成 &#x2F;usr ，然后列出这个目录内容，最后返回到原始目录 (使用 cd- ) 。那么程序结束的位置恰恰是开始的位置 </p></li><li><p>我们通过使用 alias 命令将以上命令整合成一条新的命令。首先要为新命令虚构出一个名称，试试名称 test 。不过输入前，我们最好检查一下名称 test 是否已经被使用过了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure></li><li><p>这个名字已经用过了，试试 foo 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">bash:<span class="built_in">type</span>:foo:not found</span><br></pre></td></tr></table></figure></li><li><p>下面创建新命令的别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">alias</span> foo = <span class="string">&#x27;cd /usr;ls;cd -&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>上面的命令结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> name=<span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在 alias 命令之后输入 name ，紧接着是一个等号 (没有空格) ，等号之后是一个用单引号括起来的字符串，该字符串中的内容赋值给 name</p></li><li><p>尝试别名命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo</span><br><span class="line">bin games kerberos lib64 <span class="built_in">local</span> share tmp</span><br><span class="line">etc include lib libexec sbin src</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li><p>再次使用 type 命令来查看别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">foo is aliased to <span class="string">&#x27;cd /usr;ls;cd -&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>要删除别名，可以使用 unalias 命令，如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">unalias</span> foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">bash:<span class="built_in">type</span>:foo:nou found</span><br></pre></td></tr></table></figure></li><li><p>尽管我们有意避免使用已经存在的命名名称来给我们的别名命名，但有时也会期待这么做。这样做的目的是，为每一个经常调用的命令添加一个普遍会用到的选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is aliased to <span class="string">&#x27;ls --color=tty&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>查看环境中定义的所有别名，可使用不带参数的 alias 命令。以下是 Fedora 系统默认定义的一些别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll = <span class="string">&#x27;ls -l --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span> = <span class="string">&#x27;ls --color=tty&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 操作文件与目录</title>
      <link href="/post/4ad1077e.html"/>
      <url>/post/4ad1077e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-操作文件与目录"><a href="#第四章-操作文件与目录" class="headerlink" title="第四章 操作文件与目录"></a>第四章 操作文件与目录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章将介绍如下命令：</li></ol><ul><li>cp: 复制文件和目录 </li><li>mv: 移动或重命名文件和目录 </li><li>mkdir: 创建目录 </li><li>rm: 移除文件和目录 </li><li>ln: 创建硬链接和符号连接</li></ul><ol start="2"><li>以上 5 个命令属于最常使用 Linux 命令之列，可用来操作文件与目录。</li><li>坦率地说，使用图形文件管理器来执行一些由这些命令执行的任务要容易多。使用文件管理器，我们可以将文件从一个目录拖放到另一个目录，我们可以剪切和粘贴文件，我们可以删除文件。</li><li>使用命令行程序的原因是其具有强大的功能和灵活的操作。</li><li>虽然使用图形文件管理器能轻松实现简单的文件操作，但是对于复杂的任务，使用命令行程序更容易完成。</li><li>例如，将所有 HTML 文件从一个目录复制到目标目录，要完成这个任务，使用文件管理器则相当困难，而使用命令行则很容易。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -u *.html destination</span><br></pre></td></tr></table></figure></li></ol><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ol><li>基本介绍</li></ol><ul><li>在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell 特性</li><li>由于 shell 需要经常使用文件名，因此它提供了一些特殊字符来帮助你快速指定一组文件名，这些特殊字符称为通配符</li><li>通配符 (也叫文件名替换) 允许用户依据字符模式选择文件名</li><li>通配符的使用使得为文件名构建复杂的筛选标准成为可能</li></ul><ol start="2"><li>通配符以及它们所选择的对象</li></ol><table><thead><tr><th align="center">通配符</th><th align="center">匹配项</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配任意多个字符(包括 0 个和 1 个)</td></tr><tr><td align="center">?</td><td align="center">匹配任意单个字符(不包括 0 个)</td></tr><tr><td align="center">[characters]</td><td align="center">匹配任意一个属于字符集中的字符</td></tr><tr><td align="center">[!characters]</td><td align="center">匹配任意一个不属于字符集中的字符</td></tr><tr><td align="center">[[:class:]]</td><td align="center">匹配任意一个属于指定字符类中的字符</td></tr></tbody></table><ol start="3"><li>通配符的字符类</li></ol><table><thead><tr><th align="center">字符类</th><th align="center">匹配项</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">匹配任意一个字符或数字</td></tr><tr><td align="center">[:alpha:]</td><td align="center">匹配任意一个字母</td></tr><tr><td align="center">[:digit:]</td><td align="center">匹配任意一个数字</td></tr><tr><td align="center">[:lower:]</td><td align="center">匹配任意一个小写字母</td></tr><tr><td align="center">[:upper:]</td><td align="center">匹配任意一个大写字母</td></tr></tbody></table><ol start="4"><li>通配符模式及其匹配内容</li></ol><table><thead><tr><th align="center">形式</th><th align="center">匹配项</th></tr></thead><tbody><tr><td align="center">g*</td><td align="center">以 g 开头的任一文件</td></tr><tr><td align="center">b*.txt</td><td align="center">以 b 开头，中间有任意多个字符，并以 .txt 结尾的任一文件</td></tr><tr><td align="center">Data???</td><td align="center">以 Data 开头，后面跟三个字符的任一文件</td></tr><tr><td align="center">[abc]*</td><td align="center">以 abc 中任一开头的任一文件</td></tr><tr><td align="center">BACKUP.[0-9][0-9][0-9]</td><td align="center">以 BACKUP. 开头，后面紧跟 3 个数字的任一文件</td></tr><tr><td align="center">[[:upper:]]*</td><td align="center">以大学字母开头的任一文件</td></tr><tr><td align="center">[![:digit:]]</td><td align="center">不以数字开头的任一文件</td></tr><tr><td align="center">*[[:lower:123]]</td><td align="center">以小写字母或数字 1、2、3 中的任一结尾的文件</td></tr></tbody></table><h2 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir - 创建目录"></a>mkdir - 创建目录</h2><ol><li>mkdir 基本介绍</li></ol><ul><li>mkdir 命令是是用来创建目录的，格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory...</span><br></pre></td></tr></table></figure></li><li>创建单个 dir1 目录，输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1</span><br></pre></td></tr></table></figure></li><li>输入以下命令可以创建 3 个目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1 dir2 dir3</span><br></pre></td></tr></table></figure></li></ul><h2 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp - 复制文件和目录"></a>cp - 复制文件和目录</h2><ol><li>cp 基本介绍</li></ol><ul><li>cp 文件用来复制文件和目录，它有两种不同的使用方式。 </li><li>将单个文件或目录 item1 复制到文件或目录 item2 中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item1 item2</span><br></pre></td></tr></table></figure></li><li>将多个项目(文件或目录)复制进一个目录中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item... directory</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>cp 命令选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-a, --archive</td><td align="center">复制文件和目录及其属性，包括所有权和权限。通常来说，复制的文件具有用户所操作文件的默认属性</td></tr><tr><td align="center">-i, --interactive</td><td align="center">在覆盖一个已存在的文件前，提示用户进行确认。如果没有指定该选项，cp 会默认覆盖文件</td></tr><tr><td align="center">-r, --recursive</td><td align="center">递归地复制目录及其内容。复制目录时需要这个选项 (或 -a 选项)</td></tr><tr><td align="center">-u, --update</td><td align="center">当将文件从一个目录复制到另一个目录时，只会复制那些目标目录中不存在的文件或是目标目录相应文件的更新文件</td></tr><tr><td align="center">-v, --verbose</td><td align="center">复制文件时，显示信息性消息 (informative message)</td></tr></tbody></table><ol start="3"><li>cp 命令示例</li></ol><table><thead><tr><th align="center">命令</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">cp file1 file2</td><td align="center">将 file1 复制到 file2 。如果 file2 存在，则会被 file1 的内容覆盖。如果 file2 不存在，则创建 file2</td></tr><tr><td align="center">cp -i file1 file2</td><td align="center">同上，区别在于当 file2 存在时，覆盖之前通知用户确认</td></tr><tr><td align="center">cp file1 file2 dir1</td><td align="center">将 file1 和 file2 复制到目录 dir1 里。dir1 必须已经存在</td></tr><tr><td align="center">cp dir1&#x2F;* dir2</td><td align="center">通过使用通配符，将 dir1 中的所有文件复制到 dir2 中。dir2 必须已经存在</td></tr><tr><td align="center">cp -r dir1 dir2</td><td align="center">将 dir1 目录 (及其内容) 复制到 dir2 目录中。如果 dir2 不存在，创建 dir2 ，且包含与 dir1 目录相同的内容</td></tr></tbody></table><h2 id="mv-移除和重命名文件"><a href="#mv-移除和重命名文件" class="headerlink" title="mv - 移除和重命名文件"></a>mv - 移除和重命名文件</h2><ol><li>mv 基本介绍</li></ol><ul><li>mv 命令可以执行文件移动和文件重命名操作，这具体取决于如何使用它。在这两种情况下，完成操作之后，原来的文件名将不存在</li><li>mv 的使用方法与 cp 基本相似。将文件 (或目录) item1 移动 (或重命名) 为 item2 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item1 item2</span><br></pre></td></tr></table></figure></li><li>将一个或多个条目从一个目录移动到另一个目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item... directory</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>mv 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-i, --interactive</td><td align="center">覆盖一个已存在的文件之前，提示用户确认。如果没有指定该选项，mv 会默认覆盖文件</td></tr><tr><td align="center">-u, --update</td><td align="center">将文件从一个目录移动到另一个目录，只移动那些目标目录中不存在的文件或是目标目录里相应文件的更新文件</td></tr><tr><td align="center">-v, --verbose</td><td align="center">移动文件时显示信息性消息</td></tr></tbody></table><ul><li>mv 示例</li></ul><table><thead><tr><th align="center">命令</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">mv file1 file2</td><td align="center">将 file1 移到 file2 。如果 file2 存在，则会被 file1 的内容覆盖。如果 file2 不存在，则创建 file2 。无论哪一种情况，file1 不再存在</td></tr><tr><td align="center">mv -i file1 file2</td><td align="center">同上，仅当 file2 存在时，覆盖之前通知用户确认</td></tr><tr><td align="center">mv file1 file2 dir1</td><td align="center">将 file1 和 file2 移动目录 dir1 下。dir1 必须已经存在</td></tr><tr><td align="center">mv dir1 dir2</td><td align="center">将目录 dir1 (和其他内容) 移到目录 dir2 下。如果目录 dir2 不存在，创建目录 dir2 ，将目录 dir1 的内容移到 dir2 下，同时删除目录 dir1</td></tr></tbody></table><h2 id="rm-删除文件和目录"><a href="#rm-删除文件和目录" class="headerlink" title="rm - 删除文件和目录"></a>rm - 删除文件和目录</h2><ol><li>rm 基本介绍</li></ol><ul><li>rm 命令用来移除 (删除文件) 和目录，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> item ...</span><br></pre></td></tr></table></figure></li><li>其中 item 是一个或多个文件 (或目录) 的名称。</li></ul><ol start="2"><li>rm 常用选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-i, --interactive</td><td align="center">删除一个已经存在的文件前，提示用户确认。如果没有指定这个选项，rm 命令会默认删除文件</td></tr><tr><td align="center">-r, --recursive</td><td align="center">递归地删除目录。也就是说，如果删除的目录有子目录的话，也要将其删除。要删除一个目录，则必须指定该选项</td></tr><tr><td align="center">-f, --force</td><td align="center">忽略不存在的文件并无需提示确认。该选项会覆盖 --interactive</td></tr><tr><td align="center">-v, --verbose</td><td align="center">删除文件时显示信息性消息</td></tr></tbody></table><ol start="3"><li>rm 常用实例</li></ol><table><thead><tr><th align="center">命令</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">rm file1</td><td align="center">在不提示用户的情况下，删除 file1</td></tr><tr><td align="center">rm -i file1</td><td align="center">删除 file1 前，提示用户确认</td></tr><tr><td align="center">rm -r file1 dir1</td><td align="center">删除 file1、dir1 以及它们的内容</td></tr><tr><td align="center">rm -rf file1 dir1</td><td align="center">同上，当在 file1 或 dir1 不存在时，rm 仍会继续执行，且不提示用户</td></tr></tbody></table><h2 id="ln-创建链接"><a href="#ln-创建链接" class="headerlink" title="ln - 创建链接"></a>ln - 创建链接</h2><ol><li>ln 概述</li></ol><ul><li>ln 命令可用来创建硬链接或是符号链接。它的使用方式有两种：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建硬链接</span></span><br><span class="line"><span class="built_in">ln</span> file <span class="built_in">link</span></span><br><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line"><span class="built_in">ln</span> -s item <span class="built_in">link</span>   <span class="comment"># 这里的 item 可以是文件也可以是目录。</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>硬链接</li></ol><ul><li>硬链接是最初 UNIX 用来创建链接的方式，符号链接较之更为先进。</li><li>默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，也为这个文件创建了一个额外的目录条目。</li><li>硬链接有两条重要的局限性：<ul><li>硬链接不能引用自身文件系统之外的文件</li><li>硬链接无法引用目录</li></ul></li><li>硬链接和文件本身没有什么区别。与包含符号链接的目录列表不同，包含硬链接的目录列表没有特别的链接指示说明。</li><li>当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在 (也就是说，该空间没有释放) ，除非该文件的所有链接都被删除了。</li></ul><ol start="3"><li>符号链接</li></ol><ul><li>符号链接是为了克服硬链接的局限性而创建的。</li><li>符号链接是通过创建一个特殊类型的文件来起作用的，该文件包含了指向引用文件或目录的文本指针</li><li>符号链接指向的文件与符号链接自身几乎没有区别</li><li>当删除一个符号链接时，删除的只是符号链接而没有删除文件本身</li><li>如果先于符号链接之前删除文件，那么这个链接依然存在，但却不指向任何文件。此时这个链接称为坏链接</li></ul><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><ol><li>概述</li></ol><ul><li>由于我们要做一些实际的文件操作，我们先来创建一个安全的地带，来执行文件操作命令</li><li>首先，我们需要一个工作目录。我们在主目录里创建一个目录并命名为 playground</li></ul><ol start="2"><li>创建目录</li></ol><ul><li>mkdir 命令用来创建一个目录。为了创建 playground 目录，我们首先要保证当前目录是主目录，然后再创建新目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> playground</span><br></pre></td></tr></table></figure></li><li>在 playground 目录中新建两个目录，命名为 dir1 、 dir2</li><li>切换工作目录为 playground ，然后再次执行 mkdir 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> playground</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">mkdir</span> dir1 dir2</span><br></pre></td></tr></table></figure></li><li>需要注意的是， mkdir 命令可以接受多个参数，从而允许我们用一个命令创建两个目录</li></ul><ol start="3"><li>复制文件</li></ol><ul><li>接下来，让我们在创建的目录中放入一些数据，这一过程可以通过文件复制来完成</li><li>通过使用 cp 命令，我们可以将 &#x2F;etc 目录中的 passwd 文件复制到当前工作目录里<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> /etc/passwd .</span><br></pre></td></tr></table></figure></li><li>如果我们此时执行 ls 命令，将会看到我们的文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir2</span><br><span class="line">-rw-r--r-- 1 me me 1650 2012-01-10 16:07 passwd</span><br></pre></td></tr></table></figure></li><li>现在让我们使用 -v 选项，重复操作复制命令，来看看结果如何<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> -v /etc/passwd .</span><br><span class="line"><span class="string">&#x27;/etc/passwd&#x27;</span> -&gt; <span class="string">&#x27;.passwd&#x27;</span></span><br></pre></td></tr></table></figure></li><li>cp 命令再次执行复制操作，但是，这一次显示了一条简洁的信息来指明它正在执行什么操作。</li><li>需要注意的是，在没有任何警告的情况下，cp 命令覆盖了第一次的复制内容。</li><li>cp 命令会假定用户清楚自己当前的操作，加上 -i 选项可以获得警告信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> -i /etc/passwd .</span><br><span class="line"><span class="built_in">cp</span>: overwrite <span class="string">&#x27;./passwd&#x27;</span>?</span><br></pre></td></tr></table></figure></li><li>通过在提示符下输入 y ，文件就会被重写；任何其他的字符会使 cp 命令保留该文件。</li></ul><ol start="4"><li>移动和重命名文件</li></ol><ul><li>现在，passwd 这个名字似乎没有那么有趣，而我们毕竟是在进行实战演练，因此我们给它改个名字。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> passwd fun</span><br></pre></td></tr></table></figure></li><li>现在传送 fun 文件，这是通过将重命名的文件移动到各个目录，然后再移动回当前目录来实现的。<ul><li>首先移到目录 dir1 下，然后：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> fun dir1</span><br></pre></td></tr></table></figure></li><li>将文件从目录 dir1 移到 dir2 ，然后：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1/fun dir2</span><br></pre></td></tr></table></figure></li><li>再将文件 fun 重新移到当前工作目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir2/fun .</span><br></pre></td></tr></table></figure></li></ul></li><li>下面来看 mv 命令的效果。首先，再次将数据文件移到目录 dir1<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> fun dir1</span><br></pre></td></tr></table></figure></li><li>然后将目录 dir1 移到 dir2 并且使用 ls 命令确认<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1 dir2</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir2</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-11 06:06 dir1</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir2/dir1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 me me 1650 2012-01-10 16:33 fun</span><br></pre></td></tr></table></figure></li><li>注意，因为目录 dir2 已经存在，mv 命令将目录 dir1 移到 dir2</li><li>如果 dir2 不存在，mv 将 dir1 重命名为 dir2 。最后，我们将所有东西放回原处<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir2/dir1 .</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1/fun .</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>创建硬链接</li></ol><ul><li><p>现在，我们试着创建一些链接。首先是创建硬链接，我们先按照如下方式创建一些指向数据文件的链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun dir1/fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun dir2/fun-hard</span><br></pre></td></tr></table></figure></li><li><p>目前有 4 个文件 fun 的实例。来看一下 playground 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br></pre></td></tr></table></figure></li><li><p>可以注意到，在列表中，文件 fun 和 fun-hard 的第二个字段都是 4 ，这是文件 fun 存在的硬链接数目</p></li><li><p>由于文件名是由链接创建的，所以一个文件通常至少有一个链接。</p></li><li><p>提到硬链接时，可以想象文件是由两部分组成的，即包含文件内容的数据部分和包含文件名的名称部分。创建硬链接时，实际上是创建了额外的名称，这些名称都指向同一数据部分</p></li><li><p>系统分配了一系列的盘块给所谓的索引节点 (inode) ，该节点随后与文件名称部分建立关联。因此，每个硬链接都指向包含文件内容的具体索引节点</p></li><li><p>ls 命令有一种显示上述信息的方法。它是通过在命令中加上 -i 选项来实现的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 16</span><br><span class="line">12353539 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1</span><br><span class="line">12353540 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2</span><br><span class="line">12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br></pre></td></tr></table></figure></li><li><p>在上面列表中，第一个字段就是索引节点号，可以看到，fun 和 fun-hard 共享同一个索引节点号，这就证实它们是相同的文件。</p></li></ul><ol start="6"><li>创建符号链接</li></ol><ul><li>之所以创建符号链接，是为了克服硬链接的两大不足，即硬链接无法跨越物理设备，也无法引用目录，只能引用文件</li><li>符号链接是一种特殊类型的文件，它包含了指向目标文件或目录的文本指针</li><li>创建符号链接与创建硬链接相似，如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s fun fun-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s ../fun dir1/fun-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s ../fun dir2/fun-sym</span><br></pre></td></tr></table></figure></li><li>创建符号链接时，同时也创建一个文本来描述目标文件与符号链接有关联<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br><span class="line">lrwxrwxrwx 1 me me 6 2012-01-15 15:17 fun-sym -&gt; ../fun</span><br></pre></td></tr></table></figure></li><li>在目录 dir1 中， fun-sym 的列表显示它是一个符号链接，这是通过第 1 个字段中的首字符 1 来确认的，并且它也指 ..&#x2F;fun ，这也是正确的</li><li>相对于 fun-sym 的实际位置，文件 fun 在它的上一级目录。还要注意到，符号链接文件的长度是 6 ，这是 ..&#x2F;fun 字符串中字符的数字，而不是它所指向的文件的长度</li><li>创建符号链接时，可以使用绝对路径名，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s /home/me/playground/fun dir1/fun-sym</span><br></pre></td></tr></table></figure></li><li>也可以使用相对路径，如前面示例所示</li><li>因为相对路径允许包含符号链接的目录被重命名&#x2F;或移动，而且不会破坏链接，因此会更可取一些</li><li>除了普通文件之外，符号链接也可以引用目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s dir1 dir1-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br><span class="line">lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>移除文件和目录</li></ol><ul><li>前面讲到，使用 rm 命令可以删除文件和目录。那么我们就用它来清空 playground 目录</li><li>首先，我们删除目录中的一个硬链接<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br><span class="line">-rw-r--r-- 3 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure></li><li>文件 file-hard 被删除了，文件 fun 的连接数相应的也由 4 变成了 3</li><li>接下来，我们删除文件 fun ，我们还会加上 -i 选项，看看执行了哪些操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> -i fun</span><br><span class="line"><span class="built_in">rm</span>: remove regular file <span class="string">&#x27;fun&#x27;</span>?</span><br></pre></td></tr></table></figure></li><li>在提示符下输入字符 y ，文件就被删除了。现在看一下 ls 命令的输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 8</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br><span class="line">lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure></li><li>由于 fun-sym -&gt; fun 是一个符号链接，且指向的文件现在已经不存在，所以链接也就被破坏了。</li><li>如果试图调用破坏的链接，将会看到如下情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ less fun-sym</span><br><span class="line">fun-sym: No such file or directory</span><br></pre></td></tr></table></figure></li><li>稍微清理一下，删除符号链接<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> fun-sym dir1-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br></pre></td></tr></table></figure></li><li>有关于符号链接，需要记住一点，即大部分文件操作是以链接目标为对象的，而非链接本身 </li><li>而 rm 命令是个例外。当删除一个链接的时候，链接本身被删除，但是目标文件依旧存在</li><li>最后，我们需要删除目录 playground 。为此，我们将返回主目录，使用 rm 命令的递归选项 (-r) 来删除 playground 目录以及包括子目录在内的所有内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> -r playground</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 Linux 基本系统</title>
      <link href="/post/2cc576b7.html"/>
      <url>/post/2cc576b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-基本系统"><a href="#Linux-基本系统" class="headerlink" title="Linux 基本系统"></a>Linux 基本系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>既然已经知道了如何在文件系统中跳转，是时候开始 Linux 操作系统之旅了。</li><li>在开始之前，我们要先学习一些对研究 Linux 系统很有帮助的命令。</li></ol><ul><li>ls: 列出目录内容</li><li>file: 确定文件类型</li><li>less: 查看文件内容</li></ul><h2 id="ls-命令的乐趣"><a href="#ls-命令的乐趣" class="headerlink" title="ls 命令的乐趣"></a>ls 命令的乐趣</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>有充足的理由证明， ls 命令很可能是用户最常用的命令。</li><li>通过 ls 命令可以查看目录内容，确定各种重要文件和目录的属性。</li><li>我们已经看到，只需输入 ls 命令，即可查看当前工作目录中包含的一系列文件和子目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos </span><br></pre></td></tr></table></figure></li><li>除了当前工作目录之外，我们还可以指定要显示的，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr</span><br><span class="line">bin  games   kerberos libexec  sbin  src</span><br><span class="line">etc  include lib      <span class="built_in">local</span>    share tmp</span><br></pre></td></tr></table></figure></li><li>我们甚至可以指定多个目录。下面这个例子就列出了用户主目录(由符号 ~ 表示)和 &#x2F;usr 目录的内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> ~ /usr</span><br><span class="line">/home/me:</span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos </span><br><span class="line">/usr:</span><br><span class="line">bin  games   kerberos libexec  sbin   src</span><br><span class="line">etc  include lib      <span class="built_in">local</span>    share  tmp</span><br></pre></td></tr></table></figure></li><li>我们也可以改变输出格式来得到更多细节。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 56</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Desktop</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Documents</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Music</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Pictures</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Public</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Templates</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Videos</span><br></pre></td></tr></table></figure></li><li>在命令中加上 -l ，我们可以将输入以长格式显示。</li></ol><h3 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数"></a>选项和参数</h3><ol><li>ls 选项和参数</li></ol><ul><li>通常，命令后面跟有一个或多个选项，带有不同选项的命令其功能也不一样。 </li><li>此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象。 </li><li>大部分命令看起来如右所示： command -options arguments </li><li>大部分命令使用的选项是在单个字符前加上连字符，如 -l 。 </li><li>但是，很多命令，包括 GNU 项目里的命令，也支持在单字前加两个连字符的长选项。而且，很多命令也允许多个短选项串在一起使用。 </li><li>在下面的例子中， ls 命令包含了两个选项； l 选项产生长格式输出，而 t 选项则表示以文件修改时间的先后将结果进行排序。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure></li><li>加上长选项 --reverse ，则结果会以相反的顺序输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -lt --reverse</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>ls 常用选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">长选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">--all</td><td align="center">列出所有文件，包括以点号开头的文件，这些文件通常是不列出来的(比如隐藏的文件)</td></tr><tr><td align="center">-d</td><td align="center">--directory</td><td align="center">通常，如果指定了一个目录，ls 命令会列出目录中的内容而不是目录本身。将此选项与 -l 选项结合使用，可查看目录的详细信息，而不是目录中的内容</td></tr><tr><td align="center">-F</td><td align="center">--classify</td><td align="center">选项会在每个所列出的名字后面加上类型指示符(例如，如果名字是目录名，则会加上一个斜杠)</td></tr><tr><td align="center">-h</td><td align="center">--human-readable</td><td align="center">以长格式列出，以人们可读的方式而不是字节数来显示文件大小</td></tr><tr><td align="center">-l</td><td align="center"></td><td align="center">使用长格式显示结果</td></tr><tr><td align="center">-r</td><td align="center">--reverse</td><td align="center">以相反的顺序显示结果。通常， ls 命令按照字母升序排列显示结果</td></tr><tr><td align="center">-S</td><td align="center"></td><td align="center">按文件大小对结果排序</td></tr><tr><td align="center">-t</td><td align="center"></td><td align="center">按修改时间排序</td></tr></tbody></table><h3 id="进一步了解长列表格式"><a href="#进一步了解长列表格式" class="headerlink" title="进一步了解长列表格式"></a>进一步了解长列表格式</h3><ol><li>ls 长列表格式</li></ol><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-rw-r-r–</td><td align="center">对文件的访问权限。第一个字符表示文件的类型。在不同类型之间，开头的 - 表示该文件是一个普通文件，d 表示目录。紧接着的三个字符表示文件所有者的访问权限，再接着的三个字符表示文件所有者访问权限，再接着的三个字符</td></tr><tr><td align="center">1</td><td align="center">文件硬链接数目</td></tr><tr><td align="center">root</td><td align="center">文件所有者的用户名</td></tr><tr><td align="center">root</td><td align="center">文件所属用户组的名称</td></tr><tr><td align="center">32059</td><td align="center">以字节数表示的文件大小</td></tr><tr><td align="center">2012-04-03 11:05</td><td align="center">上次修改文件的日期和时间</td></tr><tr><td align="center">00-cd-cover.odf</td><td align="center">文件名</td></tr></tbody></table><h2 id="使用-file-命令确定文件类型"><a href="#使用-file-命令确定文件类型" class="headerlink" title="使用 file 命令确定文件类型"></a>使用 file 命令确定文件类型</h2><ol><li>在我们探索系统的过程中，知道文件包含的内容是非常有用的。为此，我们可以使用 file 命令来确定文件类型。</li><li>Linux 系统中的文件名不需要反映文件的内容，我们可以这样调用 file 命令： file filename ，调用后， file 命令会打印文件内容的简短说明。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ file picture.jpg</span><br><span class="line">picture.jpg: JPEG image data, JFIF standard 1.01</span><br></pre></td></tr></table></figure></li><li>文件的种类有很多。事实上，在类 UNIX 操作系统中，有个普遍的观念是所有的东西都是一个文件。</li></ol><h2 id="使用-less-命令查看文件内容"><a href="#使用-less-命令查看文件内容" class="headerlink" title="使用 less 命令查看文件内容"></a>使用 less 命令查看文件内容</h2><ol><li>less 基本内容</li></ol><ul><li>less 命令是一种查看文本文件的程序，less 程序为我们查看文件提供方便。 </li><li>less 命令的使用方式如右： less filename </li><li>一旦运行起来，less 程序允许我们前后滚动文件。 </li><li>例如，想要查看定义了系统用户账户的文件，可输入下面命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less /etc/passwd</span><br></pre></td></tr></table></figure></li><li>一旦 less 程序运行起来，我们就可查看文件内容。</li><li>如果文件不止一页，可以上下滚动文件，按 Q 键可退出 less 程序。</li></ul><ol start="2"><li>less 键盘命令</li></ol><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">PAGE UP 或 b</td><td align="center">后翻一页</td></tr><tr><td align="center">PAGE DOWN 或 Space</td><td align="center">前翻一页</td></tr><tr><td align="center">向上箭头</td><td align="center">向上一行</td></tr><tr><td align="center">向下箭头</td><td align="center">向下一行</td></tr><tr><td align="center">G</td><td align="center">跳转到文本文件的末尾</td></tr><tr><td align="center">lG 或 g</td><td align="center">跳转到文本文件的开头</td></tr><tr><td align="center">&#x2F;characters</td><td align="center">向前查找指定的字符串</td></tr><tr><td align="center">n</td><td align="center">向前查找下一个出现的字符串，这个字符串是之前的所指定查找的</td></tr><tr><td align="center">h</td><td align="center">显示帮助屏幕</td></tr><tr><td align="center">q</td><td align="center">退出 less</td></tr></tbody></table><h2 id="快速浏览"><a href="#快速浏览" class="headerlink" title="快速浏览"></a>快速浏览</h2><ol><li>基本介绍</li></ol><ul><li>在 Linux 系统中，文件系统布局与其他类 UNIX 系统很相似。 </li><li>实际上，一个已经发布的名为 Linux 文件系统层次标准 (Linux Filesystem Hierarchy Standard) 的标准，已经详细阐述了这个设计。 </li><li>并不是所有 Linux 发行版都严格符合该标准，但大部分与之很接近。 </li><li>接下来，我们将通过对文件系统的探索来找到 Linux 系统的正常运行所依赖的基础，请尝试下面的步骤： <ul><li>使用 cd 命令进入一个给定的目录 </li><li>使用 ls -l 命令列出目录的内容 </li><li>如果看到一个感兴趣的文件，使用 file 命令确定文件内容 </li><li>如果文件看起来像一个文本，试着使用 less 命令浏览其内容</li></ul></li></ul><ol start="2"><li>Linux 基本目录</li></ol><table><thead><tr><th align="center">目录</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">&#x2F;</td><td align="center">根目录，一切从这里开始</td></tr><tr><td align="center">&#x2F;bin</td><td align="center">包含系统启动和运行所必需的二进制文件、包含 Linux 内核、最初的 RAM 磁盘映像(系统启动时，驱动程序会用到)，以及启动加载程序</td></tr><tr><td align="center">&#x2F;boot</td><td align="center">有趣的文件：&#x2F;boot&#x2F;grub&#x2F;grub.conf 或 menu.lst，&#x2F;boot&#x2F;vmlinuz，Linux 内核</td></tr><tr><td align="center">&#x2F;dev</td><td align="center">这是一个包含设备节点的特殊目录。把一切当成文件也适用于设备，内核将它能够识别的所有设备存放在这个目录</td></tr><tr><td align="center">&#x2F;etc</td><td align="center">&#x2F;etc 目录包含了所有系统层面的配置文件，同时也包含了一系列 shell 脚本，系统每次启动时，这些 shell 脚本都会打开每个系统服务。该目录中包含的内容都应该是可读的文本文件。</td></tr><tr><td align="center">&#x2F;home</td><td align="center">在通常的配置中，每个用户都会在 &#x2F;home 目录中拥有一个属于自己的目录。普通用户只能在自己的主目录中创建文件。这一限制可以保护系统免遭错误的用户行为的破坏。</td></tr><tr><td align="center">&#x2F;lib</td><td align="center">包含核心程序系统使用的共享库文件。这与 Windows 系统中的 DLL 类似</td></tr><tr><td align="center">&#x2F;lost+found</td><td align="center">每个使用 Linux 文件系统的格式化分区或设备，例如 ext3 文件系统，都会有这个目录。当文件系统崩溃时，该目录用于恢复分区。除非系统真的发生很严重的问题，否则这个目录一直是空的。</td></tr><tr><td align="center">&#x2F;media</td><td align="center">在现代 Linux 系统中，&#x2F;media 目录包含可移除媒体设备的挂载点。比如 USB 驱动、CD-ROM 等。这些设备在插入计算机后，会自动挂载到这个目录节点下。</td></tr><tr><td align="center">&#x2F;mnt</td><td align="center">在早期 Linux 系统中，&#x2F;mnt 目录包含手动挂载的可移除设备的挂接点</td></tr><tr><td align="center">&#x2F;opt</td><td align="center">&#x2F;opt 目录用来安装其他可选的软件。主要用来存放可能安装在系统中的商业软件</td></tr><tr><td align="center">&#x2F;proc</td><td align="center">&#x2F;proc 目录很特殊。从文件的角度来说，它不是存储在硬盘中的真正的文件系统，反而是一个 Linux 内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。该文件是可读的，从中可以看到内核是如何监管计算机的</td></tr><tr><td align="center">&#x2F;root</td><td align="center">root 账户的主目录</td></tr><tr><td align="center">&#x2F;sbin</td><td align="center">该目录放置系统二进制文件。这些程序执行重要的系统任务，这些任务通常是为超级用户预留的。</td></tr><tr><td align="center">&#x2F;tmp</td><td align="center">&#x2F;tmp 是供用户存放各类程序创建的临时文件的目录。某些配置使得每次系统重启时会清空该目录</td></tr><tr><td align="center">&#x2F;usr</td><td align="center">&#x2F;usr 目录可能是 Linux 系统中最大的目录树。它包含普通用户使用的所有程序和相关文件</td></tr><tr><td align="center">&#x2F;usr&#x2F;bin</td><td align="center">&#x2F;usr&#x2F;bin 目录中放置了一些 Linux 发行版本安装的可执行程序。该目录通常会存储成千上万个程序</td></tr><tr><td align="center">&#x2F;usr&#x2F;lib</td><td align="center">&#x2F;usr&#x2F;bin 目录中的程序使用的共享库</td></tr><tr><td align="center">&#x2F;usr&#x2F;local</td><td align="center">这个 &#x2F;usr&#x2F;local 目录是并非系统发行版自带，但却打算让系统使用的程序的安装目录。由源代码编译好的程序通常安装在 &#x2F;usr&#x2F;local&#x2F;bin 中，在一个新安装的 Linux 系统中，就存在这么一个目录。但却是空目录，直到系统管理员向其添加内容。</td></tr><tr><td align="center">&#x2F;usr&#x2F;sbin</td><td align="center">包含更多的系统管理程序</td></tr><tr><td align="center">&#x2F;usr&#x2F;share</td><td align="center">&#x2F;usr&#x2F;share 目录里包含 &#x2F;usr&#x2F;bin 中的程序所使用的的全部共享数据，这包括默认配置文件、图标、屏幕背景、音频文件等</td></tr><tr><td align="center">&#x2F;usr&#x2F;share&#x2F;doc</td><td align="center">安装在系统中的大部分程序包包含一些文档文件。在 &#x2F;usr&#x2F;share&#x2F;doc 中，文档文件是按照软件包来组织分类的。</td></tr><tr><td align="center">&#x2F;var</td><td align="center">除了 &#x2F;tmp 和 &#x2F;home 目录之外，目前看到目录相对来说都是静态的；也就是说，其包含的内容是不变的。而那些可能改变的数据存储在 &#x2F;var 目录树里。各种数据库、假脱机文件、用户邮件等都存储在这里</td></tr><tr><td align="center">&#x2F;var&#x2F;log</td><td align="center">&#x2F;var&#x2F;log 目录包含的日志文件，记录了各种系统活动。这些文件非常重要，并且应该时不时监控它们。其中最有用的文件是 &#x2F;var&#x2F;log&#x2F;messages 。注意，为了安全起见，在一些系统里，必须是超级用户才能查看日志文件</td></tr></tbody></table><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><ol><li>基本介绍</li></ol><ul><li>在浏览过程中，我们可能会看到带有如下条目的目录信息。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 11 2012-08-11 07:34 libc.so.6 -&gt; libc-2.6.so</span><br></pre></td></tr></table></figure></li><li>注意，该条目信息的第一个字母是 l ，这种特殊的文件叫做符号链接 (又称软链接或 symlink ) 。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 导航.md</title>
      <link href="/post/3d3cca4.html"/>
      <url>/post/3d3cca4.html</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>除了在命令行进行输入操作之外，我们首先需要学习的是如何在 Linux 系统中导航文件系统。</li><li>本章将介绍下述命令：</li></ol><ul><li>pwd: 查看当前工作目录</li><li>cd: 改变目录</li><li>ls: 列出目录内容</li></ul><h2 id="理解文件系统树"><a href="#理解文件系统树" class="headerlink" title="理解文件系统树"></a>理解文件系统树</h2><ol><li>与 Windows 相同，类 UNIX 操作系统也是以称之为分层目录结构的方式来组织文件的。</li><li>这意味着文件是在树形结构的目录(有时在其他系统中称为文件夹)中进行组织的，该树形结构目录可能包含文件和其他目录。</li><li>文件系统的第一个目录叫做根目录，它包含了文件和子目录。子目录里包含了更多的文件和子目录，依此类推。</li><li>需要注意的是，在 Windows 系统中，每个存储设备都有一个独立的文件系统树。而在类 UNIX 系统中，如 Linux ，无论多少驱动器或储存设备与计算机相连，通常只有一个文件系统树。</li><li>根据系统管理员的设置，存储设备将会挂载到文件系统树的不同位置，系统管理员要负责系统的维护。</li></ol><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><ol><li>可能大部分人都熟悉用于表示文件系统树的图形文件管理器，需要注意的是，树通常是倒立显式的。也就是说，顶部是根目录，依次向下排列是子目录。</li><li>然而，由于命令行没有图像，若是要浏览文件系统树，就必须使用其他方法。</li><li>假设文件系统是一个迷宫，形如一棵倒置的树，并且用户处在文件系统之中。任何时候，我们处在单个目录中，能够看到该目录中包含的文件、去往上一级目录(称为父级目录)的路径，以及下一级的各个子目录。</li><li>用户所处的目录叫做当前工作目录，使用 pwd(打印工作目录) 命令可以显示当前工作目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure></li><li>第一次登录系统时(或是启动终端仿真器会话时)，当前工作目录被设置成主目录。每一个用户账号都有一个主目录，作为普通用户操作时，这是唯一一个允许用户写文件的地方。</li></ol><h2 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h2><ol><li>使用 ls 命令可以列出当前工作目录的文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop Documents Music Pictures Public Videos </span><br></pre></td></tr></table></figure></li><li>实际上，可以使用 ls 命令列出任何目录的内容，而不仅仅是当前工作目录。</li></ol><h2 id="更改当前工作目录"><a href="#更改当前工作目录" class="headerlink" title="更改当前工作目录"></a>更改当前工作目录</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>使用 cd 可以改变工作目录，只需要输入 cd 命令，然后再输入目标工作目录的路径名即可。</li><li>路径名指的是沿着分枝到达目标目录的路由。路径名分为两种：绝对路径名和相对路径名。</li></ol><h3 id="绝对路径名"><a href="#绝对路径名" class="headerlink" title="绝对路径名"></a>绝对路径名</h3><ol><li>绝对路径名从根目录开始，其后紧接着一个又一个文件树分支，直到到达目标目录或文件。</li><li>例如，系统里有一个目录，大多数系统程序都安装到这个目录里，该目录的路径名是 &#x2F;usr&#x2F;bin 。</li><li>这意味着根目录中有个目录是 usr ，该目录包含一个 bin 目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>可以看到，我们已经将当前工作目录改变成 &#x2F;usr&#x2F;bin ， bin 目录中包含很多文件。</li></ol><h3 id="相对路径名"><a href="#相对路径名" class="headerlink" title="相对路径名"></a>相对路径名</h3><ol><li>绝对路径名是从根目录开始，通向目标目录，而相对路径名则是从工作目录开始的。</li><li>为了实现这个目的，它通常使用一些特殊符号来表示文件系统树中的相对位置，这些符号是 . 和 .. 。</li><li>符号是 . 代表工作目录，符号 .. 代表工作目录的父目录。</li><li>下面演示它们是如何工作，让我们再次将工作目录改变成 &#x2F;usr&#x2F;bin 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>下面，我们希望将工作目录改变成 &#x2F;usr&#x2F;bin 的父目录，回到 &#x2F;usr 。有两种方法可以实现，一种是使用绝对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox bin]$ <span class="built_in">cd</span> /usr</span><br><span class="line">[me@linuxbox usr]$ <span class="built_in">pwd</span></span><br><span class="line">/usr</span><br></pre></td></tr></table></figure></li><li>另一种是使用相对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox bin]$ <span class="built_in">cd</span> ..</span><br><span class="line">[me@linuxbox usr]$ <span class="built_in">pwd</span></span><br><span class="line">/usr</span><br></pre></td></tr></table></figure></li><li>同样可以用两种方法将工作目录从 &#x2F;usr 变到 &#x2F;usr&#x2F;bin 。我们可以使用绝对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox usr]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>我们也可以用相对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox usr]$ <span class="built_in">cd</span> ./bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>必须在这里指出来的是，几乎所有的情况下都可以省略 .&#x2F; ，因为它是隐含的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox usr]$ <span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure></li><li>该代码与使用相对路径名的代码具有相同效果。一般而言，如果没有指定路径名，则默认为工作目录。</li></ol><h3 id="一些有用的快捷方式"><a href="#一些有用的快捷方式" class="headerlink" title="一些有用的快捷方式"></a>一些有用的快捷方式</h3><table><thead><tr><th align="center">快捷方式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">cd</td><td align="center">将工作目录改变成主目录</td></tr><tr><td align="center">cd-</td><td align="center">将工作目录改变成先前的工作目录</td></tr><tr><td align="center">cd~username</td><td align="center">将工作目录改变为 username 的主目录。例如， cd~bob 将目录改变成用户 bob 的主目录</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 Shell 是什么</title>
      <link href="/post/37c791b4.html"/>
      <url>/post/37c791b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-是什么"><a href="#Shell-是什么" class="headerlink" title="Shell 是什么"></a>Shell 是什么</h1><h2 id="终端仿真器"><a href="#终端仿真器" class="headerlink" title="终端仿真器"></a>终端仿真器</h2><ol><li>当谈到命令行时，我们实际上指的是 shell 。</li><li>shell 是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序。</li><li>几乎所有的 Linux 发行版都是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序。</li><li>几乎所有的 Linux 的发行版都提供 shell 程序，该程序来自于称之为 bash 的 GNU 项目。</li><li>bash 是 Bourne Again Shell 的首字母缩写， Bourne Again Shell 基于这样一个事实，即 bash 是 sh 的增强版本，而 sh 是最初的 UNIX shell 程序，由 Steve Bourne 编写。</li><li>当使用图形用户界面时，需要另一种叫做终端仿真器(terminal emulator)的程序与 shell 进行交互。</li><li>在 KDE 环境下使用的是 konsole ，而在 GNOME 环境下使用 gnome-terminal ，但是在桌面菜单上很可能将它们简单地统称为终端。</li><li>在 Linux 系统中，还有许多其他的终端仿真器可以使用，但是它们基本上都做同样的事情：让用户访问 shell 。</li><li>因为不同的终端仿真器所具有的功能特性不尽相同，因此，你可以根据自己的喜好进行选择。</li></ol><h2 id="第一次键盘输入"><a href="#第一次键盘输入" class="headerlink" title="第一次键盘输入"></a>第一次键盘输入</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>启动终端仿真器，运行后的终端仿真器如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>这是 shell 提示符，只要 shell 准备接收外部输入，它就会出现。在不同的发行版中，提示符外观可能会有差异，但是，它通常包括 username@machinename ，其后是当前工作目录和一个 $ 符号。</li><li>如果 shell 提示符的最后一个字符是 # ，而不是一个 $ 符号，那么终端会话将享有超级用户特权。</li><li>假定一切工作都很顺利，接下来尝试输入一些内容。在提示符后输入一些乱码。如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ kaekfjaeifj</span><br></pre></td></tr></table></figure></li><li>由于这些命令没有任何意义，shell 会让我们重新输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash: kaekfjaeifj: <span class="built_in">command</span> not found</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li></ol><h3 id="命令历史记录"><a href="#命令历史记录" class="headerlink" title="命令历史记录"></a>命令历史记录</h3><ol><li>如果按下向上方向的指示键，将会看到先前的命令 kaekfjaeifj 再一次出现提示符后面，这称为命令历史记录。</li><li>在默认情况下，大部分 Linux 发行版本能够存储最近输入的 500 个命令。</li><li>按下向下方向指示键，则先前的命令消失。</li></ol><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ol><li>再次按下向上方向指示键，重新调用先前的命令，然后分别按下向左向右方向的指示键，看看如何将光标定位到命令行的任意位置。这可以让我们很容易地编辑命令。</li></ol><h2 id="几个简单的命令"><a href="#几个简单的命令" class="headerlink" title="几个简单的命令"></a>几个简单的命令</h2><ol><li>在学习键盘输入之后，我们来尝试几个简单的命令。</li><li>首先是 date 命令，该命令显示当前系统的时间和日期：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ <span class="built_in">date</span></span><br><span class="line">Thu Oct 25 13:51:54 EDT 2012</span><br></pre></td></tr></table></figure></li><li>与之相关的一个命令是 cal ，在默认情况下， cal 显示当月的日历。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ cal</span><br><span class="line">    八月 2020</span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">                   1</span><br><span class="line"> 2  3  4  5  6  7  8</span><br><span class="line"> 9 10 11 12 13 14 15</span><br><span class="line">16 17 18 19 20 21 22</span><br><span class="line">23 24 25 26 27 28 29</span><br><span class="line">30 31</span><br></pre></td></tr></table></figure></li><li>如果想要查看磁盘驱动器当前可用的空间，可以使用 df 命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ <span class="built_in">df</span></span><br><span class="line">Filesystem    512-blocks      Used Available Capacity iused               ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s1   489620264 132645336 350371888    28% 1330866 9223372036853444941    0%   /</span><br><span class="line">devfs                383       383         0   100%     673                   0  100%   /dev</span><br><span class="line">/dev/disk1s4   489620264   4194344 350371888     2%       2 9223372036854775805    0%   /private/var/vm</span><br><span class="line">map -hosts             0         0         0   100%       0                   0  100%   /net</span><br><span class="line">map auto_home          0         0         0   100%       0                   0  100%   /home</span><br></pre></td></tr></table></figure></li></ol><h2 id="结束终端会话"><a href="#结束终端会话" class="headerlink" title="结束终端会话"></a>结束终端会话</h2><ol><li>直接关闭终端窗口或是在 shell 提示符下输入 exit 命令，即可结束终端会话。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十六讲 Git rebase</title>
      <link href="/post/4c946041.html"/>
      <url>/post/4c946041.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>rebase：变基，意即改变分支的根基</li><li>rebase 作用：从某种程度上来说，rebase 与 merge 可以完成类似的工作，不过两者的工作方式有着显著的差异</li><li>Git rebase 操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch_name</span><br><span class="line">git rebase branch_new_name</span><br></pre></td></tr></table></figure></li><li>Git merge 操作和 Git rebase 操作的区别: 两者结果内容一样，过程和操作方式完全不一样。</li><li>Git rebase 操作会修改提交历史，会让提交历史变成一条直线。</li><li>Git rebase 原理：实际上是将一个分支的修改内容应用到里另外一个分支上，不断的应用，所以提交历史变成一条直线。</li><li>Git rebase 注意事项</li></ol><ul><li>rebase 过程中也会出现冲突</li><li>解决冲突后，使用 git add 添加，然后执行如下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li><li>接下来 Git 会继续应用余下的补丁</li><li>任何时候都可以通过如下命令终止 rebase ，分支会恢复到 rebase 开始前的状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>Git rebase 最佳实践</li></ol><ul><li>不要对 master 分支执行 rebase ，否则会引起很多问题</li><li>一般来说，执行 rebase 的分支都是自己的本地分支，没有推送到远程的版本库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五讲 Git subtree 与 Git cherry-pick</title>
      <link href="/post/2b68b650.html"/>
      <url>/post/2b68b650.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-subtree-与-Git-cherry-pick"><a href="#Git-subtree-与-Git-cherry-pick" class="headerlink" title="Git subtree 与 Git cherry-pick"></a>Git subtree 与 Git cherry-pick</h1><h2 id="Git-subtree"><a href="#Git-subtree" class="headerlink" title="Git subtree"></a>Git subtree</h2><ol><li>Git submodule 如果在主项目修改依赖项目会造成很多问题，Git subtree 和 Git submodule 解决问题一样，Git subtree 可以解决针对双向修改。</li></ol><ul><li>新建 git_subtree_parent 和 git_subtree_children 两个工程(远程仓库)，其中 git_subtree_children 是子工程。</li><li>在本地创建仓库 git_subtree_parent 和 git_subtree_children</li><li>在本地创建的仓库 git_subtree_parent 新建文件 parent.txt ，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_subtree_parent 信息</li><li>将本地的 git_subtree_parent 提交推送到远程 git_subtree_parent 中</li><li>在本地创建的仓库 git_subtree_children 新建 children.txt，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_subtree_children 信息</li><li>将本地的 git_subtree_children 提交推送到远程 git_subtree_children</li><li>在本地创建的仓库 git_subtree_children 新建 hello.txt ，将修改纳入暂存区，并进行提交</li><li>将本地的 git_subtree_children 提交推送到远程 git_subtree_children</li><li>在主项目关联子项目的远程库</li><li>执行 git subtree 命令，将子依赖拉到主项目</li><li>如果 git_children 发生变化，git_parent 也随之变化</li><li>在主工程的 git_subtree_parent&#x2F;subtree 目录下修改文件 children.txt ，将修改纳入暂存区，并进行提交</li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_parent 中</li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_children</li></ul><ol start="2"><li>在主项目关联子项目的远程库命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add subtree-origin git@github.com:gitlecture/git_subtree_children.git</span><br></pre></td></tr></table></figure></li><li>执行 git subtree 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree add --prefix=subtree subtree-orign master --squash <span class="comment"># squash 参数表示子项目的多次提交被压缩成一次提交</span></span><br></pre></td></tr></table></figure></li><li>拉取 git_subtree_children 更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree pull --prefix=subtree subtree-origin --squash <span class="comment"># squash 也可以不用(注意：要是不用就所有 subtree 命令不用，要用就所有 subtree 命令都用)</span></span><br></pre></td></tr></table></figure></li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_parent 中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_children<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=subtree subtree-origin master</span><br></pre></td></tr></table></figure></li><li>将远程的 git_subtree_children 拉到本地 git_subtree_children<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 在 git_subtree_children 目录下</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-cherry-pick"><a href="#Git-cherry-pick" class="headerlink" title="Git cherry-pick"></a>Git cherry-pick</h2><ol><li>作用：将在一个分支的修改应用到另一个分支上(主要用于本地分支)</li><li>将一个分支的修改应用到另一个分支上(例如将在 develop 分支的修改应用于 master 分支)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commit_id <span class="comment"># 将其他分支的一个提交所做的修改应用到当前分支</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四讲 Git 裸库与 Git submodule</title>
      <link href="/post/47e9a5ce.html"/>
      <url>/post/47e9a5ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-裸库与-Git-submodule"><a href="#Git-裸库与-Git-submodule" class="headerlink" title="Git 裸库与 Git submodule"></a>Git 裸库与 Git submodule</h1><h2 id="Git-裸库"><a href="#Git-裸库" class="headerlink" title="Git 裸库"></a>Git 裸库</h2><ol><li>没有工作区的 Git 仓库(一般在服务器端)</li><li>创建裸库命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare <span class="comment"># 没有工作区</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-submodule"><a href="#Git-submodule" class="headerlink" title="Git submodule"></a>Git submodule</h2><ol><li>项目的相互协作(多模块开发-项目的依赖)</li></ol><ul><li>准备工作<ul><li>在 GitHub 上创建仓库 git_parent 和 git_children</li><li>在本地创建仓库 git_parent 和 git_children</li><li>在本地创建的仓库 git_parent 新建文件 parent.txt ，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_parent 信息</li><li>将本地的 git_parent 提交推送到远程 git_parent</li><li>在本地创建的仓库 git_children 新建 submodule.txt ，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_children 信息</li><li>将本地的 git_children 提交推送到远程 git_children</li><li>在本地创建的仓库 git_children 新建 hello.txt ，将修改纳入暂存区，并进行提交</li><li>将本地的 git_children 提交推送到远程 git_children</li><li>执行 git submodule 命令，将子依赖拉到主项目</li><li>将文件修改纳入暂存区，接着进行提交</li><li>如果 git_children 发生变化，git_parent 也随之变化</li></ul></li></ul><ol start="2"><li>git submodule 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule git@github.com:gitlecture/git_children.git my module</span><br></pre></td></tr></table></figure></li><li>拉取 <code>git_children</code> 更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 在 git_parent/myModule 目录下</span></span><br></pre></td></tr></table></figure></li><li>拉取所有依赖子模块的所有更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure></li><li>如果一个项目包含着 submodule ，进行 git clone 操作的时候，默认情况下是不会把 submodule 的代码克隆下来，需要手工的去执行一次<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gitlecture/git_parent.git parent2 <span class="comment"># 克隆</span></span><br><span class="line">git submodule init <span class="comment"># submodule 初始化</span></span><br><span class="line">git submodule update --recursive <span class="comment"># 进行子模块更新</span></span><br></pre></td></tr></table></figure></li><li>进行 git clone 操作时候，使用后面加参数将所有子模块的更新全部克隆下来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gitlecture/git_parent.git parent3 --recursive</span><br></pre></td></tr></table></figure></li><li>删除 submodule (命令组合)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.将 submodule 从缓存区删除</span></span><br><span class="line">git <span class="built_in">rm</span> --cached mymodule</span><br><span class="line"><span class="comment"># 2.将 submodule 的实体文件从工作区删除</span></span><br><span class="line"><span class="built_in">rm</span> -rf mymodule</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;remove submodule&#x27;</span></span><br><span class="line">git push</span><br><span class="line"><span class="comment"># 3.将 .gitmodules 目录删除</span></span><br><span class="line"><span class="built_in">rm</span> .gitmodules</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;remove submodules&#x27;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三讲 Git gc</title>
      <link href="/post/db6359d5.html"/>
      <url>/post/db6359d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-gc"><a href="#Git-gc" class="headerlink" title="Git gc"></a>Git gc</h1><h2 id="git-垃圾收集"><a href="#git-垃圾收集" class="headerlink" title="git 垃圾收集"></a>git 垃圾收集</h2><ol><li>git 垃圾收集主要用于做一些文件压缩，将分散在不同地方的文件给合并到一起，对一些对象通过一些手段将其所占体积减少。(git gc 实际开发中使用很少，因为很多时候 git 后台自动运行)</li><li>进入本地仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repository_name</span><br></pre></td></tr></table></figure></li><li>进入 refs 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> refs</span><br></pre></td></tr></table></figure></li><li>进入 heads 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> heads</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cat</span> branch_name <span class="comment"># 查看本地分支内容</span></span><br></pre></td></tr></table></figure></li><li>进入 remotes&#x2F;origin 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> remotes/origin</span><br><span class="line"><span class="built_in">cat</span> branch_name <span class="comment"># 查看远程分支内容</span></span><br></pre></td></tr></table></figure></li><li>进入 tags 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tags</span><br><span class="line"><span class="built_in">cat</span> v1.0 <span class="comment"># 查看标签内容</span></span><br></pre></td></tr></table></figure></li><li>运行 git gc 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git gc <span class="comment"># 文件压缩(git gc 实际上把 refs 目录下的所有文件被打包到 pached-refs 目录下，增加新的提交信息，则该信息还是在 refs 的目录下)</span></span><br></pre></td></tr></table></figure></li><li>git 每次提交的对象保存到 .git&#x2F;objects&#x2F;info 的 packs 文件中(进行压缩后 .git&#x2F;objects&#x2F;info&#x2F;packs 文件会被压缩到 .git&#x2F;objects&#x2F;pack)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二讲 Git 远程标签</title>
      <link href="/post/ea965a0c.html"/>
      <url>/post/ea965a0c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-远程标签"><a href="#Git-远程标签" class="headerlink" title="Git 远程标签"></a>Git 远程标签</h1><h2 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h2><ol><li>列出本地的所有标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li>创建一个轻量级标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure></li><li>创建带注释的标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v2.0 -m <span class="string">&#x27;v2.0 released&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看标签内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v1.0</span><br></pre></td></tr></table></figure></li><li>搜索标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l <span class="string">&#x27;v&#x27;</span> <span class="comment"># 利用通配符</span></span><br></pre></td></tr></table></figure></li><li>推送标签到远程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br><span class="line">git push origin v1.0 v2.0 <span class="comment"># 少数标签</span></span><br><span class="line">git push origin --tags <span class="comment"># 将标签 批量推送到远程</span></span><br></pre></td></tr></table></figure></li><li>删除远程标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1.0</span><br><span class="line">git push origin --delete tag v1.0</span><br></pre></td></tr></table></figure></li><li>将本地标签推送到远程的完整语法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin refs/tags/v1.0:refs/tags/v1.0</span><br></pre></td></tr></table></figure></li><li>只从远程拉取标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin tag v1.0</span><br></pre></td></tr></table></figure></li><li>只从远程拉取标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin tag v1.0</span><br></pre></td></tr></table></figure></li><li>显示远程信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote origin show</span><br></pre></td></tr></table></figure></li><li>删除远程游离的分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin <span class="comment"># 通常删除分支后的操作</span></span><br></pre></td></tr></table></figure></li><li>如果远端上有一个 master 分支，本地就可以通过下面几种方式来访问它的历史记录：</li></ol><ul><li>查看远程分支的历史记录(3 种方式)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> origin/matser</span><br><span class="line">git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure></li></ul><ol start="14"><li>将远程的某个分支的内容拉取到本地的新远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:refs/origin/mymaster</span><br></pre></td></tr></table></figure></li><li>在本地创建新分支并追踪本地的远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin mymaster</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一讲 Git refspec</title>
      <link href="/post/d0933ad4.html"/>
      <url>/post/d0933ad4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-refspec"><a href="#Git-refspec" class="headerlink" title="Git refspec"></a>Git refspec</h1><h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><ol><li>配置别名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.br branch # 配置信息在 ~/.gitconfig 文件下</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD&#x27;</span><br><span class="line">git config --global alias.ui &#x27;!git&#x27;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-refspec-1"><a href="#Git-refspec-1" class="headerlink" title="Git refspec"></a>Git refspec</h2><h3 id="git-push-相关操作"><a href="#git-push-相关操作" class="headerlink" title="git push 相关操作"></a>git push 相关操作</h3><ol><li>git push 操作的完整命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin srcbranch:destbranch <span class="comment"># 建议的 git push 命令</span></span><br></pre></td></tr></table></figure></li><li>将本地分支推送到远程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin branch_name <span class="comment"># 将本地分支推送到远程(默认远程分支名与本地一样)</span></span><br><span class="line">git push -u origin branch_name <span class="comment"># 跟上一条命令一样效果</span></span><br><span class="line">git push --set-upstream origin branch_name:branch_new_name <span class="comment"># 将本地分支推送到远程并且远程分支名与本地所关联的分支不同名</span></span><br><span class="line"><span class="comment"># 如果不同名，则进行 git push 操作，则要执行以下命令</span></span><br><span class="line">git push origin HEAD:branch_new_name <span class="comment"># 尽可能同名(不同名无法简写 git push 命令)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="git-pull-相关操作"><a href="#git-pull-相关操作" class="headerlink" title="git pull 相关操作"></a>git pull 相关操作</h3><ol><li>git pull 操作的完整命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin srcbranch:destbranch</span><br></pre></td></tr></table></figure></li><li>将远程分支拉到本地<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 将远程所有分支改变都拉到本地</span></span><br><span class="line">git checkout -b branch_name origin/branch_name <span class="comment"># 创建跟远程分支同名的本地分支，并关联。</span></span><br><span class="line">git checkout --track origin/branch_name分支来追踪 <span class="comment"># 本地创建同名的 branch_name 分支来追踪 origin/branch_name (与上一条命令意思完全一样)</span></span><br></pre></td></tr></table></figure></li><li>删除远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branch_name <span class="comment"># 将本地的一个空分支推送到远程某个分支(意味着删除远程的该分支)</span></span><br><span class="line">git push origin --delete branch_name <span class="comment"># 与上一个命令一样效果</span></span><br></pre></td></tr></table></figure></li><li>重命名远程分支</li></ol><ul><li>删除远程分支</li><li>本地重命名分支</li><li>将本地重命名后的分支推送到远程</li></ul><h2 id="HEAD-文件相关内容"><a href="#HEAD-文件相关内容" class="headerlink" title="HEAD 文件相关内容"></a>HEAD 文件相关内容</h2><ol><li>HEAD 标记</li></ol><ul><li>HEAD 文件是一个指向你当前所在分支的引用标识符，该文件内部并不包含 SHA-1 值，而是包含一个指向另外一个引用的指针。</li><li>当执行 git commit 命令时，git 会创建一个 commit 对象，并且将这个 commit 对象的 parent 指针设置为 HEAD 所指向的引用的 SHA-1 值。</li><li>我们对于 HEAD 修改的任何操作都会被 git reflog 完整记录下来。</li><li>实际上，我们可以通过对 git 底层命令 symbolic-ref 来实现对 HEAD 文件内容的修改。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git symbolic-ref HEAD <span class="comment"># 读取</span></span><br><span class="line">git symbolic-ref HEAD refs/heads/branch_name <span class="comment"># 写入</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十讲 Git 远程操作与 Git 协作</title>
      <link href="/post/1624a6c0.html"/>
      <url>/post/1624a6c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-远程操作与-Git-协作"><a href="#Git-远程操作与-Git-协作" class="headerlink" title="Git 远程操作与 Git 协作"></a>Git 远程操作与 Git 协作</h1><h2 id="Git-远程操作"><a href="#Git-远程操作" class="headerlink" title="Git 远程操作"></a>Git 远程操作</h2><ol><li>建立 SSH 安全连接<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1.配置远程</span><br><span class="line">git remote add orgin git@github.com:repository_name/repository_name.git # 远程仓库 SSH 链接地址</span><br><span class="line">git remote show orgin</span><br><span class="line"># 2.把公钥放置远程</span><br><span class="line">cd .ssh</span><br><span class="line">ls</span><br><span class="line">vi known_hosts</span><br><span class="line">which ssh-keygen # 生成公钥</span><br><span class="line">ssh-keygen # 生成公钥(敲入命令回车，要求输入密码连续两次回车)</span><br><span class="line">ls id_rsa.pub # 进入公钥文件夹(把公钥粘贴放置 GitHub 中 settings 的 Deploy keys 上面)</span><br><span class="line"># 3.把本地分支推送到远程</span><br><span class="line">git push -u orgin master # 将本地的 master 分支推送到远程</span><br></pre></td></tr></table></figure></li><li>查看所有远程仓库的别名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show</span><br></pre></td></tr></table></figure></li><li>查看远程仓库所有信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show repository_name</span><br></pre></td></tr></table></figure></li><li>重命名远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin origin2</span><br></pre></td></tr></table></figure></li><li>删除远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure></li><li>删除之后再次创建<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add orgin git@github.com:repository_name/epository_name.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="更新-git"><a href="#更新-git" class="headerlink" title="更新 git"></a>更新 git</h2><ol><li>查看 git 版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li>查看 git 的位置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> git</span><br></pre></td></tr></table></figure></li><li>查看 mac 的系统环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li>修改环境目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi .zshrc</span><br></pre></td></tr></table></figure></li><li>安装新版 git<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 新增的 git 一般被安装在 usr/local/git 中 </span><br></pre></td></tr></table></figure></li></ol><h2 id="git-协作"><a href="#git-协作" class="headerlink" title="git 协作"></a>git 协作</h2><ol><li>查看所有远程仓库的名字<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show</span><br></pre></td></tr></table></figure></li><li>查看所有远程仓库的详细信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show remote_repository_name</span><br></pre></td></tr></table></figure></li><li>关联远程(过程理解)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 与远程关联之后，本地有一个 master 分支，还有一个 origin/master 分支(追踪着远程版本库的 mater 分支)</span><br><span class="line"># 进行 git pull 操作，git 会将远程的修改拉到本地，同时将 origin/master 分支的 commit_id 对应到远程 master 最新的那次提交,如果这种合并是可以直接合并，git 会将远程的 master 分支直接合并到本地的 master 分支上。</span><br><span class="line"># 进行 git push 操作，git 会将本地的 origin/master 分支最新的 commit_id 指向本地的 master 分支上，将本地的 master 的分支内容 push 到远程</span><br></pre></td></tr></table></figure></li><li>查看远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment"># 查看所有远程分支</span></span><br><span class="line">git branch -av <span class="comment"># 查看所有远程分支以及其最新的提交 commit_id</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="拉取代码操作"><a href="#拉取代码操作" class="headerlink" title="拉取代码操作"></a>拉取代码操作</h2><ol><li>拉取远程代码(克隆)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repository_url_ssh</span><br></pre></td></tr></table></figure></li><li>拉取远程代码并重命名仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repository_url_ssh repository_new_name</span><br></pre></td></tr></table></figure></li></ol><h2 id="git-pull-与-git-fetch-区别"><a href="#git-pull-与-git-fetch-区别" class="headerlink" title="git pull 与 git fetch 区别"></a>git pull 与 git fetch 区别</h2><ol><li>git fetch<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment"># 一定会成功的(不执行合并操作，仅仅是将远程的修改拉到本地，更新本地的 orgin/master)</span></span><br><span class="line">git merge orgin/master <span class="comment"># 将本地的 orgin/master 的修改 merge 到本地的 master 分支上</span></span><br></pre></td></tr></table></figure></li><li>git pull &#x3D;&#x3D; git fetch + git merge</li></ol><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><ol><li>Gitflow</li><li>关于 Git 分支的最佳实践(基于 Git 分支的开发模型)</li></ol><ul><li>master 分支(生产发布)–生产发布分支，变化非常不频繁的一个分支</li><li>test 分支(测试)–供测试与产品人员使用的一个分支，变化不是特别频繁</li><li>develop 分支(开发)–频繁变化的一个分支</li><li>hotfix 分支(修复 bug 分支)–生产系统当中出现了紧急 bug ，用于紧急修复的分支</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九讲 远程与 GitHub</title>
      <link href="/post/e986823a.html"/>
      <url>/post/e986823a.html</url>
      
        <content type="html"><![CDATA[<h1 id="远程与-GitHub"><a href="#远程与-GitHub" class="headerlink" title="远程与 GitHub"></a>远程与 GitHub</h1><h2 id="远程版本库-GitHub"><a href="#远程版本库-GitHub" class="headerlink" title="远程版本库(GitHub)"></a>远程版本库(GitHub)</h2><ol><li><a href="https://github.com/">Github 官网网址</a></li><li>注册账号: 利用邮箱注册账号(公共仓库)</li><li>将本地仓库推送到 GitHub 上</li></ol><ul><li>初始化仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init repository_name</span><br></pre></td></tr></table></figure></li><li>配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;name&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;email&#x27;</span></span><br></pre></td></tr></table></figure></li><li>修改配置的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure></li><li>修改文件</li><li>将修改纳入暂存区</li><li>进行提交</li><li>本地版本库推送<ul><li>对 GitHub 进行配置</li><li>新建 README.md 进行说明，并提交到本地版本库</li><li>现在网页上创建一个远程仓库</li><li>推送到远程命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/repository_name.git <span class="comment"># 远程仓库 url</span></span><br><span class="line">git push -u origin master <span class="comment"># 将本地的 master 分支推送到远程</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八讲 标签与 diff</title>
      <link href="/post/38d25409.html"/>
      <url>/post/38d25409.html</url>
      
        <content type="html"><![CDATA[<h1 id="标签与-diff"><a href="#标签与-diff" class="headerlink" title="标签与 diff"></a>标签与 diff</h1><h2 id="Git-标签"><a href="#Git-标签" class="headerlink" title="Git 标签"></a>Git 标签</h2><ol><li>新建标签，标签有两种：轻量级标签(lightweight)与带有附注标签(annotated)。</li><li>创建一个轻量级标签</li><li>创建一个带附注的标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.02 -m <span class="string">&#x27;release version&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看所有标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li>查找标签(模糊查找和精确查找)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l <span class="string">&#x27;v1.0&#x27;</span></span><br></pre></td></tr></table></figure></li><li>删除标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d tag_name</span><br></pre></td></tr></table></figure></li><li>git blame 命令(定位文件修改的信息)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame file <span class="comment"># 可以查看该文件所有修改者信息</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><h3 id="系统自带的-diff"><a href="#系统自带的-diff" class="headerlink" title="系统自带的 diff"></a>系统自带的 diff</h3><ol><li>系统自带 diff 对比文件差别<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file_1 file_2 </span><br></pre></td></tr></table></figure></li><li>详细系统自带 diff 对比文件差别<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -u file_1 file_2</span><br></pre></td></tr></table></figure></li></ol><h3 id="Git-中-diff"><a href="#Git-中-diff" class="headerlink" title="Git 中 diff"></a>Git 中 diff</h3><ol><li>进行工作区与暂存区之间的文件差别对比: 暂存区文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment"># 比较的是暂存区与工作区文件之间的差别(将工作区文件修改，暂存区不动，进行差异性比较。)</span></span><br></pre></td></tr></table></figure></li><li>进行工作区与特定 commit_id 之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff commit_id</span><br></pre></td></tr></table></figure></li><li>进行工作区与最新的提交之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD </span><br></pre></td></tr></table></figure></li><li>进行暂存区与某一特定 commit_id 之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached commit_id</span><br></pre></td></tr></table></figure></li><li>进行暂存区与最新的提交之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七讲 checkout 进阶与 stash</title>
      <link href="/post/935be61e.html"/>
      <url>/post/935be61e.html</url>
      
        <content type="html"><![CDATA[<h1 id="checkout-进阶与-stash"><a href="#checkout-进阶与-stash" class="headerlink" title="checkout 进阶与 stash"></a>checkout 进阶与 stash</h1><h2 id="checkout-进阶"><a href="#checkout-进阶" class="headerlink" title="checkout 进阶"></a>checkout 进阶</h2><ol><li>丢弃工作目录的变更<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure></li><li>从暂存区取消暂存<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure></li><li>checkout 切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout new_branch <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b new_branch <span class="comment"># 创建分支并切换分支</span></span><br></pre></td></tr></table></figure></li><li>利用 checkout 回退版本(HEAD 处于游离状态)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout commit_id <span class="comment"># 此时指针处于游离状态</span></span><br></pre></td></tr></table></figure></li><li>接着利用下一命令可以将游离的指针，移到创建分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch </span><br></pre></td></tr></table></figure></li><li>分支改名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m branch_1 branch_2</span><br></pre></td></tr></table></figure></li></ol><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ol><li>将当前分支的所有修改临时保存起来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></li><li>查看所有保存状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></li><li>提交临时保存说明<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&#x27;message&#x27;</span></span><br></pre></td></tr></table></figure></li><li>将临时保存状态恢复出来，并把这个保存状态删除掉<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash poo</span><br></pre></td></tr></table></figure></li><li>将临时保存状态恢复出来，不把这个保存状态删除掉<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></li><li>手动删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;number&#125; </span><br></pre></td></tr></table></figure></li><li>从任意一个临时状态恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;number&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六讲 分支进阶与版本回退</title>
      <link href="/post/9551f68e.html"/>
      <url>/post/9551f68e.html</url>
      
        <content type="html"><![CDATA[<h1 id="分支进阶与版本回退"><a href="#分支进阶与版本回退" class="headerlink" title="分支进阶与版本回退"></a>分支进阶与版本回退</h1><h2 id="Fast-Forward"><a href="#Fast-Forward" class="headerlink" title="Fast-Forward"></a>Fast-Forward</h2><ol><li>如果可能，合并分支时 Git 会使用 fast-forward 模式。</li><li>在这种模式下，删除分支时会丢掉分支信息</li><li>合并时加上 –no-ff 参数会禁用 fast-forward ，这样会多出一个 commit id<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff new_branch</span><br></pre></td></tr></table></figure></li><li>查看 log<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph <span class="comment"># 以图形化的方式</span></span><br><span class="line">git <span class="built_in">log</span> --graph --abbrev-commit <span class="comment"># log 日志中 commit_id 信息简写</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol><li>把当前文件目录下的所有文件放入暂存区，然后提交<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">&#x27;add another line&#x27;</span> </span><br><span class="line"><span class="comment"># 上述命令等价于以下两命令之和</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;add another line&#x27;</span></span><br></pre></td></tr></table></figure></li><li>回退到上一版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard HEAD~1 </span><br></pre></td></tr></table></figure></li><li>返回到某一版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog <span class="comment"># 查看操作日志，查看版本的 commit_id</span></span><br><span class="line">git reset --hard commit_id <span class="comment"># 回退到特定版本</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五讲 .gitignore 与分支</title>
      <link href="/post/60c32a6b.html"/>
      <url>/post/60c32a6b.html</url>
      
        <content type="html"><![CDATA[<h1 id="gitignore-与分支"><a href="#gitignore-与分支" class="headerlink" title=".gitignore 与分支"></a>.gitignore 与分支</h1><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><ol><li>文件忽略: .gitignore<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，但不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt ，但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过网站生成常用的-gitignore-文件"><a href="#通过网站生成常用的-gitignore-文件" class="headerlink" title="通过网站生成常用的 .gitignore 文件"></a>通过网站生成常用的 .gitignore 文件</h2><ul><li><a href="!http://www.gitignore.io/">网站链接</a></li></ul><h2 id="一些重要的命令"><a href="#一些重要的命令" class="headerlink" title="一些重要的命令"></a>一些重要的命令</h2><ol><li>删除目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> mydir <span class="comment"># 不常用，要求目录是空目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf mydir</span><br></pre></td></tr></table></figure></li><li>拼接两条命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mydir &amp;&amp; <span class="built_in">cd</span> mydir <span class="comment"># 创建目录并进入该目录</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><ol><li>分支的一些概念</li></ol><ul><li>一个 commit 对象链：一条工作记录线(只有一个分支)</li><li>HEAD 指向的是当前分支</li><li>master(分支名)指向当前分支的最后一次提交</li><li>分支的合并形式：快进-fast forward</li><li>master 分支没有做修改，另一分支做修改，合并形式就是快进</li></ul><ol start="2"><li>查看当前版本库的所有分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li>创建新的分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch new_branch(此时新分支和当前分支同步)</span><br></pre></td></tr></table></figure></li><li>切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout new_branch <span class="comment"># 两分支文件是独立的</span></span><br><span class="line">git checkout - <span class="comment"># 切换到之前的分支</span></span><br></pre></td></tr></table></figure></li><li>删除分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d new_branch </span><br></pre></td></tr></table></figure></li><li>注意事项：</li></ol><ul><li>不能删除当前所在分支</li><li>如果分支没有完全合并，要强行删除分支需要采用以下命令(要被删除的分支上做出了文件修改)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D new_branch </span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>创建分支并同时切换到新的分支上<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch</span><br></pre></td></tr></table></figure></li><li>分支的合并<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge new_branch <span class="comment"># 将 new_branch 的内容修改合并到 master 分支上</span></span><br></pre></td></tr></table></figure></li><li>显示当前所处分支最新的提交信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></li><li>合并产生冲突(解决冲突)</li></ol><ul><li>原因：两个分支修改了同时修改同一个文件同一行(产生冲突)</li><li>无法自动解决冲突，手动利用工具解决</li><li>手动解决冲突后利用以下两个命令进行合并的提交</li><li>手动解决合并冲突后，当前分支如果和另一分支合并，则这次合并是 fast-forward<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add file <span class="comment"># 告诉 git 手动解决了冲突</span></span><br><span class="line">git commit -m <span class="string">&#x27;&#x27;</span> <span class="comment"># 提交这次合并的 commit message</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四讲 Git 添加、删除、修改与日志</title>
      <link href="/post/7df480e5.html"/>
      <url>/post/7df480e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-添加、删除、修改与日志"><a href="#Git-添加、删除、修改与日志" class="headerlink" title="Git 添加、删除、修改与日志"></a>Git 添加、删除、修改与日志</h1><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ol><li>创建文件(利用 echo)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span> &gt; file <span class="comment"># 文件重定向</span></span><br></pre></td></tr></table></figure></li><li>删除文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file <span class="comment"># 先删除文件并把这次修改纳入暂存区。</span></span><br></pre></td></tr></table></figure></li><li>利用 git rm 删除文件可以利用以下两次命令恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file <span class="comment"># 将文件从暂存区回退到工作区</span></span><br><span class="line">git checkout -- file <span class="comment"># 将工作区的文件修改全部丢弃(未纳入暂存区的文件修改)</span></span><br></pre></td></tr></table></figure></li><li>删除文件(系统命令 rm)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file <span class="comment"># 删除文件但并未把这次修改纳入暂存区</span></span><br></pre></td></tr></table></figure></li><li>利用系统命令 rm 删除文件可以利用以下一条命令恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file <span class="comment"># 将工作区的文件修改全部丢弃(未纳入暂存区的文件修改)</span></span><br></pre></td></tr></table></figure></li><li>利用 git mv 进行文件重命名: 将原文件删除并创建一个新的和原文件一样的文件并把这次修改纳入暂存区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> file file_1 <span class="comment"># 先将文件进行重命名并把这次修改纳入暂存区</span></span><br></pre></td></tr></table></figure></li><li>利用 git mv 进行文件重命名可以利用以下操作恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br><span class="line">git reset HEAD file_1</span><br><span class="line">git checkout -- file</span><br><span class="line"><span class="built_in">rm</span> file_1</span><br></pre></td></tr></table></figure></li><li>利用系统命令 mv 进行文件重命名: 将原文件删除并创建一个新的和原文件一样的文件并未把这次修改纳入暂存区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file file_1 <span class="comment"># 并未把这次修改纳入暂存区</span></span><br></pre></td></tr></table></figure></li><li>利用系统命令 mv 进行文件重命名可以利用以下操作恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br><span class="line"><span class="built_in">rm</span> file_1</span><br></pre></td></tr></table></figure></li><li>将当前目录以及当前目录子目录的所有文件同时纳入暂存区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li>commit message 提交错误进行修正<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m <span class="string">&#x27;message_1&#x27;</span> <span class="comment"># 修正上一次的 commit message</span></span><br></pre></td></tr></table></figure></li><li>查看日志<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n <span class="comment"># 查看最近 n 条日志</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline 日志以一行的简单方式呈现</span><br></pre></td></tr></table></figure></li><li>获取帮助<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> config</span><br><span class="line">git config --<span class="built_in">help</span></span><br><span class="line">man git-config</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三讲 Git 重要命令操练</title>
      <link href="/post/46863b15.html"/>
      <url>/post/46863b15.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-重要命令操练"><a href="#Git-重要命令操练" class="headerlink" title="Git 重要命令操练"></a>Git 重要命令操练</h1><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ol><li>获得版本库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 版本库初始化(本地创建 git 版本库)</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment"># 克隆远程版本库</span></span><br></pre></td></tr></table></figure></li><li>版本管理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment"># 将已修改的文件从工作区纳入到暂存区</span></span><br><span class="line">git commit <span class="comment"># 将暂存区文件提交到 git 本地版本库</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="comment"># 删除文件</span></span><br></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> <span class="comment"># 查看 git 命令使用</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看日志</span></span><br><span class="line">git diff <span class="comment"># 查看文件不同状态的差异</span></span><br></pre></td></tr></table></figure></li><li>远程协作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 将远程版本库当中的文件拉到本地</span></span><br><span class="line">git push <span class="comment"># 将本地版本库当中的版本内容推送到远程</span></span><br></pre></td></tr></table></figure></li><li>查看工作区状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure></li><li>将文件从暂存区回退到工作区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached file</span><br></pre></td></tr></table></figure></li><li>将文件从暂存区提交到本地版本库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;提交消息&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看提交历史</li></ol><ul><li>Git 的提交(commit id)是一个在摘要值。这个摘要值实际是 sha1 计算出来的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>配置信息</li></ol><ul><li>对于 user.name 和 user.email 来说，有三个地方可以设置<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/etc/gitconfig(几乎不会使用)</span><br><span class="line">git config --system</span><br><span class="line"></span><br><span class="line">~/.gitconfig(很常用) # 针对用户(优先级其次)</span><br><span class="line">git config --global</span><br><span class="line"></span><br><span class="line">.git/config # 针对于特定项目的(优先级最高)</span><br><span class="line">git config --local</span><br></pre></td></tr></table></figure></li><li>查看配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li>删除配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --<span class="built_in">unset</span> user.name <span class="comment"># 针对特定项目的</span></span><br></pre></td></tr></table></figure></li><li>查看配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> config <span class="comment"># 查看针对特定项目的配置信息文件</span></span><br><span class="line"><span class="built_in">cat</span> ~/.gitconfig <span class="comment"># 查看针对用户的配置信息文件</span></span><br></pre></td></tr></table></figure></li><li>丢弃在工作区所做的修改<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure></li><li>完全修改文件内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;weclome&#x27;</span> &gt; file <span class="comment"># 文件重定向</span></span><br></pre></td></tr></table></figure></li><li>追加文件内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;weclome&#x27;</span> &gt;&gt; file</span><br></pre></td></tr></table></figure></li><li>从将文件从暂存区回退到工作区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二讲 Git 入门指引</title>
      <link href="/post/16f9fd9.html"/>
      <url>/post/16f9fd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-入门指引"><a href="#Git-入门指引" class="headerlink" title="Git 入门指引"></a>Git 入门指引</h1><h2 id="Git-简史"><a href="#Git-简史" class="headerlink" title="Git 简史"></a>Git 简史</h2><ol><li>Linux 内核开源项目有着位数众多的参与者。一开始整个项目组使用 BitKeeper 来管理和维护代码。2005 年，BitKeeper 不再能免费使用，这就迫使 Linux 开源社区开发一套属于自己的版本控制系统。</li><li>自诞生于 2005 年以来，Git 日臻成熟完善，它的速度飞快，极其适合管理大型项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。</li><li>众多的开源、非开源项目已经逐步由 SVN 迁移到 Git 。</li></ol><h2 id="CVS、SVN-与-Git"><a href="#CVS、SVN-与-Git" class="headerlink" title="CVS、SVN 与 Git"></a>CVS、SVN 与 Git</h2><ol><li>CVCS: 集中式版本控制系统</li><li>DVCS: 分布式版本控制系统</li><li>有了 Git ，编程真正成了一种乐趣。</li></ol><h2 id="Git、GitHub-与-GitLab"><a href="#Git、GitHub-与-GitLab" class="headerlink" title="Git、GitHub 与 GitLab"></a>Git、GitHub 与 GitLab</h2><ol><li>Git 是一个版本控制软件</li><li>GitHub 与 GitLab 都是用于管理版本的服务端软件</li><li>GitHub 提供免费服务(代码需公开)以及付费服务(代码私有)</li><li>GitLab 用于在企业内部管理 Git 版本库，功能上类似于 GitHub</li></ol><h2 id="Git-设计目标"><a href="#Git-设计目标" class="headerlink" title="Git 设计目标"></a>Git 设计目标</h2><ol><li>快速</li><li>简单(学习曲线陡峭)</li><li>高效存储</li><li>完全分布</li><li>满足大规模项目需要</li></ol><h2 id="Git-优点"><a href="#Git-优点" class="headerlink" title="Git 优点"></a>Git 优点</h2><ol><li>本地建立版本库</li><li>本地版本控制</li><li>多主机异地协同工作</li><li>重写提交说明</li><li>有后悔药可以吃</li><li>更好用的提交列表</li><li>更好的差异比较</li><li>更完善的分支系统</li><li>速度极快</li></ol><h2 id="Git-工作模式"><a href="#Git-工作模式" class="headerlink" title="Git 工作模式"></a>Git 工作模式</h2><ol><li>版本库初始化</li></ol><ul><li>个人计算机从版本服务器同步</li></ul><ol start="2"><li>操作</li></ol><ul><li>90% 以上的操作在个人计算机上</li><li>添加文件</li><li>修改文件</li><li>提交变更</li><li>查看版本历史等</li></ul><ol start="3"><li>版本库同步</li></ol><ul><li>将本地修改推送到版本服务器</li></ul><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><ol><li>直接记录快照，而非差异比较</li><li>近乎所有操作都在本地执行</li><li>时刻保持数据完整性</li><li>多数操作仅添加操作</li><li>文件的三种状态</li></ol><ul><li>modified: 已修改</li><li>staged: 已暂存</li><li>committed: 已提交</li></ul><h2 id="Git-文件状态"><a href="#Git-文件状态" class="headerlink" title="Git 文件状态"></a>Git 文件状态</h2><ol><li>Git 文件</li></ol><ul><li>已被版本库管理的文件</li></ul><ol start="2"><li>已修改</li></ol><ul><li>在工作目录修改 Git 文件</li></ul><ol start="3"><li>已暂存</li></ol><ul><li>对已修改的文件执行 Git 暂存操作，将文件存入暂存区</li></ul><ol start="4"><li>已提交</li></ol><ul><li>将已暂存的文件执行 Git 提交操作，将文件存入版本库</li></ul><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><ol><li>Linux: Ubuntu<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li><li>Mac</li></ol><ul><li>安装命令行工具：如已安装 Xcode ，命令行工具会在首次启动 Xcode 时提示安装</li><li>安装 Homebrew<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Windows</li></ol><ul><li>安装 <a href="https://gitforwindows.org/">msysGit</a></li><li>完成安装之后，就可以使用命令行的 git 工具了，另外还有一个图形界面的 Git 项目管理工具。</li><li>建议使用 Git 命令行，方便又快捷，GUI 反而繁琐。</li><li>如果需要使用 GUI ，推荐使用 SourceTree ，拥有 Mac 与 Windows 版本；此外，Windows 下还可以使用 TortoiseGit 。</li></ul><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ul><li>获得版本库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 版本库初始化(本地创建 git 版本库)</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment"># 克隆远程版本库</span></span><br></pre></td></tr></table></figure></li><li>版本管理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment"># 将已修改的文件从工作区纳入到暂存区</span></span><br><span class="line">git commit <span class="comment"># 将暂存区文件提交到 git 本地版本库</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="comment"># 删除文件</span></span><br></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> <span class="comment"># 查看 git 命令使用</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看日志</span></span><br><span class="line">git diff <span class="comment"># 查看文件不同状态的差异</span></span><br></pre></td></tr></table></figure></li><li>远程协作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 将远程版本库当中的文件拉到本地</span></span><br><span class="line">git push <span class="comment"># 将本地版本库当中的版本内容推送到远程</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲 课程内容概述与准备</title>
      <link href="/post/8f4877b8.html"/>
      <url>/post/8f4877b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="课程内容概述与准备"><a href="#课程内容概述与准备" class="headerlink" title="课程内容概述与准备"></a>课程内容概述与准备</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li><a href="http://www.git-scm.com/">Git 官网</a></li><li>常见 Linux 命令介绍</li><li>Git 在各种平台下的安装和配置</li><li>分布式与集中式版本控制系统的差别</li><li>缓存区、工作区与 Git 的提交</li><li>版本回退</li><li>修改与撤销修改、文件添加与删除</li><li>Git 对象类型与索引</li><li>Git 分支</li><li>如何创建、切换与删除分支</li><li>Git 分支在项目开发中的作用</li><li>Git 分支在工程化项目中的最佳实践</li><li>分支常见重要命令详解</li><li>Git merge</li><li>Git 冲突解决策略</li><li>HEAD 详解</li><li>Git commit 修改详情</li><li>远程版本库的介绍</li><li>如何使用远程版本库</li><li>Git push、pull、fetch 使用注意事项</li><li>Git 合并的基本原则</li><li>Git 别名、config 文件详情</li><li>Git tag 详情</li><li>如何创建与推送 tag</li><li>Git feature 分支详解</li><li>Git subtree 详解</li><li>Git subtree的使用方式详解</li><li>.gitignore 的正确使用方式</li><li>Git 私服 Gitlab 的搭建方法</li><li>在公司内部使用 Gitlab 作为版本控制服务器。</li><li>Gitlab 使用详情</li><li>如何使用 Gitlab 管理项目分组、用户角色</li><li>Git issue 与提交使用技巧</li><li>Github 使用方法介绍</li><li>.gitignore 最佳实践</li></ul><h2 id="课程准备"><a href="#课程准备" class="headerlink" title="课程准备"></a>课程准备</h2><h3 id="Mac-电脑开发环境"><a href="#Mac-电脑开发环境" class="headerlink" title="Mac 电脑开发环境"></a>Mac 电脑开发环境</h3><ul><li><p>Mac 自带了 Git</p></li><li><p>Mac 终端</p></li><li><p>查看 git 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>bash 功能过于单一，安装 oh-my-zsh</p></li><li><p>下载 iterm2</p><ul><li><a href="http://www.iterms.com/">官网下载</a></li><li>安装完成后，在 &#x2F;bin 目录下会多出一个 zsh 的文件</li><li>原生的 bash 环境配置文件 .bash_profile 迁移到 .zshrc 文件中，修改环境配置可以在 .zshrc 文件中修改</li></ul></li><li><p>Mac 系统默认使用 bash 作为终端，可以使用命令修改默认使用 zsh 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></li><li><p>如果想修改回默认 bash ，同样使用 chsh 命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>oh-my-zsh 的 curl 安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>oh-my-zsh 的 wget 安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="常见-Linux-命令"><a href="#常见-Linux-命令" class="headerlink" title="常见 Linux 命令"></a>常见 Linux 命令</h2><ol><li>创建文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdkir mygit</span><br></pre></td></tr></table></figure></li><li>进入桌面文件夹<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li><li>回到上一层目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></li><li>回到之前目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure></li><li>回退主目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></li><li>显示当前路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li><li>显示当前路径下的文件内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li>显示当前路径下的所有文件内容(包括隐藏文件)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure></li><li>将光标移到行头<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control a(键盘)</span><br></pre></td></tr></table></figure></li><li>将光标移到行尾<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control e(键盘)</span><br></pre></td></tr></table></figure></li><li>抛弃错误命令<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control c(键盘)</span><br></pre></td></tr></table></figure></li><li>新建文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test.txt</span><br></pre></td></tr></table></figure></li><li>vi 打开和修改文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt</span><br></pre></td></tr></table></figure></li><li>vi 下的一些常用命令</li></ol><ul><li>显示行号<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：set number</span><br></pre></td></tr></table></figure></li><li>进入插入模式<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i(键盘)</span><br></pre></td></tr></table></figure></li><li>退出插入模式<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Esc(键盘)</span><br></pre></td></tr></table></figure></li><li>保存并退出文件(插入模式)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Esc(键盘)</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure></li><li>往下滚屏<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control f(键盘)</span><br></pre></td></tr></table></figure></li><li>往上滚屏<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control b(键盘)</span><br></pre></td></tr></table></figure></li><li>定位到最后一行<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift g(键盘)</span><br></pre></td></tr></table></figure></li><li>定位到某一行<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: number(键盘)</span><br></pre></td></tr></table></figure></li><li>删除某一行<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: number d d (键盘)</span><br></pre></td></tr></table></figure></li><li>光标移到行尾并切换到插入模式<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift a(键盘)</span><br></pre></td></tr></table></figure></li></ul><ol start="15"><li>查看文件内容<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt</span><br></pre></td></tr></table></figure></li><li>复制文件、粘贴文件<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp test.txt test2.txt</span><br></pre></td></tr></table></figure></li><li>清屏(两种方式)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">control l(快捷键)</span><br></pre></td></tr></table></figure></li><li>文件重命名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> test2.txt text3.txt</span><br></pre></td></tr></table></figure></li><li>文件删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> test3.txt</span><br></pre></td></tr></table></figure></li><li>命令使用具体方法查询(查看帮助文档)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">rm</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 使用 iTerm2 进行远程服务器文件的上传下载</title>
      <link href="/post/67502ae4.html"/>
      <url>/post/67502ae4.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在 Windows 下面使用 xShell 时，经常使用 sz 命令进行文件的上传下载非常方便。</li><li>在 Mac 下面就不能直接使用了，需要进行配置才能使用这么方便的功能。</li></ol><h2 id="安装-lrzsz"><a href="#安装-lrzsz" class="headerlink" title="安装 lrzsz"></a>安装 lrzsz</h2><ul><li>安装 lrzsz<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure></li><li>安装完成后检查是否存在<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -alh /usr/local/bin/sz</span><br></pre></td></tr></table></figure></li><li>lrzsz 是对 zmodem 协议实现的软件包</li></ul><h2 id="配置-iTerm2-属性"><a href="#配置-iTerm2-属性" class="headerlink" title="配置 iTerm2 属性"></a>配置 iTerm2 属性</h2><ul><li><p>拉取<a href="https://gitcode.net/mirrors/mmastrac/iterm2-zmodem?utm_source=csdn_github_accelerator">相关仓库</a> </p></li><li><p>上面仓库主要文件如下： </p><ul><li>iterm2-recv-zmodem.sh </li><li>iterm2-send-zmodem.sh</li></ul></li><li><p>将两个脚本 copy 到 &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 文件夹下面 </p></li><li><p>设置一下两个脚本的权限，一般 chmod 777 就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure></li><li><p>设置 iterm2 的 Tirgger 特性， profiles -&gt; default -&gt; editProfiles -&gt; Advanced 中的 Tirgger</p></li><li><p>添加两条 trigger，分别设置 Regular expression，Action，Parameters，Instant 如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.第一条</span><br><span class="line">        Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">        Action: Run Silent Coprocess</span><br><span class="line">        Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line">        Instant: checked</span><br><span class="line">2.第二条</span><br><span class="line">        Regular expression: \*\*B00000000000000</span><br><span class="line">        Action: Run Silent Coprocess</span><br><span class="line">        Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br><span class="line">        Instant: checked</span><br></pre></td></tr></table></figure></li><li><p>添加过程如下：</p><p><img src="/img/loading.gif" data-original="../../img/posts/mac/lrzsz_01.png" width = 98% height = 100% /><p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/weixin_34067980/article/details/91773253">iTerm2 使用 zmodem 协议上传下载文件</a></li><li><a href="https://blog.csdn.net/weixin_34115824/article/details/88036529">在 Mac 上使用 iTerm2 进行 sz 和 rz 命令进行远程服务器文件的上传下载功能</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iTerm2 </tag>
            
            <tag> lrzsz </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 MySQL</title>
      <link href="/post/59e50a26.html"/>
      <url>/post/59e50a26.html</url>
      
        <content type="html"><![CDATA[<h2 id="下载-mysql"><a href="#下载-mysql" class="headerlink" title="下载 mysql"></a>下载 mysql</h2><ul><li><a href="https://dev.mysql.com/downloads/mysql/">官方网站</a></li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_01.png" width = 90% height = 100% /><p><ul><li>双击打开下载的 mysql-8.0.22-macos10.15-x86_64.dmg 安装包</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_02.png" width = 90% height = 100% /><p><ul><li>一路点击继续，直到以下画面</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_03.png" width = 90% height = 100% /><p><ul><li>选择 Use Legacy Password Encryption</li><li>此处需要你设置一个密码，记住这个密码是你日后登录 mysql 的密码</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_04.png" width = 90% height = 100% /><p><ul><li>完成之后，打开系统偏好设置，会发现下面多出了 mysql 的小图标 </li><li>双击打开 mysql 的小图标 </li><li>如果显示 Start MySQL Server，表示现在是停止运行的，点击按钮即可运行 mysql</li><li>如果显示显示 Stop MySQL Server，表示现在是正在运行的，点击按钮即可停止 mysql</li></ul><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul><li>修改 .zshrc 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>添加环境变量<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Path to your mysql installation.</span><br><span class="line">export PATH=$PATH:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure></li><li>使更改立即生效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="登录-mysql"><a href="#登录-mysql" class="headerlink" title="登录 mysql"></a>登录 mysql</h2><ul><li>登录 mysql<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></li><li>输入密码，即可进入 mysql 数据库操作</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/mirajay_yeah/article/details/110388507">转载: Mac 安装 mysql (极简)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 Anaconda 教程</title>
      <link href="/post/3bae1910.html"/>
      <url>/post/3bae1910.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>Anaconda 指的是一个开源的 Python 发行版本，其包含了 conda、Python 等 180 多个科学包及其依赖项。</li><li>因为包含了大量的科学包，Anaconda 的下载文件比较大(约 531 MB)，如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版(仅包含 conda 和 Python)。</li><li>Anaconda 包括 Conda、Python 以及一大堆安装好的工具包，比如：Numpy、Pandas 等。</li><li>Miniconda 包括 Conda、Python。</li><li>conda 是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。</li></ol><h2 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h2><ul><li><a href="https://docs.anaconda.com/anaconda/install/">Anaconda 官方下载网址</a></li><li>选择 mac 版本，下载好软件包后一路默认安装，dmg 安装会自动添加环境变量</li></ul><h2 id="Anaconda-换源"><a href="#Anaconda-换源" class="headerlink" title="Anaconda 换源"></a>Anaconda 换源</h2><ul><li>打开 Anaconda 软件，初始化后，会在用户目录下生成 .condarc 文件</li><li>修改 .condarc 文件，更换清华镜像源<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure></li><li>安装完 Anaconda，终端默认进入 Anaconda 中的 base 环境，这里取消默认设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Anaconda-基本命令"><a href="#Anaconda-基本命令" class="headerlink" title="Anaconda 基本命令"></a>Anaconda 基本命令</h2><ul><li>查看当前的 conda 版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></li><li>常看当前所有的环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure></li><li>创建新的 Python 环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name python=3.6.2</span><br></pre></td></tr></table></figure></li><li>切换环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure></li><li>退出环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate env_name</span><br></pre></td></tr></table></figure></li><li>移除环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n env_name --all</span><br></pre></td></tr></table></figure></li></ul><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><ul><li>查看当前环境的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li>查看指定 xxx 环境下的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n xxx</span><br></pre></td></tr></table></figure></li><li>查找包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search xxx</span><br></pre></td></tr></table></figure></li><li>更新包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure></li><li>更新所有库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure></li><li>更新 conda 自身<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></li><li>更新 anaconda 自身<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure></li><li>安装包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xxx</span><br></pre></td></tr></table></figure></li><li>也可指定安装的环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name xxx</span><br></pre></td></tr></table></figure></li><li>卸载包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove xxx</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/qq_31573519/article/details/82845515">Mac 安装 anaconda 及其基本命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 Go 环境</title>
      <link href="/post/67a9606f.html"/>
      <url>/post/67a9606f.html</url>
      
        <content type="html"><![CDATA[<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><ul><li><a href="https://go.dev/dl/">官方源下载</a> </li><li><a href="https://studygolang.com/dl">国内源下载</a></li><li>直接下一步安装即可</li></ul><h2 id="GO111MODULE-设置"><a href="#GO111MODULE-设置" class="headerlink" title="GO111MODULE 设置"></a>GO111MODULE 设置</h2><ul><li>设置 GO111MODULE<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置-GOPATH"><a href="#配置-GOPATH" class="headerlink" title="配置 GOPATH"></a>配置 GOPATH</h2><ul><li>查看具体信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span></span><br></pre></td></tr></table></figure></li><li>在用户目录(&#x2F;Users&#x2F;mac)下，新建 go 目录，再在下面建立 bin pkg src 文件夹</li><li>修改 .zshrc 文件，添加环境变量<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) vim ~/.zshrc</span><br><span class="line">(2) 添加</span><br><span class="line">export GOPATH=/Users/用户名/go</span><br><span class="line">(3) 使更改立即生效</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/082549479701">Mac 安装 go 语言</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台 java 开发环境搭建教程</title>
      <link href="/post/87aba1ef.html"/>
      <url>/post/87aba1ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h2><ul><li>在安装 JDK 之前，先查看下自己电脑是否已经安装了 JDK</li><li>打开终端，输入 java –version 并回车<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java 17.0.1 2021-10-19 LTS</span><br><span class="line">Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)</span><br></pre></td></tr></table></figure></li><li>从上图中可以看出我们已安装了 JDK 17</li><li>如果这个版本是你需要的版本，可直接看如何配置 Java 开发环境</li></ul><h2 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h2><ul><li><a href="https://www.oracle.com/java/technologies/downloads/">官网下载</a></li><li>JDK 安装</li><li>MAC 系统 JDK 安装是很简单的，一路下一步就 ok 了</li></ul><h2 id="配置-Java-开发环境"><a href="#配置-Java-开发环境" class="headerlink" title="配置 Java 开发环境"></a>配置 Java 开发环境</h2><ul><li>MAC 默认安装目录为 &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;</li><li>编辑 ～&#x2F;.zshrc 文件，添加环境变量(前提：事先装了 oh-my-zsh)</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/java_01.png" width = 100% height = 100% /><p><ul><li>使更改立即生效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><ul><li>可以用文本编辑器写程序，保存为后缀为 Test.java 的 Java 文件，进行程序测试<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/wyaokai/p/12520494.html">MAC 系统 java 开发环境搭建教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台给 Github 配置 SSH</title>
      <link href="/post/ff91de0c.html"/>
      <url>/post/ff91de0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="配置本地-Git"><a href="#配置本地-Git" class="headerlink" title="配置本地 Git"></a>配置本地 Git</h2><ul><li>打开终端 </li><li>Git 全局设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;github 账户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;注册 github 所用邮箱&quot;</span></span><br></pre></td></tr></table></figure></li><li>查看配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><ul><li><p>主目录下(&#x2F;Users&#x2F;用户名)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure></li><li><p>如果不存在 .ssh 文件夹，新建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .ssh</span><br></pre></td></tr></table></figure></li><li><p>切换文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br></pre></td></tr></table></figure></li><li><p>生成公私钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;注册 github 所用邮箱&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>一路回车，出现如下画面表示成功</p><p><img src="/img/loading.gif" data-original="../../img/posts/mac/ssh_01.png" width = 30% height = 30% /><p></li><li><p>查看公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>复制密钥，进入 github ，然后点击 Setting -&gt; SSh and GPG keys -&gt; New SSH key ，将复制 id_rsa.pub 内容粘贴上去即可</p></li><li><p>验证是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Github </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/post/d98ef1d2.html"/>
      <url>/post/d98ef1d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><ul><li><a href="https://leetcode-cn.com/problems/two-sum/">题目传送门</a></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一：暴力破解"><a href="#方法一：暴力破解" class="headerlink" title="方法一：暴力破解"></a>方法一：暴力破解</h4><h5 id="个人解"><a href="#个人解" class="headerlink" title="个人解"></a>个人解</h5><ul><li><p>关键点：用两层循环进行解题</p></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        loop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> j, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> num + v == target:</span><br><span class="line">                        result.append(i)</span><br><span class="line">                        result.append(j)</span><br><span class="line">                        loop = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> loop:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    resultSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    Loop:</span><br><span class="line">    <span class="comment">// 1. 循环遍历 nums</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 2. 循环遍历 nums</span></span><br><span class="line">        <span class="keyword">for</span> j, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 3. 判断元素是否重复</span></span><br><span class="line">            <span class="keyword">if</span> i != j &#123;</span><br><span class="line">                <span class="comment">// 4. 两数之和等于目标值</span></span><br><span class="line">                <span class="keyword">if</span> num + v == target &#123;</span><br><span class="line">                    resultSlice = <span class="built_in">append</span>(resultSlice, i)</span><br><span class="line">                    resultSlice = <span class="built_in">append</span>(resultSlice, j)</span><br><span class="line">                    <span class="keyword">break</span> Loop</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>个人总结： </p><ul><li>Python3 版本提交结果 ✅ ，执行用时 6524 ms，内存消耗 15.5 MB。</li><li>Golang 版本提交结果 ✅ ，执行用时 48 ms，内存消耗 3.4 MB。</li><li>可改进点：第二次遍历的时候，应该从 i + 1 元素开始。</li></ul></li></ul><h5 id="官方解"><a href="#官方解" class="headerlink" title="官方解"></a><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">官方解</a></h5><ul><li><p>关键点：</p><ul><li>最容易想到的方法是枚举数组中的每一个数 x ，寻找数组中是否存在 target - x 。 </li><li>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。 </li><li>而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x 。</li></ul></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> x+nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</li><li>空间复杂度：O(1)。</li></ul></li></ul><h4 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h4><h5 id="个人解-1"><a href="#个人解-1" class="headerlink" title="个人解"></a>个人解</h5><ul><li><p>关键点：用哈希表进行解题</p></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        records = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 用枚举更方便，就不需要通过索引再去取当前位置的值</span></span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - val <span class="keyword">not</span> <span class="keyword">in</span> records:</span><br><span class="line">                records[val] = idx</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [records[target - val], idx] <span class="comment"># 如果存在就返回字典记录索引和当前索引</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    resultSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    sliceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sliceMap[num] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := sliceMap[target - v]; ok &#123;</span><br><span class="line">            <span class="keyword">if</span> j == sliceMap[target - v] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            resultSlice = <span class="built_in">append</span>(resultSlice, j)</span><br><span class="line">            resultSlice = <span class="built_in">append</span>(resultSlice, sliceMap[target - v])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>个人总结：</p><ul><li>Python3 版本提交结果 ✅ ，执行用时 28 ms，内存消耗 16 MB。 </li><li>Golang 版本提交结果 ✅ ，执行用时 8 ms，内存消耗 5.4 MB。 </li><li>可改进点：哈希表添加元素和匹配可以同时进行。</li></ul></li></ul><h5 id="官方解-1"><a href="#官方解-1" class="headerlink" title="官方解"></a><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">官方解</a></h5><ul><li><p>关键点：</p><ul><li>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。 </li><li>因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。 </li><li>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N^2) 降低到 O(1)。 </li><li>这样我们创建一个哈希表，对于每一个 x ，我们首先查询哈希表中是否存在 target - x ，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</li></ul></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target-x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x ，我们可以 O(1) 地寻找 target - x 。 </li><li>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台配置 iTerm2 + oh-my-zsh</title>
      <link href="/post/9ca5bb98.html"/>
      <url>/post/9ca5bb98.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mac-安装-iTerm2"><a href="#Mac-安装-iTerm2" class="headerlink" title="Mac 安装 iTerm2"></a>Mac 安装 iTerm2</h2><ul><li>下载 iTerm2</li><li><a href="https://www.iterm2.com/index.html">官方链接</a></li></ul><h2 id="Mac-安装-oh-my-zsh"><a href="#Mac-安装-oh-my-zsh" class="headerlink" title="Mac 安装 oh-my-zsh"></a>Mac 安装 oh-my-zsh</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>Mac 系统一般预置安装了 zsh，如果当前默认 shell 是 bash，则修改默认 shell，如果默认的 shell 是 zsh，则不改变<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></li><li>你的 Mac 上需要安装 git</li></ul><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ul><li>克隆代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure></li><li>备份已有的 .zshrc 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/.zshrc ~/.zshrc.bak</span><br></pre></td></tr></table></figure></li><li>新建一个 zsh 的配置文件，可以拷贝一份已有的模板文件来创建 zsh 的配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>重新打开一个终端窗口，它将自动开启加载 oh-my-zsh 配置的 zsh</li><li>以上四步结束后，可能会存在 zsh 目录权限问题，解决问题如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 /usr/local/share/zsh</span><br><span class="line"><span class="built_in">chmod</span> 755 /usr/local/share/zsh/site-functions</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><h4 id="命令高亮插件"><a href="#命令高亮插件" class="headerlink" title="命令高亮插件"></a>命令高亮插件</h4><ul><li>下载高亮插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting ~/.zsh/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></li><li>编辑配置文件，使用插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>在 .zshrc 文件的 plugins 后面加入 zsh-syntax-highlighting 插件名</li><li>重启终端</li></ul><h4 id="命令提示插件"><a href="#命令提示插件" class="headerlink" title="命令提示插件"></a>命令提示插件</h4><ul><li>下载命令提示插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li><li>编辑配置文件，使用插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>在 .zshrc 文件的 plugins 后面加入 zsh-autosuggestions 插件名</li><li>重启终端</li></ul><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="更换-zsh-主题为-Dracula"><a href="#更换-zsh-主题为-Dracula" class="headerlink" title="更换 zsh 主题为 Dracula"></a>更换 zsh 主题为 Dracula</h3><ul><li>下载主题文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dracula/zsh.git</span><br></pre></td></tr></table></figure></li><li>创建一个指向 oh-my-zsh 主题文件夹的符号链接，DRACULA_THEME 是刚才下载主题的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s <span class="variable">$DRACULA_THEME</span>/dracula.zsh-theme ~/.oh-my-zsh/themes/dracula.zsh-theme</span><br></pre></td></tr></table></figure></li><li>修改 zsh 主题，编辑 .zshrc 文件，修改 ZSH_THEME 为 “dracula” <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line">ZSH_THEME=<span class="string">&quot;dracula&quot;</span> </span><br></pre></td></tr></table></figure></li></ul><h3 id="更换-iterm2-主题为-Dracula"><a href="#更换-iterm2-主题为-Dracula" class="headerlink" title="更换 iterm2 主题为 Dracula"></a>更换 iterm2 主题为 Dracula</h3><ul><li><p>下载 iterm2 的 Dracula 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dracula/iterm.git</span><br></pre></td></tr></table></figure></li><li><p>设置主题</p><ul><li>iTerm2 &gt; Preferences &gt; Profiles &gt; Colors Tab</li><li>Open the Color Presets…</li><li>从列表中选择 import</li><li>选择刚才下载主题中 Dracula.itermcolors 文件，确定</li></ul></li><li><p>再次打开 Color Presets… ，选择 Dracula</p></li><li><p>重启终端</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/daiyuhe/article/details/88667875">利用 iTerm2+oh-my-zsh+Dracula 主题打造我的 Mac 终端利器</a></li><li><a href="https://blog.csdn.net/qq_43656353/article/details/106444661">关于 zsh 目录权限问题的解决</a></li><li><a href="https://blog.csdn.net/weixin_43376075/article/details/110840009">mac 入门-安装 oh my zsh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iTerm2 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> Dracula </tag>
            
            <tag> oh-my-zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 MongoDB</title>
      <link href="/post/d6049e8.html"/>
      <url>/post/d6049e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB-下载"><a href="#MongoDB-下载" class="headerlink" title="MongoDB 下载"></a>MongoDB 下载</h2><ul><li>MongoDB 提供了 Mac 平台上 64 位的安装包，你可以在官网下载安装包</li><li><a href="https://www.mongodb.com/try/download/community">官方下载链接</a></li></ul><h2 id="MongoDB-安装步骤"><a href="#MongoDB-安装步骤" class="headerlink" title="MongoDB 安装步骤"></a>MongoDB 安装步骤</h2><ul><li>找到下载的 MongoDB 压缩文件 mongodb-macos-x86_64-5.0.5.tgz</li><li>移动文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> mongodb-macos-x86_64-5.0.5.tgz /usr/local/</span><br></pre></td></tr></table></figure></li><li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf mongodb-macos-x86_64-5.0.5.tgz</span><br></pre></td></tr></table></figure></li><li>重命名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> mongodb-macos-x86_64-5.0.5/ mongodb</span><br></pre></td></tr></table></figure></li><li>删除压缩文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> mongodb-macos-x86_64-5.0.5.tgz</span><br></pre></td></tr></table></figure></li><li>添加环境变量(安装过 oh-my-zsh)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) vim ~/.zshrc</span><br><span class="line">(2) 添加 PATH</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/mongodb/bin</span><br><span class="line">(3) 使修改立即生效</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>创建日志及数据存放的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 切换到 /usr/local/var/db 目录</span><br><span class="line"><span class="built_in">mkdir</span> mongodb</span><br><span class="line">(2) 切换到 /usr/local/var/log 目录</span><br><span class="line"><span class="built_in">touch</span> mongodb.log</span><br></pre></td></tr></table></figure></li><li>添加配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(1) 切换到 /usr/local/etc 目录下</span><br><span class="line">(2) vim mongodb.conf</span><br><span class="line">(3) 添加内容</span><br><span class="line"><span class="comment"># 数据库路径</span></span><br><span class="line">dbpath=/usr/local/var/db/mongodb</span><br><span class="line"><span class="comment"># 日志输出文件路径</span></span><br><span class="line">logpath=/usr/local/var/log/mongodb.log</span><br><span class="line"><span class="comment"># 错误日志采用追加模式</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 启用日志文件，默认启用</span></span><br><span class="line">journal=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span></span><br><span class="line">quiet=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 端口号 默认为27017</span></span><br><span class="line">port=27017</span><br><span class="line"><span class="comment"># 允许远程访问</span></span><br><span class="line"><span class="comment"># bind_ip=0.0.0.0</span></span><br><span class="line"><span class="comment"># 开启子进程</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 开启认证，必选先添加用户，先不开启（不用验证账号密码）</span></span><br><span class="line"><span class="comment"># auth=true</span></span><br></pre></td></tr></table></figure></li><li>直接设置配置文件启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongodb.conf</span><br></pre></td></tr></table></figure></li><li>另外开启新的终端，输入 mongo 命令进入 MongoDB 数据库</li><li>正常退出数据库(mongo 执行命令的终端窗口)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) use admin</span><br><span class="line">(2) db.shutdownServer()</span><br><span class="line">(3) control + c</span><br></pre></td></tr></table></figure><h2 id="MongoDB-常用命令"><a href="#MongoDB-常用命令" class="headerlink" title="MongoDB 常用命令"></a>MongoDB 常用命令</h2></li></ul><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">db.help()</td><td align="center">查看命令提示</td></tr><tr><td align="center">db</td><td align="center">查看当前所在数据库的名字</td></tr><tr><td align="center">use 数据库名</td><td align="center">表示切换或是创建数据库</td></tr><tr><td align="center">show dbs</td><td align="center">显示有数据的库</td></tr><tr><td align="center">db.stats()</td><td align="center">查看当前数据的状态</td></tr><tr><td align="center">db.version()</td><td align="center">查看 MongoDB 版本</td></tr><tr><td align="center">db.[数据库名].insert()</td><td align="center">插入数据</td></tr><tr><td align="center">db.[数据库名].find()</td><td align="center">查找数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 Homebrew</title>
      <link href="/post/48976.html"/>
      <url>/post/48976.html</url>
      
        <content type="html"><![CDATA[<h2 id="brew-安装脚本"><a href="#brew-安装脚本" class="headerlink" title="brew 安装脚本"></a>brew 安装脚本</h2><ul><li>brew 安装脚本(国内源)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span> </span><br></pre></td></tr></table></figure></li><li>傻瓜式安装(建议选择中科大源)</li></ul><h2 id="brew-卸载脚本"><a href="#brew-卸载脚本" class="headerlink" title="brew 卸载脚本"></a>brew 卸载脚本</h2><ul><li>brew 卸载脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>brew 常用命令</li></ul><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">安装软件</td><td align="center">brew install xxx</td></tr><tr><td align="center">卸载软件</td><td align="center">brew uninstall xxx</td></tr><tr><td align="center">搜索软件</td><td align="center">brew search xxx</td></tr><tr><td align="center">更新软件</td><td align="center">brew upgrade xxx</td></tr><tr><td align="center">查看列表</td><td align="center">list</td></tr><tr><td align="center">更新 brew</td><td align="center">brew update</td></tr><tr><td align="center">清理所有包的旧版本</td><td align="center">brew cleanup</td></tr><tr><td align="center">清理指定包的旧版本</td><td align="center">brew cleanup $FORMULA</td></tr><tr><td align="center">查看可清理的旧版本包，不执行实际操作</td><td align="center">brew cleanup -n</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/032ce92e4c7b?utm_campaign=shakespeare">转载: homebrew 安装、卸载、基本操作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
