<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第八章 高级键盘技巧</title>
      <link href="/post/fbd34a1b.html"/>
      <url>/post/fbd34a1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-高级键盘技巧"><a href="#第八章-高级键盘技巧" class="headerlink" title="第八章 高级键盘技巧"></a>第八章 高级键盘技巧</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>UNIX 被称为它是为喜欢敲键盘的人设计的系统。当然，UNIX 中存在命令行的这一事实充分证明了一点。</li><li>用户使用命令行时往往不喜欢敲入太多字，所以命令行中存在类似 cp、ls、mv 和 rm 的短命令。</li><li>事实上，省事 (即用最少的击键次数执行最多的任务) 是命令行最希望达到的目标之一。</li><li>命令行的另一个目标是，用户在执行任务时手指无需离开键盘，不使用鼠标。</li><li>我们将使用到以下命令：</li></ol><ul><li>clear: 清屏</li><li>history: 显示历史列表的记录</li></ul><h2 id="编辑命令行"><a href="#编辑命令行" class="headerlink" title="编辑命令行"></a>编辑命令行</h2><ol><li>基本介绍</li></ol><ul><li>bash 使用了一个名为 Readline 的库 (供不同的应用程序共享使用的线程集合) 来实现命令行的编辑。</li></ul><ol start="2"><li>光标移动</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl-A</td><td align="center">移动光标到行首</td></tr><tr><td align="center">Ctrl-E</td><td align="center">移动光标到行尾</td></tr><tr><td align="center">Ctrl-F</td><td align="center">光标向前移动一个字符；和右箭头键作用一样</td></tr><tr><td align="center">Ctrl-B</td><td align="center">光标向前移动一个字符；和左箭头键作用一样</td></tr><tr><td align="center">Alt-F</td><td align="center">光标向前移动一个字</td></tr><tr><td align="center">Alt-B</td><td align="center">光标向后移动一个字</td></tr><tr><td align="center">Ctrl-l</td><td align="center">清屏并把光标移到左上角；clear 命令可以完成相同工作</td></tr></tbody></table><ol start="3"><li>修改文本</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl-D</td><td align="center">删除光标处的字符</td></tr><tr><td align="center">Ctrl-T</td><td align="center">使光标处的字符和它前面的字符对调位置</td></tr><tr><td align="center">Alt-T</td><td align="center">使光标处的字符和它前面的字对调位置</td></tr><tr><td align="center">Alt-L</td><td align="center">把光标到字尾的字符换成小写字母形式</td></tr><tr><td align="center">Alt-U</td><td align="center">把光标到字尾的字符换成大写字母形式</td></tr></tbody></table><ol start="4"><li>剪切和粘贴文本</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl+K</td><td align="center">剪切从光标到行尾的文本</td></tr><tr><td align="center">Ctrl+U</td><td align="center">剪切从光标到行尾的文本</td></tr><tr><td align="center">Alt-D</td><td align="center">剪切从光标到当前词尾的文本</td></tr><tr><td align="center">Alt-Backspace</td><td align="center">剪切从光标到词头的文本。如果光标在一个单词，则剪切前一个单词</td></tr><tr><td align="center">Ctrl-Y</td><td align="center">把 kill-ring 缓冲区的文本粘贴到光标的位置</td></tr></tbody></table><h2 id="自动补齐功能"><a href="#自动补齐功能" class="headerlink" title="自动补齐功能"></a>自动补齐功能</h2><ol><li>基本介绍</li></ol><ul><li>shell 的一种称为自动补齐的机制为用户提供了很大的帮助。在输入命令时，按 Tab 键将触发自动补齐功能。 </li><li>假设用户目录如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop ls-output.txt Pictures Templates Videos</span><br><span class="line">Documents Music Public</span><br></pre></td></tr></table></figure></li><li>输入如下命令，但是不要按 Enter 键。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> l</span><br></pre></td></tr></table></figure></li><li>此时按 Tab 键：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> ls-output.txt</span><br></pre></td></tr></table></figure></li><li>再看另一个例子，同样也不要按 Enter 键。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> D</span><br></pre></td></tr></table></figure></li><li>按下 Tab 键：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> D</span><br></pre></td></tr></table></figure></li><li>没有自动补齐–只有哔哔声。这是因为字母 D 和目录一个以上的名称匹配。要让自动补齐功能生效，要保证输入的内容不模棱两可，即必须是确定性的。</li><li>如果我们继续输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> Do</span><br></pre></td></tr></table></figure></li><li>此时按下 Tab 键：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">ls</span> Documents </span><br></pre></td></tr></table></figure></li><li>自动补齐功能这次生效了。</li><li>自动补齐也可以针对变量 (如果单词是以 $ 开头) 、用户名 (如果单词以 ~ 开头) 、命令 (如果单词是命令行的第一个单词) 和主机名 (如果单词以 @ 开头) 起作用。</li><li>主机名的自动补齐只对 &#x2F;etc&#x2F;hosts 目录下的主机名生效。</li></ul><ol start="2"><li>自动补全命令</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Alt-$</td><td align="center">显示所有可能的自动补全列表。在大多数系统中，可通过按两次 Tab 键实现，而且也会更容易一些</td></tr><tr><td align="center">Alt-*</td><td align="center">插入所有可能的匹配项。当需要用到一个以上的匹配项时候，将比较有用</td></tr></tbody></table><h2 id="使用历史命令"><a href="#使用历史命令" class="headerlink" title="使用历史命令"></a>使用历史命令</h2><ol><li>基本介绍</li></ol><ul><li>第一章我们已经提到，bash 会保存使用过命令的历史记录。这些命令的历史记录列表保存在用户主目录的 .bash_history 文件中。</li><li>这些历史记录非常有用，可以大大减少用户敲打键盘的次数，特别是和命令行编辑结合使用的时候。</li></ul><ol start="2"><li>搜索历史命令</li></ol><ul><li>任何情况下，我们都可以通过如下命令查看历史记录内容列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure></li><li>bash 默认会保存用户最近使用过的 500 个命令。其中，500 是个默认值，关于如何改变这个默认值在第十一章介绍。</li><li>假设我们想找到用来列出 &#x2F;usr&#x2F;bin 目录下内容的命令，我们可以这样做：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">history</span> | grep /usr/bin</span><br></pre></td></tr></table></figure></li><li>假设得到的搜索结果中有一行包含如下有趣的命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88 <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>数字 88 表示这个命令行在历史记录列表中所处的行号，我们可以通过使用名为历史记录扩展 (history expansion) 的扩展类型来立即使用它。</li><li>为了使用我们发现的命令行，可以如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ !88</span><br></pre></td></tr></table></figure></li><li>bash 将把 !88 扩展为历史列表中的 88 行的内容。</li><li>bash 也支持以递增方式搜索历史记录。也就是说，当搜索历史记录时，随着输入字符数的增加，bash 会相应地改变搜索范围。</li><li>按下 Ctrl-R 键，接着输入你要查找的内容时，按 Enter 键表示执行此命令，而按 Ctrl-J 将把搜索到的内容从历史记录列表中复制到当前命令行。当要查找下一个匹配项时 (即向前搜索历史记录) ，再次按下 Ctrl-R 键。</li><li>请看下面例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>首先按下 Ctrl-R<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(reverse-i-search) <span class="string">&#x27;&#x27;</span>:</span><br></pre></td></tr></table></figure></li><li>提示符发生改变，提示正在进行逆向递增式搜索。称为逆向是因为查的是从现在到过去的某个时间之间的操作。</li><li>接下来，输入要查找的内容，这个例子中是查找 &#x2F;usr&#x2F;bin 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(reverse-i-search) <span class="string">&#x27;/usr/bin&#x27;</span>: <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt </span><br></pre></td></tr></table></figure></li><li>很快搜索操作返回了结果。此时我们可按 Enter 键执行搜索结果，也可按下 Ctrl-J 把搜索结果复制到当前命令行以便做进一步的编辑。</li><li>假定按下 Ctrl-J ，把搜索结果复制到当前命令行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@Linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>shell 将实时响应，命令行将被加载，准备运行。</li></ul><ol start="3"><li>历史记录命令</li></ol><table><thead><tr><th align="center">组合键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Ctrl-p</td><td align="center">移动到前一条历史记录。相当于向上箭头键</td></tr><tr><td align="center">Ctrl-N</td><td align="center">移动到后一条历史记录。相当于向下箭头键</td></tr><tr><td align="center">Alt-&lt;</td><td align="center">移动到历史记录列表的开始处</td></tr><tr><td align="center">Alt-&gt;</td><td align="center">移动到历史记录列表的结尾处。即当前命令行</td></tr><tr><td align="center">Ctrl-R</td><td align="center">逆向递增地搜索。从当前命令行向前递增搜索</td></tr><tr><td align="center">Alt-P</td><td align="center">逆向非递增地搜索。按下这个组合键，接着输入待搜索的字符串，在按 Enter 键后，搜索才真正执行</td></tr><tr><td align="center">Alt-N</td><td align="center">向前非递增地搜索</td></tr><tr><td align="center">Ctrl-O</td><td align="center">执行历史记录列表中的当前项，执行完跳到下一项。若要把历史记录中的一系列命令重新执行一遍，使用该组合键将很方便</td></tr></tbody></table><ol start="4"><li>历史记录扩展命令</li></ol><table><thead><tr><th align="center">序列</th><th align="center">行为</th></tr></thead><tbody><tr><td align="center">!!</td><td align="center">重复最后一个执行的命令。按向上箭头再按 Enter 键也可以实现相同的功能，而且操作更简单</td></tr><tr><td align="center">!number</td><td align="center">重复历史记录中第 number 行的命令</td></tr><tr><td align="center">!string</td><td align="center">重复最近的以 string 开头的历史记录</td></tr><tr><td align="center">!？string</td><td align="center">重复最近的包含 string 的历史记录</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 透过 Shell 看世界</title>
      <link href="/post/ffbaef4b.html"/>
      <url>/post/ffbaef4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-透过-Shell-看世界"><a href="#第七章-透过-Shell-看世界" class="headerlink" title="第七章 透过 Shell 看世界"></a>第七章 透过 Shell 看世界</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在本章，我们将介绍在按下 Enter 键时，命令行中发生的一些神奇事情。</li><li>虽然我们会介绍 shell 的几个有趣而复杂的特性，但是我们只使用一条新命令来处理。</li></ol><ul><li>echo: 显示一行文本</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>每次输入命令行按下 Enter 键时，bash 都会执行之前的对文本进行多重处理。</li><li>前面已经见过一个简单的字符序列 (比如 * ) 在 shell 中被识别为多种意思的例子。产生这个结果的处理过程称为扩展 (expansion) 。</li><li>有了扩展功能，再输入内容后，这些内容将在 Shell 对其执行之前被扩展成其他内容。</li><li>echo 是 shell 的一个内置命令，它执行的任务非常简单，即把文本参数内容打印到标准输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li>上面例子相当简单，传递 echo 的任何参数都将显示出来。</li><li>我们可以看看另一个例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">echo</span> *</span><br><span class="line">Desktop Documents ls-output.txt Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure></li><li>* 字符意味着匹配文件名中的任意字符，shell 会在执行 echo 命令前把 * 扩展成其他内容 (在这个例子中，扩展为当前工作目录下的所有文件名) 。</li><li>在按下 Enter 键的时候，shell 会在执行命令前自动扩展命令行中所有符合条件的字符，因此，echo 命令将不可能看到 * 字符，只能看到 * 字符扩展后的结果。</li></ol><h3 id="路径名拓展"><a href="#路径名拓展" class="headerlink" title="路径名拓展"></a>路径名拓展</h3><ol><li>通过使用通配符来实现扩展机制称为路径名扩展 (pathname expansion) 。</li><li>尝试前面章节中使用过的一些技术，将会发现它们实际上就是扩展。下面给定一个主目录，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop ls-output.txt Pictures Templates</span><br><span class="line">Documents Music Public Videos</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> D*</span><br><span class="line">Desktop Documents</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> *s</span><br><span class="line">Documents Pictures Temolates Videos</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> [[:upper:]]*</span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> /usr/*/share</span><br><span class="line">/usr/kerberos/share /usr/local/share</span><br></pre></td></tr></table></figure></li></ol><h3 id="波浪线扩展"><a href="#波浪线扩展" class="headerlink" title="波浪线扩展"></a>波浪线扩展</h3><ol><li>回顾前面对 cd 命令的介绍，你会发现波浪线字符 ~ 具有特殊的含义。</li><li>如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户命名，则扩展为当前用户的主目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有指定用户</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> ~</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> ~foo</span><br><span class="line">/home/foo</span><br></pre></td></tr></table></figure></li></ol><h3 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h3><ol><li>基本介绍</li></ol><ul><li>shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $((<span class="number">2</span>+<span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li>算术扩展使用如下格式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$((expression))     <span class="comment">#  其中，expression 是包含数值和算术操作符的算术表达式</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>算术扩展操作符</li></ol><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">除 (但是记住，因为扩展只支持整数运算，所以结果也是整数)</td></tr><tr><td align="center">%</td><td align="center">取余，即余数</td></tr><tr><td align="center">**</td><td align="center">取幂</td></tr></tbody></table><ol start="3"><li>算术扩展使用细节</li></ol><ul><li>空格在算术表达式中是没有意义的，而且表达式是可以嵌套的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(($((<span class="number">5</span>**<span class="number">2</span>))*3))</span><br></pre></td></tr></table></figure></li><li>你可以使用一对括号来组合多个子表达式。通过该技术，可以把上面的例子重写，用一个扩展来替代两个，可以得到同样的结果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(((<span class="number">5</span>**<span class="number">2</span>)*<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li><li>下面的例子使用了除运算符和取余运算符，注意整数相除的结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> Five divided by two equals $((<span class="number">5</span>/<span class="number">2</span>))</span><br><span class="line">Five divided by two equals 2</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> with $((<span class="number">5</span>%<span class="number">2</span>)) left over.</span><br><span class="line">with 1 left over.</span><br></pre></td></tr></table></figure></li></ul><h3 id="花括号扩展"><a href="#花括号扩展" class="headerlink" title="花括号扩展"></a>花括号扩展</h3><ol><li>花括号扩展 (brace expansion) 可能算是最奇怪的扩展方式了。有了它，你可以按照花括号里面的模式创建多种文本字符串。实例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br></pre></td></tr></table></figure></li><li>用于花括号扩展的模式信息可以包含一个称为前导字符 (preamble) 的开头部分和一个称为附言 (postscript) 的结尾部分。</li><li>花括号表达式本身可以包含一系列逗号分隔符的字符串，也可以包含一系列整数或者单个字符。这里的模式信息不能包含内嵌的空白。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br></pre></td></tr></table></figure></li><li>下面输出一系列逆序排列的字母。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> &#123;Z..A&#125;</span><br><span class="line">Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br></pre></td></tr></table></figure></li><li>花括号最普遍的应用是创建一系列的文件或者目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> Pics</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> Pics</span><br><span class="line">[me@linuxbox Pics]$ <span class="built_in">mkdir</span> &#123;2009..2010&#125;-0&#123;1..9&#125; &#123;2009..2010&#125;-&#123;10..12&#125;</span><br><span class="line">[me@linuxbox Pics]$ <span class="built_in">ls</span></span><br><span class="line">2009-01 2009-07 2010-01 2010-07</span><br><span class="line">2009-02 2009-08 2010-02 2010-08</span><br><span class="line">2009-03 2009-09 2010-03 2010-09</span><br><span class="line">2009-04 2009-10 2010-04 2010-10</span><br><span class="line">2009-05 2009-11 2010-05 2010-11</span><br><span class="line">2009-06 2009-12 2010-06 2010-12</span><br></pre></td></tr></table></figure></li></ol><h3 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a>参数扩展</h3><ol><li>参数扩展用在 shell 脚本中比直接用在命令行中更为有用。</li><li>它的许多特性与系统存储小块数据以及给每小块数据命令的性能有关。很多这样的小块数据 (称为变量 [variable] 会更合适) 可用于扩展。</li><li>例如，命名为 USER 的变量包含你的用户名，为了触发参数扩展，并显示出 USER 的内容，你可以进行如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">me</span><br></pre></td></tr></table></figure></li><li>想要查看可用的变量列表，试试如下操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printenv</span> | less</span><br></pre></td></tr></table></figure></li><li>对于其他的扩展类型来说，如果你误输入了一个模式，就不会发生扩展，这时 echo 命令将只是显示这些误输入的模式信息。但是对于参数扩展来说，如果变量名拼写错误，仍然会进行扩展，只不过结果是输出一个空字符串而已，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$SUER</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li></ol><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><ol><li>命令替换可以把一个命令的输出作为一个扩展模式使用，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(<span class="built_in">ls</span>)</span><br><span class="line">Desktop Documents ls-output.txt Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure></li><li>另外一种用法：<br>[me@linuxbox ~]$ ls -l $(which cp)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp</span><br></pre></td></tr></table></figure></li><li>这里，把 which cp 命令的运行结果作为 ls 命令的一个参数，因此我们无需知道 cp 程序的完整路径就能获得 cp 程序对应的列表。</li><li>这个功能并不只是局限于简单的命令，也可以应用于整个管道中 (只不过只显示部分输出内容) 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ file $(<span class="built_in">ls</span> /usr/bin* | grep zip)</span><br><span class="line">/usr/bin/bunzip2: symbolic <span class="built_in">link</span> to <span class="string">&#x27;bzip2&#x27;</span></span><br><span class="line">/usr/bin/bzip2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs)，<span class="keyword">for</span> GNU/Linux 2.69, stripped</span><br></pre></td></tr></table></figure></li><li>在早期的 shell 程序中，存在命令替换的另一种语法，bash 也支持这种格式。它用反引号替代美元符号和括号，具体如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l `<span class="built_in">which</span> <span class="built_in">cp</span>`</span><br><span class="line">-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp</span><br></pre></td></tr></table></figure></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>shell 有多种方式可以执行扩展，现在我们来学习如何控制扩展。先看下面的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> this  is a <span class="built_in">test</span></span><br><span class="line">this is <span class="built_in">test</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> The total is <span class="variable">$100</span>.00</span><br><span class="line">The total is 00.00</span><br></pre></td></tr></table></figure></li><li>在第一个例子，shell 会对 echo 命令的参数列表进行单词分割 (word splitting) ，去除多余的空白。在第二个例子中，因为 $1 是一个未定义的变量，所以参数扩展把 $1 的值替换为空字符串。</li><li>shell 提供了一种称为引用 (quoting) 的机制，用来选择性地避免不想要的扩展。</li></ol><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><ol><li>我们要看的第一种引用类型是双引号 (double quote) 。</li><li>如果把文本放在双引号中，那么 shell 使用的所有特殊字符都将失去他们的特殊含义，而被看成普通字符。字符 $(美元符号)、(反斜杠)、&#96;(反引号) 除外。</li><li>这就意味着单词分割、路径名扩展、波浪线扩展和花括号扩展都将失效，但是参数扩展、算术扩展、命令替换仍然生效。</li><li>使用双引号能够处理文件名中包含空白的情况。</li><li>假设不幸地有一个名为 two words.txt 的文件，如果在命令行中使用该文件名，那么单词分割功能将把它当成两个独立的参数，而不是当成我们希望的单个参数，具体运行结果如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l two words.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access two: No such file or directory</span><br><span class="line"><span class="built_in">ls</span>: cannot access words.txt: No such file or directory</span><br></pre></td></tr></table></figure></li><li>使用双引号可以阻止单词分割，得到预期的效果。另外，使用双引号甚至可以修复破损的文件名，参考下面的例子。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l <span class="string">&quot;two words.txt&quot;</span></span><br><span class="line">-rw-rw-r-- 1 me me 18 2012-02-20 13:03 two words.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> <span class="string">&quot;two words.txt&quot;</span> <span class="string">&quot;two_words.txt&quot;</span></span><br></pre></td></tr></table></figure></li><li>参数扩展、算术扩展和命令替换在双引号中依然生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$USER</span> <span class="subst">$((2+2)</span>) <span class="subst">$(cal)</span>&quot;</span></span><br><span class="line">me 4 February 2012</span><br><span class="line">Su  Mo Tu We Th Fr Sa</span><br><span class="line">           1  2  3  4</span><br><span class="line"> 5   6  7  8  9 10 11</span><br><span class="line"> 12 13 14 15 16 17 18</span><br><span class="line"> 19 20 21 22 23 24 25</span><br><span class="line"> 26 27 28 29</span><br></pre></td></tr></table></figure></li><li>默认情况下，单词分割会先查找是否存在空格、制表符以及换行 (换行字符) ，然后把它们当作单词见的界定符 (delimiter) 。这就意味着没有用引号包含起来的空格、制表符和换行字符都不会被当成文本的一部分，而只是被当成分割符。</li><li>单词分割机制会把换行字符当成界定符，这一点在命令替换将会产生微妙有趣的效果。参考下面例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(cal)</span><br><span class="line">February 2012 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cal)</span>&quot;</span></span><br><span class="line">    February 2012</span><br><span class="line">Su  Mo Tu We Th Fr Sa</span><br><span class="line">           1  2  3  4</span><br><span class="line"> 5   6  7  8  9 10 11</span><br><span class="line"> 12 13 14 15 16 17 18</span><br><span class="line"> 19 20 21 22 23 24 25</span><br><span class="line"> 26 27 28 29</span><br></pre></td></tr></table></figure></li><li>在第一个例子中，没有加上引号的命令替换将导致命令行被识别为命令后面跟 38 个参数；而在第二个例子中加了双引号，使得命令行被识别为命令后面只跟一个参数，这个参数包含着嵌入空格和换行字符。</li></ol><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><ol><li>如果我们希望抑制所有扩展，那么应使用单引号。下面是不使用引号、使用双引号和使用单引号的情况对比。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> text ~/*.txt &#123;a,b&#125; $(<span class="built_in">echo</span> foo) $((<span class="number">2</span>+<span class="number">2</span>)) <span class="variable">$USER</span></span><br><span class="line">text /home/me/ls-output.txt a b foo 4 me</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;text ~/*.txt &#123;a,b&#125; <span class="subst">$(echo foo)</span> <span class="subst">$((2+2)</span>) <span class="variable">$USER</span>&quot;</span></span><br><span class="line">text ~/*.txt &#123;a,b&#125; foo 4 me</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;</span></span><br><span class="line">text ~/*.txt &#123;a,b&#125; $(<span class="built_in">echo</span> foo) $((<span class="number">2</span>+<span class="number">2</span>)) <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li><li>可以看到，随着引用级别的加强，越来越多扩展将被抑制。</li></ol><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ol><li>基本介绍</li></ol><ul><li>有时候我们只是想要引用单个字符，这种情况可以通过在该字符前加上反斜杠来实现。这里的反斜杠称为转义字符。</li><li>转义字符经常在双引号中用来有选择性地组织扩展。如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The balance for user <span class="variable">$USER</span> is: \$5.00&quot;</span></span><br><span class="line">The balance <span class="keyword">for</span> user <span class="variable">$USER</span> is: <span class="variable">$5</span>.00</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>转义字符也常用来消除文件名中某个字符的特殊含义。</li><li>比如，文件名中可以使用在 shell 中通常具有特殊含义的字符。这些字符包括 $、!、&amp;、空格等。想要在文件名中包含特殊字符，可执行如下操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> bad\&amp;filename good_filename</span><br></pre></td></tr></table></figure></li><li>如果想要显示反斜杠字符，可以通过使用两个反斜杠 \\ 来实现。</li></ol><ul><li>反斜杠转义字符序列</li></ul><table><thead><tr><th align="center">转义字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">响铃 (警告声-计算机发出哔哔声音)</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\n</td><td align="center">新的一行 (在类 UNIX 系统中，产生的是换行效果)</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\t</td><td align="center">制表</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 重定向</title>
      <link href="/post/544753df.html"/>
      <url>/post/544753df.html</url>
      
        <content type="html"><![CDATA[<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章我们将要探讨命令行最酷的功能- I&#x2F;O 重定向。</li><li>I&#x2F;O 是输入&#x2F;输出 (input&#x2F;output) 的缩写。这个功能可以把命令行的输入的重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中。</li><li>如果我们将多个命令行关联起来，将形成非常强大的命令-管道。</li><li>本章的主要命令：</li></ol><ul><li>cat: 合并文件</li><li>sort: 对文本进行排序</li><li>uniq: 报告或删除文件中的重复的行 </li><li>wc: 打印文件中的换行符、字和字节的个数 </li><li>grep: 打印匹配行 </li><li>head: 输出文件的第一部分内容 </li><li>tail: 输出文件的最后一部分内容 </li><li>tee: 读取标准输入的数据，并将其内容输出到标准输出和文件中</li></ul><h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>目前为止，我们使用过的很多程序生成不同种类的输出。</li><li>这些输出通常包含两种类型。一种是程序运行的结果，即该程序生成的数据；另一种是状态和错误信息，表示程序当前的运行情况。</li><li>比如输入 ls 命令，屏幕上将显示它的运行结果以及它的相关错误信息。</li><li>与 UNIX 系统一切都是文件的思想一致，类似 ls 的程序实际上把它们的运行结果发送到一个称为标准输出 (standard output，通常称为 stdout) 的特殊文件中，它们的状态信息则发送到另一个成为标准错误 (standard error，表示为 stderr) 的文件中。</li><li>默认情况下，标准输出和标准错误都将被链接到屏幕上，并且不会被保存在磁盘文件中。</li><li>另外，许多程序从一个称为标准输入 (standard input，表示为 stdin) 的设备来输入。默认情况下，标准输入连接到键盘。</li><li>I&#x2F;O 重定向功能可以改变输出内容发送的目的地，也可以改变输入内容的来源地。</li><li>通常来说，输出内容显示在屏幕上，输入内容来自于硬盘，但是使用 I&#x2F;O 重定向功能可以改变这一惯例。</li></ol><h3 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h3><ol><li>I&#x2F;O 重定向功能可以重新定义标准输出内容发送到哪里。</li><li>使用重定向操作符 &gt; ，后面接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上。它主要用于把命令的输出内容保存到一个文件中</li><li>比如，我们可以按照下面的形式把 ls 命令的输出保存到 ls-output.txt 文件中，而不是输出到屏幕上<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>这里，我们将创建 &#x2F;usr&#x2F;bin 目录的一个长列表信息，并把这个结果输出到 ls-output.txt 文件中。</li><li>检查下该命令被重定向的输出内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 167878 2012-02-01 15:07 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>如果使用 less 命令查看这个文件，我们可以看到 ls-output.txt 文件确定包含了 ls 命令的执行结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less ls-output.txt</span><br></pre></td></tr></table></figure></li><li>现在，让我们重复重定向测试，但是这次做一点变换。我们把目录名称换成一个不存在的目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr &gt; ls-output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access /bin/usr: No such file or directory</span><br></pre></td></tr></table></figure></li><li>我们会收到一条错误信息。因为我们指定的是一个不存在的目录 &#x2F;bin&#x2F;usr&#x2F; ，所以这个错误信息是正确的。</li><li>这个错误信息显示在屏幕上，而不是重定向到 ls-output.txt 文件中的原因：ls 程序并不会把它运行的错误信息发送到标准输出文件中。</li><li>而是与大多数写得很好的 UNIX 程序一样，它把错误信息发送到标准错误文件中。因为我们只重定向了标准输出，并没有重定向标准错误，所以这个错误信息仍然输出在屏幕上。</li><li>我们首先看看这个输出文件发生的变化。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2012-02-01 15:08 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>当前这个文件大小为零。这是因为当使用重定向符 &gt; 来重定向标准输出时，目的文件通常会从文件开头部分重新改写。由于 ls 命令执行后没有输出任何内容，只显示一条错误信息，所以重定向操作开始重新改写这个文件，并在出现错误的情况下停止操作，最终导致了该文件内容被删除。</li><li>事实上，如果我们需要删除一个文件内容 (或创建一个新的空文件) ，可以采用这样的方式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>仅仅使用了重定向符，并在它之前不加任何命令，就可以删除一个已经存在的文件内容或者创建一个新的空文件。</li><li>如果我们想不从文件的首位置开始覆盖文件，而是从文件的尾部开始添加输出内容，可以使用重定向符 &gt;&gt; 来实现，比如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>使用重定向符 &gt;&gt; 将使得输出内容添加在文件的尾部。如果这个文件并不存在，将与操作符 &gt; 的作用一样创建这个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 503634 2012-02-01 15:45 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>重复执行这条命令三次，系统将最终生成一个为原来三倍大小的输出文件。</li></ol><h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><ol><li>标准错误的重定向并不能简单地使用一个专用的重定向符来实现。要实现标准错误的重定向，不得不提到它的文件描述符 (file descriptor) 。</li><li>一个程序可以把生成的输出内容发送任意文件流中。</li><li>如果把这些文件流中的前三个分别对应标准输入文件、标准输出文件和标准错误文件，那么 shell 将在内部用文件描述符分别索引它们为 0 ，1 和 2 。</li><li>shell 提供了使用文件描述编号来重定向文件的表示法。由于标准错误等同于文件描述符 2 ，所以可以使用这种表示法来重定向标准错误。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure></li><li>文件描述符 2 紧放在重定向符之前，将标准错误重定向到 ls-error.txt 文件中。</li></ol><h3 id="将标准输出和标准错误重定向到同一个文件"><a href="#将标准输出和标准错误重定向到同一个文件" class="headerlink" title="将标准输出和标准错误重定向到同一个文件"></a>将标准输出和标准错误重定向到同一个文件</h3><ol><li>在许多情况下，我们会希望把一个命令的所有输出内容都放在同一个独立的文件中。为此，我们必须同时重定向标准输出和标准错误。</li><li>有两种方法可以满足要求，第一种是传统的方法，在旧版本的 shell 中使用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li><li>使用这种方法，将执行两个重定向操作。首先重定向标准输出和标准输出到 ls-output.txt 文件中，然后使用标记符 2&gt;&amp;1 把文件描述符 2(标准错误) 重定向到文件描述符 1(标准输出) 中。</li><li>注意：这些重定向操作的顺序是非常重要的。标准错误的重定向通常发生在标准输出重定向之后，否则它将不起作用。</li><li>在上面的例子中，&gt;ls-output.txt 2&gt;&amp;1 把标准错误重定向到 ls-output.txt 文件中，但是如果顺序改变为 2&gt;&amp;1 &gt;ls-output.txt ，那么标准错误将会重定向到屏幕上。</li><li>最近的 bash 版本提供了效率更高的第二种方法来实现这一联合的重定向操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure></li><li>这个例子中，只使用一个标记符 &amp;&gt; 就把标准输出和标准错误都重定向到了 ls-output.txt 文件中。</li></ol><h3 id="处理不想要的输出"><a href="#处理不想要的输出" class="headerlink" title="处理不想要的输出"></a>处理不想要的输出</h3><ol><li>有时候沉默是金，命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。</li><li>系统提供了一种方法，即通过把输出重定向到一个称为 &#x2F;dev&#x2F;null 的特殊文件中来实现它。</li><li>这个文件是一个称为位桶 (bit bucket) 的系统设备，它接受输入但是不对输入进行任何处理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure></li></ol><h3 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h3><ol><li>cat - 合并文件</li></ol><ul><li>cat 命令读取一个或多个文件，并把它们复制到标准输出文件中，格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [file...]</span><br></pre></td></tr></table></figure></li><li>在大多数情况下，你可以认为 cat 命令和 DOS 中的 TYPE 命令类似。使用它显示文件而不需要分页，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox]$ <span class="built_in">cat</span> ls-output.txt</span><br></pre></td></tr></table></figure></li><li>上面命令将显示 ls-output.txt 文件的内容。cat 经常用来显示短的文本文件</li><li>由于 cat 可以接受多个文件作为输入参数，所以它也可以用来把文件连接在一起</li><li>假设我们下载了一个很大的文件，它已被拆分为多个部分 (Usenet 上的多媒体文件经常采用拆分是这种方式) ，现在我们想要把各部分连接在一起，并还原为原来文件</li><li>如果这些文件命名为 moive.mpeg.001 movie.mpeg.002…movie.mpeg.099 ，我们可以使用这个命令让它们重新连接在一起<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></table></figure></li><li>通配符一般都是按照顺序来扩展的，因此这些参数将正确的顺序来排序</li><li>如果输入 cat 命令却不带任何参数，它将从标准输入读取内容。由于标准输入在默认情况下是连接到键盘，所以实际上它正在等待着从键盘输入内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span></span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>下一步，按下 Ctrl-D (按住 Ctrl 键同时按下 D) ，告知 cat 命令它已经达到了标准输入的文件尾 (end-of-file, EOF) <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span></span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>在缺少文件名参数的情况下，cat 把标准输入内容复制到标准输出文件中，因此我们将可以看到文本行重复显示。用这种方法我们可以创建短的文本文件</li><li>如果想要创建一个名叫 lazy_dog.txt 的文件，文件中包含之前例子中的文本内容，我们可以这样做：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>在 cat 命令后输入想要放在文件中的文本内容。记住在文件结束时按下 Ctrl-D 。为了看到结果，我们可以使用 cat 命令再次把文件复制到标准输出文件中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>现在我们已经知道 cat 命令除了接受文件名参数之外，是如何接受标准输入的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &lt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure></li><li>使用重定向符 &lt; ，我们把标准输入的源从键盘变成 lazy_dog.txt 文件</li><li>可以看到，得到的结果和只传递单个文件名参数结果一样。和传输一个文件名参数的方式作对比，这种方式并不是特别有用，但是可以用来说明把一个文件作为标准输入的源文件</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>命令从标准输入到读取数据，并将数据发送到标准输出的能力，是使用了名为管道的 shell 特性。</li><li>使用管道操作符 | (竖线) 可以把一个命令的标准输出传送到另一个命令的标准输入中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command1 | Command2</span><br></pre></td></tr></table></figure></li><li>使用 less 命令可以分页显示任意命令的输入，该命令将它的结果发送到标准输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | less</span><br></pre></td></tr></table></figure></li><li>通过使用该技术，可以很方便地检查任意一条生成标准输出的命令的运行结果。</li></ol><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ol><li>管道功能经常用来对数据执行复杂的操作。也可以多条命令合在一起构成一个管道。这种方式中用到的命令通常被称为过滤器 (filter) 。</li><li>过滤器接受输入，按照某种方法对输入进行改变，然后输出它。</li><li>第一个要用到的命令是 sort 。假设要把 &#x2F;bin 和 &#x2F;usr&#x2F;bin 目录下的所有可执行程序合并成一个列表，并且按照顺序排列，最后再查看这个列表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span> | less</span><br></pre></td></tr></table></figure></li><li>由于我们指定了两个目录 (&#x2F;bin 和 &#x2F;usr&#x2F;bin) ， ls 的输出将包含两个排好序的列表，每个对应一个目录。</li><li>通过在管道中包含 sort 命令，我们改变输出数据，从而产生一个排好序的列表。</li></ol><h3 id="uniq-报告或忽略文件中的重复行"><a href="#uniq-报告或忽略文件中的重复行" class="headerlink" title="uniq - 报告或忽略文件中的重复行"></a>uniq - 报告或忽略文件中的重复行</h3><ol><li>uniq 命令经常和 sort 命令结合使用。</li><li>uniq 可以接受来自于标准输入或者一个单一文件名参数对应的已排好序的数据列表 (可以查看 uniq 命令的 man 页面获取详细信息) 。默认情况下，该命令删除列表中的所有重复行。</li><li>因此，在管道中添加 uniq 命令，可以确保所有列表都没有重复行(即在 &#x2F;bin 和 &#x2F;usr&#x2F;bin 目录下都出现的相同名字的任意程序)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> | less</span><br></pre></td></tr></table></figure></li><li>在这个例子中，我们使用了 uniq 命令来删除来自 sort 命令输出内容中的任意重复行。</li><li>如果反过来想要查看重复行的列表，可以再 uniq 命令后面添加 -d 选项，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> -d | less</span><br></pre></td></tr></table></figure></li></ol><h3 id="wc-打印行数、字数和字节数"><a href="#wc-打印行数、字数和字节数" class="headerlink" title="wc - 打印行数、字数和字节数"></a>wc - 打印行数、字数和字节数</h3><ol><li>wc (字数，word count) 命令用来显示文件中包含的行数、字数和字节数。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">wc</span> ls-output.txt</span><br><span class="line">7902 64566 503634 ls-output.txt</span><br></pre></td></tr></table></figure></li><li>上面例子中，我们打印输出了三个数据，即 ls-output.txt 文件中包含的行数、字数和字节数。</li><li>和前面的命令一样，如果在执行 wc 时没有输入命令行参数，它将接受标准输入内容。</li><li>-l 选项限制命令只报告行数，把它添加在管道中可以很方便地实现计数功能。</li><li>如果我们要查看已排序的列表中的条目数，可以按照以下方式输入。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li></ol><h3 id="grep-打印匹配行"><a href="#grep-打印匹配行" class="headerlink" title="grep - 打印匹配行"></a>grep - 打印匹配行</h3><ol><li>grep 是一个功能强大的程序，它用来在文件中查找匹配文本，其使用方式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern [file...]</span><br></pre></td></tr></table></figure></li><li>当 grep 在文件中遇到模式的时候，就打印出包含该模式的行。 </li><li>grep 能够匹配的模式内容可以是非常复杂的，不过这里，我们只关注简单文本的匹配。</li><li>如果想我们从列出的程序中搜索出文件中包含 zip 的所有文件，该搜索将获悉系统中与文件压缩的相关程序，操作如下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span>| <span class="built_in">uniq</span> | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br></pre></td></tr></table></figure></li><li>grep 存在一对的选项：-i ，该选项使得 grep 在搜索时忽略大小写 (通常情况下，搜索区分大小写) ；-v ，该选项使得 grep 只是输出和模式不匹配的行。</li></ol><h3 id="head-x2F-tail-打印文件的开头部分"><a href="#head-x2F-tail-打印文件的开头部分" class="headerlink" title="head&#x2F;tail - 打印文件的开头部分"></a>head&#x2F;tail - 打印文件的开头部分</h3><ol><li>有的时候，你并不需要命令输出的所有内容，可能只是需要开头几行或者最后几行。</li><li>head 命令将输出文件的前 10 行，tail 命令则输出文件的最后 10 行。默认情况下，这两条命令都是输出文件的 10 行内容，不过可以使用 -n 选项来调整输出的行数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> -n 5 <span class="built_in">ls</span> ls-output.txt</span><br><span class="line">total 343496</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2011-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2011-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2011-11-26 14:27 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2010-10-06 20:16 a52dec</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">tail</span> -n 5 ls-output.txt</span><br><span class="line">-rwxr-xr-x 1 root root 5234 2011-06-27 10:56 znew</span><br><span class="line">-rwxr-xr-x 1 root root 691 2009-09-10 04:21 zonetab2pot.py</span><br><span class="line">-rw-r--r-- 1 root root 930 2011-11-01 12:23 zonetab2pot.pyc</span><br><span class="line">-rw-r--r-- 1 root root 930 2011-11-01 12:23 zonetab2pot.pyo</span><br><span class="line">1rwxrwxrwx 1 root root 6 2012-01-31 05:22 zsoelim -&gt; soelim</span><br></pre></td></tr></table></figure></li><li>这些命令选项也可以应用在管道中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">tail</span> -n 5</span><br><span class="line">zonetab2pot.py</span><br><span class="line">zonetab2pot.pyc</span><br><span class="line">zonetab2pot.pyo</span><br><span class="line">zsoelim</span><br></pre></td></tr></table></figure></li><li>tail 中有一个选项用来实时查看文件，该选项在观察正在被写入的日志文件的进展状态时很有用。</li><li>在下面的例子中，我们将观察 &#x2F;var&#x2F;log 目录下的 messages 文件。</li><li>因为 &#x2F;var&#x2F;log&#x2F;messages 文件可能包含安全信息，所以在一些 Linux 发行版本中，需要有超级用户的权限才能执行该操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure></li><li>使用 -f 选项，tail 将持续监视这个文件，一旦添加了新行，新行就会立即显示在屏幕上。该动作在按下 Ctrl-c 命令后停止。</li></ol><h3 id="tee-从-stdin-读取数据，并同时输出到-stdout-和文件"><a href="#tee-从-stdin-读取数据，并同时输出到-stdout-和文件" class="headerlink" title="tee - 从 stdin 读取数据，并同时输出到 stdout 和文件"></a>tee - 从 stdin 读取数据，并同时输出到 stdout 和文件</h3><ol><li>为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令。就好像安装了一个 T 在管道上。</li><li>tee 程序读取标准输入，再把读到的内容复制到标准输出 (允许数据可以继续向下传递到管理中) 和一个或多个的文件中去。</li><li>当在某个中间处理阶段来捕获一个管道中的内容时，会很有用。我们使用 tee 命令来获取整个目录列表并输出到 ls.txt 文件中，具体操作如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">tee</span> ls.txt | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 命令的使用</title>
      <link href="/post/e0f4dded.html"/>
      <url>/post/e0f4dded.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-命令的使用"><a href="#第五章-命令的使用" class="headerlink" title="第五章 命令的使用"></a>第五章 命令的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章中介绍的命令如下：</li></ol><ul><li>type: 说明如何解释命令名</li><li>which: 显示会执行哪些可执行程序</li><li>man: 显示命令的手册页</li><li>apropos: 显示一系列合适的命令</li><li>info: 显示命令的info条目</li><li>whatis: 显示一条命令的简述</li><li>alias: 创建一条命令的别名</li></ul><h2 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h2><ol><li>可执行程序</li></ol><ul><li>可执行程序就像在 &#x2F;usr&#x2F;bin 目录里看到的所有文件一样。</li><li>在该程序类别中，程序可以编译为二进制文件，比如 C、C++ 语言编写的程序，也可以是 Shell、Perl、Python、Ruby 等脚本语言编写的程序。</li></ul><ol start="2"><li>shell 内置命令</li></ol><ul><li>bash 支持许多在内部称之为 shell builtin 的内置命令。</li></ul><ol start="3"><li>shell 函数</li></ol><ul><li>shell 函数是合并到环境变量中的小型 shell 脚本。</li></ul><ol start="4"><li>alias 命令</li></ol><ul><li>我们可以在其他命令的基础上定义自己的命令。</li></ul><h2 id="识别命令"><a href="#识别命令" class="headerlink" title="识别命令"></a>识别命令</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>能够准确地识别我们使用的命令是上述 4 种命令类型中的哪一种是很有用的。</li></ul><h3 id="type-显示命令的类型"><a href="#type-显示命令的类型" class="headerlink" title="type - 显示命令的类型"></a>type - 显示命令的类型</h3><ol><li><p>type 命令是一个 shell 内置命令，可根据指定的命令名显示 shell 将要执行的命令类型。格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>这里的 command 是想要查看的命令名。一些实例如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linux ~]$ <span class="built_in">type</span> <span class="built_in">type</span></span><br><span class="line"><span class="built_in">type</span> is s shell <span class="built_in">builtin</span></span><br><span class="line">[me@linux ~]$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is aliased to <span class="string">&#x27;ls --color=tty&#x27;</span></span><br><span class="line">[me@linux ~]$ <span class="built_in">type</span> <span class="built_in">cp</span></span><br><span class="line"><span class="built_in">cp</span> is /bin/cp</span><br></pre></td></tr></table></figure></li></ol><h3 id="which-显示可执行程序的位置"><a href="#which-显示可执行程序的位置" class="headerlink" title="which - 显示可执行程序的位置"></a>which - 显示可执行程序的位置</h3><ol><li>有时候，系统可能会安装了一个可执行程序的多个版本。这种现象虽然在桌面系统中不常见，但是在大型服务器中却是很常见。</li><li>使用 which 命令可以确定一个给定可执行文件的准确位置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">which</span> <span class="built_in">ls</span></span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure></li><li>which 命令只适用于可执行程序，而不适用于内置命令和命令别名 (真正可执行程序的替代物) 。</li><li>试图在 shell 内置命令中使用 which 命令时，要么没有响应，要么得到一条错误信息。</li></ol><h2 id="获得命令文档"><a href="#获得命令文档" class="headerlink" title="获得命令文档"></a>获得命令文档</h2><h3 id="help-获得-shell-内置命令的帮助文档"><a href="#help-获得-shell-内置命令的帮助文档" class="headerlink" title="help - 获得 shell 内置命令的帮助文档"></a>help - 获得 shell 内置命令的帮助文档</h3><ol><li>bash 为每一个 shell 内置命令提供了一个内置的帮助工具。输入 help ，然后输入 shell 内置命令的名称即可使用该帮助工具<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">help</span> <span class="built_in">cd</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="man-显示程序的手册页"><a href="#man-显示程序的手册页" class="headerlink" title="man - 显示程序的手册页"></a>man - 显示程序的手册页</h4><ol><li>man 基本介绍</li></ol><ul><li>大多数供命令行使用的可执行文件，提供了一个称之为 manual 或者是 man page 的正式文档。 </li><li>该文档可以用一种称为 man 的特殊的分页程序来查看，用法如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man program </span><br></pre></td></tr></table></figure></li><li>手册文档在格式上会有所不同，但通常都包括标题、命令句法的摘要、命令用途的描述、命令选项列表以及每个命令选项的描述。 </li><li>例如，尝试查看 ls 命令的手册文档<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li>在大多数 Linux 系统中，man 命令调用 less 命令来显示手册文档。所以，当显示手册文档时，你熟悉的所有 less 命令都能奏效</li><li>man 命令显示的手册文档被分成多个部分，它不仅包括用户命令，也包括系统管理命令、程序接口、文件格式等</li></ul><ol start="2"><li>man 手册文档的组织结构</li></ol><table><thead><tr><th align="center">部分</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">用户命令</td></tr><tr><td align="center">2</td><td align="center">内核系统调用的程序接口</td></tr><tr><td align="center">3</td><td align="center">C 库函数程序接口</td></tr><tr><td align="center">4</td><td align="center">特殊文件，如设备节点和驱动程序</td></tr><tr><td align="center">5</td><td align="center">文件格式</td></tr><tr><td align="center">6</td><td align="center">游戏和娱乐，例如屏幕保护程序</td></tr><tr><td align="center">7</td><td align="center">其他杂项</td></tr><tr><td align="center">8</td><td align="center">系统管理命令</td></tr></tbody></table><h3 id="apropos-显示合适的命令"><a href="#apropos-显示合适的命令" class="headerlink" title="apropos - 显示合适的命令"></a>apropos - 显示合适的命令</h3><ol><li>我们有可能会搜索参考手册列表，才进行基于某个搜索条目的匹配。尽管有些粗糙，但是这种方法又是还是很有用的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ apropos floppy</span><br></pre></td></tr></table></figure></li></ol><h3 id="whatis-显示命令的简要描述"><a href="#whatis-显示命令的简要描述" class="headerlink" title="whatis - 显示命令的简要描述"></a>whatis - 显示命令的简要描述</h3><ol><li>whatis 程序显示匹配具体关键字的手册页的名字和一行描述。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ whatis <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="info-显示程序的-info-条目"><a href="#info-显示程序的-info-条目" class="headerlink" title="info - 显示程序的 info 条目"></a>info - 显示程序的 info 条目</h3><ol><li>info 基本介绍</li></ol><ul><li>GNU 项目提供了 info 页面来替代手册文档。 </li><li>info 页面可通过 info 阅读器来显示。 </li><li>info 页面使用超链接，这与网页结构很相似。 </li><li>info 程序读取 info 文件，该文件是树形结构，分为各个单独的节点，每一个节点包含一个主题。 </li><li>info 文件包含的超链接可以实现节点间的跳转。 </li><li>通过前置星号可以识别超链接，将光标放在超链接上并按 Enter 键，可以激活它。 </li><li>可以通过输入 info 以及程序名来调用 info 。 </li><li>到目前为止，我们讨论的大部分命令行程序都是 GNU 项目 coreutils 包的一部分，输入以下内容可以看到更多信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ info coreutils</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>info 页面控制指令</li></ol><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">显示命令帮助</td></tr><tr><td align="center">PAGE UP or BACKSPACE</td><td align="center">返回上一页</td></tr><tr><td align="center">PAGE DOWN or Space</td><td align="center">翻到下一页</td></tr><tr><td align="center">n</td><td align="center">Next - 显示下一个节点</td></tr><tr><td align="center">p</td><td align="center">Previous - 显示上一个节点</td></tr><tr><td align="center">u</td><td align="center">Up - 显示目前显示节点的父节点</td></tr><tr><td align="center">ENTER</td><td align="center">进入光标所指的超链接</td></tr><tr><td align="center">q</td><td align="center">退出</td></tr></tbody></table><h3 id="README-和其他程序文档文件"><a href="#README-和其他程序文档文件" class="headerlink" title="README 和其他程序文档文件"></a>README 和其他程序文档文件</h3><ol><li>系统中安装的很多软件包都有自己的文档文件，它们存放在 &#x2F;usr&#x2F;share&#x2F;doc 目录中。</li><li>其中大部分文档文件是以纯文本格式存储的，因此可以用 less 命令来查看。有些文件是 HTML 格式，并且可以用 Web 浏览器来查看。</li><li>我们可能会遇到一些以 .gz 扩展名结尾的文件。这表明它们是使用 gzip 压缩程序压缩过。</li><li>gzip 包包含一个特殊的 less 版本，称之为 zless 。</li><li>zless 可以显示由 gzip 压缩的文本文件的内容。</li></ol><h2 id="使用别名创建自己的命令"><a href="#使用别名创建自己的命令" class="headerlink" title="使用别名创建自己的命令"></a>使用别名创建自己的命令</h2><ol><li>alias 基本介绍</li></ol><ul><li><p>我们可以通过使用分号来分隔多条命令，就可以将多条命令输入在一行中。其工作方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1;command2;command3...</span><br></pre></td></tr></table></figure></li><li><p>我们将要使用的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr;<span class="built_in">ls</span>;<span class="built_in">cd</span> -</span><br><span class="line">bin games kerberos lib64 <span class="built_in">local</span> share tmp</span><br><span class="line">etc include lib libexec sbin src</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li><p>可以看到，我们将 3 条命令放置在同一行中。首先我们将当前目录改变成 &#x2F;usr ，然后列出这个目录内容，最后返回到原始目录 (使用 cd- ) 。那么程序结束的位置恰恰是开始的位置 </p></li><li><p>我们通过使用 alias 命令将以上命令整合成一条新的命令。首先要为新命令虚构出一个名称，试试名称 test 。不过输入前，我们最好检查一下名称 test 是否已经被使用过了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure></li><li><p>这个名字已经用过了，试试 foo 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">bash:<span class="built_in">type</span>:foo:not found</span><br></pre></td></tr></table></figure></li><li><p>下面创建新命令的别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">alias</span> foo = <span class="string">&#x27;cd /usr;ls;cd -&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>上面的命令结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> name=<span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在 alias 命令之后输入 name ，紧接着是一个等号 (没有空格) ，等号之后是一个用单引号括起来的字符串，该字符串中的内容赋值给 name</p></li><li><p>尝试别名命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo</span><br><span class="line">bin games kerberos lib64 <span class="built_in">local</span> share tmp</span><br><span class="line">etc include lib libexec sbin src</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li><p>再次使用 type 命令来查看别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">foo is aliased to <span class="string">&#x27;cd /usr;ls;cd -&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>要删除别名，可以使用 unalias 命令，如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">unalias</span> foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">bash:<span class="built_in">type</span>:foo:nou found</span><br></pre></td></tr></table></figure></li><li><p>尽管我们有意避免使用已经存在的命名名称来给我们的别名命名，但有时也会期待这么做。这样做的目的是，为每一个经常调用的命令添加一个普遍会用到的选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is aliased to <span class="string">&#x27;ls --color=tty&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>查看环境中定义的所有别名，可使用不带参数的 alias 命令。以下是 Fedora 系统默认定义的一些别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll = <span class="string">&#x27;ls -l --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span> = <span class="string">&#x27;ls --color=tty&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 操作文件与目录</title>
      <link href="/post/4ad1077e.html"/>
      <url>/post/4ad1077e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-操作文件与目录"><a href="#第四章-操作文件与目录" class="headerlink" title="第四章 操作文件与目录"></a>第四章 操作文件与目录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本章将介绍如下命令：</li></ol><ul><li>cp: 复制文件和目录 </li><li>mv: 移动或重命名文件和目录 </li><li>mkdir: 创建目录 </li><li>rm: 移除文件和目录 </li><li>ln: 创建硬链接和符号连接</li></ul><ol start="2"><li>以上 5 个命令属于最常使用 Linux 命令之列，可用来操作文件与目录。</li><li>坦率地说，使用图形文件管理器来执行一些由这些命令执行的任务要容易多。使用文件管理器，我们可以将文件从一个目录拖放到另一个目录，我们可以剪切和粘贴文件，我们可以删除文件。</li><li>使用命令行程序的原因是其具有强大的功能和灵活的操作。</li><li>虽然使用图形文件管理器能轻松实现简单的文件操作，但是对于复杂的任务，使用命令行程序更容易完成。</li><li>例如，将所有 HTML 文件从一个目录复制到目标目录，要完成这个任务，使用文件管理器则相当困难，而使用命令行则很容易。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -u *.html destination</span><br></pre></td></tr></table></figure></li></ol><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ol><li>基本介绍</li></ol><ul><li>在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell 特性</li><li>由于 shell 需要经常使用文件名，因此它提供了一些特殊字符来帮助你快速指定一组文件名，这些特殊字符称为通配符</li><li>通配符 (也叫文件名替换) 允许用户依据字符模式选择文件名</li><li>通配符的使用使得为文件名构建复杂的筛选标准成为可能</li></ul><ol start="2"><li>通配符以及它们所选择的对象</li></ol><table><thead><tr><th align="center">通配符</th><th align="center">匹配项</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配任意多个字符(包括 0 个和 1 个)</td></tr><tr><td align="center">?</td><td align="center">匹配任意单个字符(不包括 0 个)</td></tr><tr><td align="center">[characters]</td><td align="center">匹配任意一个属于字符集中的字符</td></tr><tr><td align="center">[!characters]</td><td align="center">匹配任意一个不属于字符集中的字符</td></tr><tr><td align="center">[[:class:]]</td><td align="center">匹配任意一个属于指定字符类中的字符</td></tr></tbody></table><ol start="3"><li>通配符的字符类</li></ol><table><thead><tr><th align="center">字符类</th><th align="center">匹配项</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">匹配任意一个字符或数字</td></tr><tr><td align="center">[:alpha:]</td><td align="center">匹配任意一个字母</td></tr><tr><td align="center">[:digit:]</td><td align="center">匹配任意一个数字</td></tr><tr><td align="center">[:lower:]</td><td align="center">匹配任意一个小写字母</td></tr><tr><td align="center">[:upper:]</td><td align="center">匹配任意一个大写字母</td></tr></tbody></table><ol start="4"><li>通配符模式及其匹配内容</li></ol><table><thead><tr><th align="center">形式</th><th align="center">匹配项</th></tr></thead><tbody><tr><td align="center">g*</td><td align="center">以 g 开头的任一文件</td></tr><tr><td align="center">b*.txt</td><td align="center">以 b 开头，中间有任意多个字符，并以 .txt 结尾的任一文件</td></tr><tr><td align="center">Data???</td><td align="center">以 Data 开头，后面跟三个字符的任一文件</td></tr><tr><td align="center">[abc]*</td><td align="center">以 abc 中任一开头的任一文件</td></tr><tr><td align="center">BACKUP.[0-9][0-9][0-9]</td><td align="center">以 BACKUP. 开头，后面紧跟 3 个数字的任一文件</td></tr><tr><td align="center">[[:upper:]]*</td><td align="center">以大学字母开头的任一文件</td></tr><tr><td align="center">[![:digit:]]</td><td align="center">不以数字开头的任一文件</td></tr><tr><td align="center">*[[:lower:123]]</td><td align="center">以小写字母或数字 1、2、3 中的任一结尾的文件</td></tr></tbody></table><h2 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir - 创建目录"></a>mkdir - 创建目录</h2><ol><li>mkdir 基本介绍</li></ol><ul><li>mkdir 命令是是用来创建目录的，格式如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory...</span><br></pre></td></tr></table></figure></li><li>创建单个 dir1 目录，输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1</span><br></pre></td></tr></table></figure></li><li>输入以下命令可以创建 3 个目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1 dir2 dir3</span><br></pre></td></tr></table></figure></li></ul><h2 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp - 复制文件和目录"></a>cp - 复制文件和目录</h2><ol><li>cp 基本介绍</li></ol><ul><li>cp 文件用来复制文件和目录，它有两种不同的使用方式。 </li><li>将单个文件或目录 item1 复制到文件或目录 item2 中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item1 item2</span><br></pre></td></tr></table></figure></li><li>将多个项目(文件或目录)复制进一个目录中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item... directory</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>cp 命令选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-a, --archive</td><td align="center">复制文件和目录及其属性，包括所有权和权限。通常来说，复制的文件具有用户所操作文件的默认属性</td></tr><tr><td align="center">-i, --interactive</td><td align="center">在覆盖一个已存在的文件前，提示用户进行确认。如果没有指定该选项，cp 会默认覆盖文件</td></tr><tr><td align="center">-r, --recursive</td><td align="center">递归地复制目录及其内容。复制目录时需要这个选项 (或 -a 选项)</td></tr><tr><td align="center">-u, --update</td><td align="center">当将文件从一个目录复制到另一个目录时，只会复制那些目标目录中不存在的文件或是目标目录相应文件的更新文件</td></tr><tr><td align="center">-v, --verbose</td><td align="center">复制文件时，显示信息性消息 (informative message)</td></tr></tbody></table><ol start="3"><li>cp 命令示例</li></ol><table><thead><tr><th align="center">命令</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">cp file1 file2</td><td align="center">将 file1 复制到 file2 。如果 file2 存在，则会被 file1 的内容覆盖。如果 file2 不存在，则创建 file2</td></tr><tr><td align="center">cp -i file1 file2</td><td align="center">同上，区别在于当 file2 存在时，覆盖之前通知用户确认</td></tr><tr><td align="center">cp file1 file2 dir1</td><td align="center">将 file1 和 file2 复制到目录 dir1 里。dir1 必须已经存在</td></tr><tr><td align="center">cp dir1&#x2F;* dir2</td><td align="center">通过使用通配符，将 dir1 中的所有文件复制到 dir2 中。dir2 必须已经存在</td></tr><tr><td align="center">cp -r dir1 dir2</td><td align="center">将 dir1 目录 (及其内容) 复制到 dir2 目录中。如果 dir2 不存在，创建 dir2 ，且包含与 dir1 目录相同的内容</td></tr></tbody></table><h2 id="mv-移除和重命名文件"><a href="#mv-移除和重命名文件" class="headerlink" title="mv - 移除和重命名文件"></a>mv - 移除和重命名文件</h2><ol><li>mv 基本介绍</li></ol><ul><li>mv 命令可以执行文件移动和文件重命名操作，这具体取决于如何使用它。在这两种情况下，完成操作之后，原来的文件名将不存在</li><li>mv 的使用方法与 cp 基本相似。将文件 (或目录) item1 移动 (或重命名) 为 item2 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item1 item2</span><br></pre></td></tr></table></figure></li><li>将一个或多个条目从一个目录移动到另一个目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item... directory</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>mv 选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-i, --interactive</td><td align="center">覆盖一个已存在的文件之前，提示用户确认。如果没有指定该选项，mv 会默认覆盖文件</td></tr><tr><td align="center">-u, --update</td><td align="center">将文件从一个目录移动到另一个目录，只移动那些目标目录中不存在的文件或是目标目录里相应文件的更新文件</td></tr><tr><td align="center">-v, --verbose</td><td align="center">移动文件时显示信息性消息</td></tr></tbody></table><ul><li>mv 示例</li></ul><table><thead><tr><th align="center">命令</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">mv file1 file2</td><td align="center">将 file1 移到 file2 。如果 file2 存在，则会被 file1 的内容覆盖。如果 file2 不存在，则创建 file2 。无论哪一种情况，file1 不再存在</td></tr><tr><td align="center">mv -i file1 file2</td><td align="center">同上，仅当 file2 存在时，覆盖之前通知用户确认</td></tr><tr><td align="center">mv file1 file2 dir1</td><td align="center">将 file1 和 file2 移动目录 dir1 下。dir1 必须已经存在</td></tr><tr><td align="center">mv dir1 dir2</td><td align="center">将目录 dir1 (和其他内容) 移到目录 dir2 下。如果目录 dir2 不存在，创建目录 dir2 ，将目录 dir1 的内容移到 dir2 下，同时删除目录 dir1</td></tr></tbody></table><h2 id="rm-删除文件和目录"><a href="#rm-删除文件和目录" class="headerlink" title="rm - 删除文件和目录"></a>rm - 删除文件和目录</h2><ol><li>rm 基本介绍</li></ol><ul><li>rm 命令用来移除 (删除文件) 和目录，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> item ...</span><br></pre></td></tr></table></figure></li><li>其中 item 是一个或多个文件 (或目录) 的名称。</li></ul><ol start="2"><li>rm 常用选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-i, --interactive</td><td align="center">删除一个已经存在的文件前，提示用户确认。如果没有指定这个选项，rm 命令会默认删除文件</td></tr><tr><td align="center">-r, --recursive</td><td align="center">递归地删除目录。也就是说，如果删除的目录有子目录的话，也要将其删除。要删除一个目录，则必须指定该选项</td></tr><tr><td align="center">-f, --force</td><td align="center">忽略不存在的文件并无需提示确认。该选项会覆盖 --interactive</td></tr><tr><td align="center">-v, --verbose</td><td align="center">删除文件时显示信息性消息</td></tr></tbody></table><ol start="3"><li>rm 常用实例</li></ol><table><thead><tr><th align="center">命令</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">rm file1</td><td align="center">在不提示用户的情况下，删除 file1</td></tr><tr><td align="center">rm -i file1</td><td align="center">删除 file1 前，提示用户确认</td></tr><tr><td align="center">rm -r file1 dir1</td><td align="center">删除 file1、dir1 以及它们的内容</td></tr><tr><td align="center">rm -rf file1 dir1</td><td align="center">同上，当在 file1 或 dir1 不存在时，rm 仍会继续执行，且不提示用户</td></tr></tbody></table><h2 id="ln-创建链接"><a href="#ln-创建链接" class="headerlink" title="ln - 创建链接"></a>ln - 创建链接</h2><ol><li>ln 概述</li></ol><ul><li>ln 命令可用来创建硬链接或是符号链接。它的使用方式有两种：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建硬链接</span></span><br><span class="line"><span class="built_in">ln</span> file <span class="built_in">link</span></span><br><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line"><span class="built_in">ln</span> -s item <span class="built_in">link</span>   <span class="comment"># 这里的 item 可以是文件也可以是目录。</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>硬链接</li></ol><ul><li>硬链接是最初 UNIX 用来创建链接的方式，符号链接较之更为先进。</li><li>默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，也为这个文件创建了一个额外的目录条目。</li><li>硬链接有两条重要的局限性：<ul><li>硬链接不能引用自身文件系统之外的文件</li><li>硬链接无法引用目录</li></ul></li><li>硬链接和文件本身没有什么区别。与包含符号链接的目录列表不同，包含硬链接的目录列表没有特别的链接指示说明。</li><li>当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在 (也就是说，该空间没有释放) ，除非该文件的所有链接都被删除了。</li></ul><ol start="3"><li>符号链接</li></ol><ul><li>符号链接是为了克服硬链接的局限性而创建的。</li><li>符号链接是通过创建一个特殊类型的文件来起作用的，该文件包含了指向引用文件或目录的文本指针</li><li>符号链接指向的文件与符号链接自身几乎没有区别</li><li>当删除一个符号链接时，删除的只是符号链接而没有删除文件本身</li><li>如果先于符号链接之前删除文件，那么这个链接依然存在，但却不指向任何文件。此时这个链接称为坏链接</li></ul><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><ol><li>概述</li></ol><ul><li>由于我们要做一些实际的文件操作，我们先来创建一个安全的地带，来执行文件操作命令</li><li>首先，我们需要一个工作目录。我们在主目录里创建一个目录并命名为 playground</li></ul><ol start="2"><li>创建目录</li></ol><ul><li>mkdir 命令用来创建一个目录。为了创建 playground 目录，我们首先要保证当前目录是主目录，然后再创建新目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> playground</span><br></pre></td></tr></table></figure></li><li>在 playground 目录中新建两个目录，命名为 dir1 、 dir2</li><li>切换工作目录为 playground ，然后再次执行 mkdir 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> playground</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">mkdir</span> dir1 dir2</span><br></pre></td></tr></table></figure></li><li>需要注意的是， mkdir 命令可以接受多个参数，从而允许我们用一个命令创建两个目录</li></ul><ol start="3"><li>复制文件</li></ol><ul><li>接下来，让我们在创建的目录中放入一些数据，这一过程可以通过文件复制来完成</li><li>通过使用 cp 命令，我们可以将 &#x2F;etc 目录中的 passwd 文件复制到当前工作目录里<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> /etc/passwd .</span><br></pre></td></tr></table></figure></li><li>如果我们此时执行 ls 命令，将会看到我们的文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir2</span><br><span class="line">-rw-r--r-- 1 me me 1650 2012-01-10 16:07 passwd</span><br></pre></td></tr></table></figure></li><li>现在让我们使用 -v 选项，重复操作复制命令，来看看结果如何<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> -v /etc/passwd .</span><br><span class="line"><span class="string">&#x27;/etc/passwd&#x27;</span> -&gt; <span class="string">&#x27;.passwd&#x27;</span></span><br></pre></td></tr></table></figure></li><li>cp 命令再次执行复制操作，但是，这一次显示了一条简洁的信息来指明它正在执行什么操作。</li><li>需要注意的是，在没有任何警告的情况下，cp 命令覆盖了第一次的复制内容。</li><li>cp 命令会假定用户清楚自己当前的操作，加上 -i 选项可以获得警告信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> -i /etc/passwd .</span><br><span class="line"><span class="built_in">cp</span>: overwrite <span class="string">&#x27;./passwd&#x27;</span>?</span><br></pre></td></tr></table></figure></li><li>通过在提示符下输入 y ，文件就会被重写；任何其他的字符会使 cp 命令保留该文件。</li></ul><ol start="4"><li>移动和重命名文件</li></ol><ul><li>现在，passwd 这个名字似乎没有那么有趣，而我们毕竟是在进行实战演练，因此我们给它改个名字。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> passwd fun</span><br></pre></td></tr></table></figure></li><li>现在传送 fun 文件，这是通过将重命名的文件移动到各个目录，然后再移动回当前目录来实现的。<ul><li>首先移到目录 dir1 下，然后：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> fun dir1</span><br></pre></td></tr></table></figure></li><li>将文件从目录 dir1 移到 dir2 ，然后：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1/fun dir2</span><br></pre></td></tr></table></figure></li><li>再将文件 fun 重新移到当前工作目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir2/fun .</span><br></pre></td></tr></table></figure></li></ul></li><li>下面来看 mv 命令的效果。首先，再次将数据文件移到目录 dir1<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> fun dir1</span><br></pre></td></tr></table></figure></li><li>然后将目录 dir1 移到 dir2 并且使用 ls 命令确认<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1 dir2</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir2</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-11 06:06 dir1</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir2/dir1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 me me 1650 2012-01-10 16:33 fun</span><br></pre></td></tr></table></figure></li><li>注意，因为目录 dir2 已经存在，mv 命令将目录 dir1 移到 dir2</li><li>如果 dir2 不存在，mv 将 dir1 重命名为 dir2 。最后，我们将所有东西放回原处<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir2/dir1 .</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1/fun .</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>创建硬链接</li></ol><ul><li><p>现在，我们试着创建一些链接。首先是创建硬链接，我们先按照如下方式创建一些指向数据文件的链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun dir1/fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun dir2/fun-hard</span><br></pre></td></tr></table></figure></li><li><p>目前有 4 个文件 fun 的实例。来看一下 playground 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br></pre></td></tr></table></figure></li><li><p>可以注意到，在列表中，文件 fun 和 fun-hard 的第二个字段都是 4 ，这是文件 fun 存在的硬链接数目</p></li><li><p>由于文件名是由链接创建的，所以一个文件通常至少有一个链接。</p></li><li><p>提到硬链接时，可以想象文件是由两部分组成的，即包含文件内容的数据部分和包含文件名的名称部分。创建硬链接时，实际上是创建了额外的名称，这些名称都指向同一数据部分</p></li><li><p>系统分配了一系列的盘块给所谓的索引节点 (inode) ，该节点随后与文件名称部分建立关联。因此，每个硬链接都指向包含文件内容的具体索引节点</p></li><li><p>ls 命令有一种显示上述信息的方法。它是通过在命令中加上 -i 选项来实现的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 16</span><br><span class="line">12353539 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1</span><br><span class="line">12353540 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2</span><br><span class="line">12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br></pre></td></tr></table></figure></li><li><p>在上面列表中，第一个字段就是索引节点号，可以看到，fun 和 fun-hard 共享同一个索引节点号，这就证实它们是相同的文件。</p></li></ul><ol start="6"><li>创建符号链接</li></ol><ul><li>之所以创建符号链接，是为了克服硬链接的两大不足，即硬链接无法跨越物理设备，也无法引用目录，只能引用文件</li><li>符号链接是一种特殊类型的文件，它包含了指向目标文件或目录的文本指针</li><li>创建符号链接与创建硬链接相似，如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s fun fun-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s ../fun dir1/fun-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s ../fun dir2/fun-sym</span><br></pre></td></tr></table></figure></li><li>创建符号链接时，同时也创建一个文本来描述目标文件与符号链接有关联<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br><span class="line">lrwxrwxrwx 1 me me 6 2012-01-15 15:17 fun-sym -&gt; ../fun</span><br></pre></td></tr></table></figure></li><li>在目录 dir1 中， fun-sym 的列表显示它是一个符号链接，这是通过第 1 个字段中的首字符 1 来确认的，并且它也指 ..&#x2F;fun ，这也是正确的</li><li>相对于 fun-sym 的实际位置，文件 fun 在它的上一级目录。还要注意到，符号链接文件的长度是 6 ，这是 ..&#x2F;fun 字符串中字符的数字，而不是它所指向的文件的长度</li><li>创建符号链接时，可以使用绝对路径名，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s /home/me/playground/fun dir1/fun-sym</span><br></pre></td></tr></table></figure></li><li>也可以使用相对路径，如前面示例所示</li><li>因为相对路径允许包含符号链接的目录被重命名&#x2F;或移动，而且不会破坏链接，因此会更可取一些</li><li>除了普通文件之外，符号链接也可以引用目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s dir1 dir1-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard</span><br><span class="line">lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>移除文件和目录</li></ol><ul><li>前面讲到，使用 rm 命令可以删除文件和目录。那么我们就用它来清空 playground 目录</li><li>首先，我们删除目录中的一个硬链接<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br><span class="line">-rw-r--r-- 3 me me 1650 2012-01-10 16:33 fun</span><br><span class="line">lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure></li><li>文件 file-hard 被删除了，文件 fun 的连接数相应的也由 4 变成了 3</li><li>接下来，我们删除文件 fun ，我们还会加上 -i 选项，看看执行了哪些操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> -i fun</span><br><span class="line"><span class="built_in">rm</span>: remove regular file <span class="string">&#x27;fun&#x27;</span>?</span><br></pre></td></tr></table></figure></li><li>在提示符下输入字符 y ，文件就被删除了。现在看一下 ls 命令的输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 8</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br><span class="line">lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure></li><li>由于 fun-sym -&gt; fun 是一个符号链接，且指向的文件现在已经不存在，所以链接也就被破坏了。</li><li>如果试图调用破坏的链接，将会看到如下情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ less fun-sym</span><br><span class="line">fun-sym: No such file or directory</span><br></pre></td></tr></table></figure></li><li>稍微清理一下，删除符号链接<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> fun-sym dir1-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2</span><br></pre></td></tr></table></figure></li><li>有关于符号链接，需要记住一点，即大部分文件操作是以链接目标为对象的，而非链接本身 </li><li>而 rm 命令是个例外。当删除一个链接的时候，链接本身被删除，但是目标文件依旧存在</li><li>最后，我们需要删除目录 playground 。为此，我们将返回主目录，使用 rm 命令的递归选项 (-r) 来删除 playground 目录以及包括子目录在内的所有内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> -r playground</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 Linux 基本系统</title>
      <link href="/post/2cc576b7.html"/>
      <url>/post/2cc576b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-基本系统"><a href="#Linux-基本系统" class="headerlink" title="Linux 基本系统"></a>Linux 基本系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>既然已经知道了如何在文件系统中跳转，是时候开始 Linux 操作系统之旅了。</li><li>在开始之前，我们要先学习一些对研究 Linux 系统很有帮助的命令。</li></ol><ul><li>ls: 列出目录内容</li><li>file: 确定文件类型</li><li>less: 查看文件内容</li></ul><h2 id="ls-命令的乐趣"><a href="#ls-命令的乐趣" class="headerlink" title="ls 命令的乐趣"></a>ls 命令的乐趣</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>有充足的理由证明， ls 命令很可能是用户最常用的命令。</li><li>通过 ls 命令可以查看目录内容，确定各种重要文件和目录的属性。</li><li>我们已经看到，只需输入 ls 命令，即可查看当前工作目录中包含的一系列文件和子目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos </span><br></pre></td></tr></table></figure></li><li>除了当前工作目录之外，我们还可以指定要显示的，如下所示。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr</span><br><span class="line">bin  games   kerberos libexec  sbin  src</span><br><span class="line">etc  include lib      <span class="built_in">local</span>    share tmp</span><br></pre></td></tr></table></figure></li><li>我们甚至可以指定多个目录。下面这个例子就列出了用户主目录(由符号 ~ 表示)和 &#x2F;usr 目录的内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> ~ /usr</span><br><span class="line">/home/me:</span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos </span><br><span class="line">/usr:</span><br><span class="line">bin  games   kerberos libexec  sbin   src</span><br><span class="line">etc  include lib      <span class="built_in">local</span>    share  tmp</span><br></pre></td></tr></table></figure></li><li>我们也可以改变输出格式来得到更多细节。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 56</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Desktop</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Documents</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Music</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Pictures</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Public</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Templates</span><br><span class="line">drwxrwxr-x 2 me me 4096 2012-10-26 17:20 Videos</span><br></pre></td></tr></table></figure></li><li>在命令中加上 -l ，我们可以将输入以长格式显示。</li></ol><h3 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数"></a>选项和参数</h3><ol><li>ls 选项和参数</li></ol><ul><li>通常，命令后面跟有一个或多个选项，带有不同选项的命令其功能也不一样。 </li><li>此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象。 </li><li>大部分命令看起来如右所示： command -options arguments </li><li>大部分命令使用的选项是在单个字符前加上连字符，如 -l 。 </li><li>但是，很多命令，包括 GNU 项目里的命令，也支持在单字前加两个连字符的长选项。而且，很多命令也允许多个短选项串在一起使用。 </li><li>在下面的例子中， ls 命令包含了两个选项； l 选项产生长格式输出，而 t 选项则表示以文件修改时间的先后将结果进行排序。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure></li><li>加上长选项 --reverse ，则结果会以相反的顺序输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -lt --reverse</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>ls 常用选项</li></ol><table><thead><tr><th align="center">选项</th><th align="center">长选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">--all</td><td align="center">列出所有文件，包括以点号开头的文件，这些文件通常是不列出来的(比如隐藏的文件)</td></tr><tr><td align="center">-d</td><td align="center">--directory</td><td align="center">通常，如果指定了一个目录，ls 命令会列出目录中的内容而不是目录本身。将此选项与 -l 选项结合使用，可查看目录的详细信息，而不是目录中的内容</td></tr><tr><td align="center">-F</td><td align="center">--classify</td><td align="center">选项会在每个所列出的名字后面加上类型指示符(例如，如果名字是目录名，则会加上一个斜杠)</td></tr><tr><td align="center">-h</td><td align="center">--human-readable</td><td align="center">以长格式列出，以人们可读的方式而不是字节数来显示文件大小</td></tr><tr><td align="center">-l</td><td align="center"></td><td align="center">使用长格式显示结果</td></tr><tr><td align="center">-r</td><td align="center">--reverse</td><td align="center">以相反的顺序显示结果。通常， ls 命令按照字母升序排列显示结果</td></tr><tr><td align="center">-S</td><td align="center"></td><td align="center">按文件大小对结果排序</td></tr><tr><td align="center">-t</td><td align="center"></td><td align="center">按修改时间排序</td></tr></tbody></table><h3 id="进一步了解长列表格式"><a href="#进一步了解长列表格式" class="headerlink" title="进一步了解长列表格式"></a>进一步了解长列表格式</h3><ol><li>ls 长列表格式</li></ol><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-rw-r-r–</td><td align="center">对文件的访问权限。第一个字符表示文件的类型。在不同类型之间，开头的 - 表示该文件是一个普通文件，d 表示目录。紧接着的三个字符表示文件所有者的访问权限，再接着的三个字符表示文件所有者访问权限，再接着的三个字符</td></tr><tr><td align="center">1</td><td align="center">文件硬链接数目</td></tr><tr><td align="center">root</td><td align="center">文件所有者的用户名</td></tr><tr><td align="center">root</td><td align="center">文件所属用户组的名称</td></tr><tr><td align="center">32059</td><td align="center">以字节数表示的文件大小</td></tr><tr><td align="center">2012-04-03 11:05</td><td align="center">上次修改文件的日期和时间</td></tr><tr><td align="center">00-cd-cover.odf</td><td align="center">文件名</td></tr></tbody></table><h2 id="使用-file-命令确定文件类型"><a href="#使用-file-命令确定文件类型" class="headerlink" title="使用 file 命令确定文件类型"></a>使用 file 命令确定文件类型</h2><ol><li>在我们探索系统的过程中，知道文件包含的内容是非常有用的。为此，我们可以使用 file 命令来确定文件类型。</li><li>Linux 系统中的文件名不需要反映文件的内容，我们可以这样调用 file 命令： file filename ，调用后， file 命令会打印文件内容的简短说明。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ file picture.jpg</span><br><span class="line">picture.jpg: JPEG image data, JFIF standard 1.01</span><br></pre></td></tr></table></figure></li><li>文件的种类有很多。事实上，在类 UNIX 操作系统中，有个普遍的观念是所有的东西都是一个文件。</li></ol><h2 id="使用-less-命令查看文件内容"><a href="#使用-less-命令查看文件内容" class="headerlink" title="使用 less 命令查看文件内容"></a>使用 less 命令查看文件内容</h2><ol><li>less 基本内容</li></ol><ul><li>less 命令是一种查看文本文件的程序，less 程序为我们查看文件提供方便。 </li><li>less 命令的使用方式如右： less filename </li><li>一旦运行起来，less 程序允许我们前后滚动文件。 </li><li>例如，想要查看定义了系统用户账户的文件，可输入下面命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less /etc/passwd</span><br></pre></td></tr></table></figure></li><li>一旦 less 程序运行起来，我们就可查看文件内容。</li><li>如果文件不止一页，可以上下滚动文件，按 Q 键可退出 less 程序。</li></ul><ol start="2"><li>less 键盘命令</li></ol><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">PAGE UP 或 b</td><td align="center">后翻一页</td></tr><tr><td align="center">PAGE DOWN 或 Space</td><td align="center">前翻一页</td></tr><tr><td align="center">向上箭头</td><td align="center">向上一行</td></tr><tr><td align="center">向下箭头</td><td align="center">向下一行</td></tr><tr><td align="center">G</td><td align="center">跳转到文本文件的末尾</td></tr><tr><td align="center">lG 或 g</td><td align="center">跳转到文本文件的开头</td></tr><tr><td align="center">&#x2F;characters</td><td align="center">向前查找指定的字符串</td></tr><tr><td align="center">n</td><td align="center">向前查找下一个出现的字符串，这个字符串是之前的所指定查找的</td></tr><tr><td align="center">h</td><td align="center">显示帮助屏幕</td></tr><tr><td align="center">q</td><td align="center">退出 less</td></tr></tbody></table><h2 id="快速浏览"><a href="#快速浏览" class="headerlink" title="快速浏览"></a>快速浏览</h2><ol><li>基本介绍</li></ol><ul><li>在 Linux 系统中，文件系统布局与其他类 UNIX 系统很相似。 </li><li>实际上，一个已经发布的名为 Linux 文件系统层次标准 (Linux Filesystem Hierarchy Standard) 的标准，已经详细阐述了这个设计。 </li><li>并不是所有 Linux 发行版都严格符合该标准，但大部分与之很接近。 </li><li>接下来，我们将通过对文件系统的探索来找到 Linux 系统的正常运行所依赖的基础，请尝试下面的步骤： <ul><li>使用 cd 命令进入一个给定的目录 </li><li>使用 ls -l 命令列出目录的内容 </li><li>如果看到一个感兴趣的文件，使用 file 命令确定文件内容 </li><li>如果文件看起来像一个文本，试着使用 less 命令浏览其内容</li></ul></li></ul><ol start="2"><li>Linux 基本目录</li></ol><table><thead><tr><th align="center">目录</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">&#x2F;</td><td align="center">根目录，一切从这里开始</td></tr><tr><td align="center">&#x2F;bin</td><td align="center">包含系统启动和运行所必需的二进制文件、包含 Linux 内核、最初的 RAM 磁盘映像(系统启动时，驱动程序会用到)，以及启动加载程序</td></tr><tr><td align="center">&#x2F;boot</td><td align="center">有趣的文件：&#x2F;boot&#x2F;grub&#x2F;grub.conf 或 menu.lst，&#x2F;boot&#x2F;vmlinuz，Linux 内核</td></tr><tr><td align="center">&#x2F;dev</td><td align="center">这是一个包含设备节点的特殊目录。把一切当成文件也适用于设备，内核将它能够识别的所有设备存放在这个目录</td></tr><tr><td align="center">&#x2F;etc</td><td align="center">&#x2F;etc 目录包含了所有系统层面的配置文件，同时也包含了一系列 shell 脚本，系统每次启动时，这些 shell 脚本都会打开每个系统服务。该目录中包含的内容都应该是可读的文本文件。</td></tr><tr><td align="center">&#x2F;home</td><td align="center">在通常的配置中，每个用户都会在 &#x2F;home 目录中拥有一个属于自己的目录。普通用户只能在自己的主目录中创建文件。这一限制可以保护系统免遭错误的用户行为的破坏。</td></tr><tr><td align="center">&#x2F;lib</td><td align="center">包含核心程序系统使用的共享库文件。这与 Windows 系统中的 DLL 类似</td></tr><tr><td align="center">&#x2F;lost+found</td><td align="center">每个使用 Linux 文件系统的格式化分区或设备，例如 ext3 文件系统，都会有这个目录。当文件系统崩溃时，该目录用于恢复分区。除非系统真的发生很严重的问题，否则这个目录一直是空的。</td></tr><tr><td align="center">&#x2F;media</td><td align="center">在现代 Linux 系统中，&#x2F;media 目录包含可移除媒体设备的挂载点。比如 USB 驱动、CD-ROM 等。这些设备在插入计算机后，会自动挂载到这个目录节点下。</td></tr><tr><td align="center">&#x2F;mnt</td><td align="center">在早期 Linux 系统中，&#x2F;mnt 目录包含手动挂载的可移除设备的挂接点</td></tr><tr><td align="center">&#x2F;opt</td><td align="center">&#x2F;opt 目录用来安装其他可选的软件。主要用来存放可能安装在系统中的商业软件</td></tr><tr><td align="center">&#x2F;proc</td><td align="center">&#x2F;proc 目录很特殊。从文件的角度来说，它不是存储在硬盘中的真正的文件系统，反而是一个 Linux 内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。该文件是可读的，从中可以看到内核是如何监管计算机的</td></tr><tr><td align="center">&#x2F;root</td><td align="center">root 账户的主目录</td></tr><tr><td align="center">&#x2F;sbin</td><td align="center">该目录放置系统二进制文件。这些程序执行重要的系统任务，这些任务通常是为超级用户预留的。</td></tr><tr><td align="center">&#x2F;tmp</td><td align="center">&#x2F;tmp 是供用户存放各类程序创建的临时文件的目录。某些配置使得每次系统重启时会清空该目录</td></tr><tr><td align="center">&#x2F;usr</td><td align="center">&#x2F;usr 目录可能是 Linux 系统中最大的目录树。它包含普通用户使用的所有程序和相关文件</td></tr><tr><td align="center">&#x2F;usr&#x2F;bin</td><td align="center">&#x2F;usr&#x2F;bin 目录中放置了一些 Linux 发行版本安装的可执行程序。该目录通常会存储成千上万个程序</td></tr><tr><td align="center">&#x2F;usr&#x2F;lib</td><td align="center">&#x2F;usr&#x2F;bin 目录中的程序使用的共享库</td></tr><tr><td align="center">&#x2F;usr&#x2F;local</td><td align="center">这个 &#x2F;usr&#x2F;local 目录是并非系统发行版自带，但却打算让系统使用的程序的安装目录。由源代码编译好的程序通常安装在 &#x2F;usr&#x2F;local&#x2F;bin 中，在一个新安装的 Linux 系统中，就存在这么一个目录。但却是空目录，直到系统管理员向其添加内容。</td></tr><tr><td align="center">&#x2F;usr&#x2F;sbin</td><td align="center">包含更多的系统管理程序</td></tr><tr><td align="center">&#x2F;usr&#x2F;share</td><td align="center">&#x2F;usr&#x2F;share 目录里包含 &#x2F;usr&#x2F;bin 中的程序所使用的的全部共享数据，这包括默认配置文件、图标、屏幕背景、音频文件等</td></tr><tr><td align="center">&#x2F;usr&#x2F;share&#x2F;doc</td><td align="center">安装在系统中的大部分程序包包含一些文档文件。在 &#x2F;usr&#x2F;share&#x2F;doc 中，文档文件是按照软件包来组织分类的。</td></tr><tr><td align="center">&#x2F;var</td><td align="center">除了 &#x2F;tmp 和 &#x2F;home 目录之外，目前看到目录相对来说都是静态的；也就是说，其包含的内容是不变的。而那些可能改变的数据存储在 &#x2F;var 目录树里。各种数据库、假脱机文件、用户邮件等都存储在这里</td></tr><tr><td align="center">&#x2F;var&#x2F;log</td><td align="center">&#x2F;var&#x2F;log 目录包含的日志文件，记录了各种系统活动。这些文件非常重要，并且应该时不时监控它们。其中最有用的文件是 &#x2F;var&#x2F;log&#x2F;messages 。注意，为了安全起见，在一些系统里，必须是超级用户才能查看日志文件</td></tr></tbody></table><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><ol><li>基本介绍</li></ol><ul><li>在浏览过程中，我们可能会看到带有如下条目的目录信息。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 11 2012-08-11 07:34 libc.so.6 -&gt; libc-2.6.so</span><br></pre></td></tr></table></figure></li><li>注意，该条目信息的第一个字母是 l ，这种特殊的文件叫做符号链接 (又称软链接或 symlink ) 。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 导航.md</title>
      <link href="/post/3d3cca4.html"/>
      <url>/post/3d3cca4.html</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>除了在命令行进行输入操作之外，我们首先需要学习的是如何在 Linux 系统中导航文件系统。</li><li>本章将介绍下述命令：</li></ol><ul><li>pwd: 查看当前工作目录</li><li>cd: 改变目录</li><li>ls: 列出目录内容</li></ul><h2 id="理解文件系统树"><a href="#理解文件系统树" class="headerlink" title="理解文件系统树"></a>理解文件系统树</h2><ol><li>与 Windows 相同，类 UNIX 操作系统也是以称之为分层目录结构的方式来组织文件的。</li><li>这意味着文件是在树形结构的目录(有时在其他系统中称为文件夹)中进行组织的，该树形结构目录可能包含文件和其他目录。</li><li>文件系统的第一个目录叫做根目录，它包含了文件和子目录。子目录里包含了更多的文件和子目录，依此类推。</li><li>需要注意的是，在 Windows 系统中，每个存储设备都有一个独立的文件系统树。而在类 UNIX 系统中，如 Linux ，无论多少驱动器或储存设备与计算机相连，通常只有一个文件系统树。</li><li>根据系统管理员的设置，存储设备将会挂载到文件系统树的不同位置，系统管理员要负责系统的维护。</li></ol><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><ol><li>可能大部分人都熟悉用于表示文件系统树的图形文件管理器，需要注意的是，树通常是倒立显式的。也就是说，顶部是根目录，依次向下排列是子目录。</li><li>然而，由于命令行没有图像，若是要浏览文件系统树，就必须使用其他方法。</li><li>假设文件系统是一个迷宫，形如一棵倒置的树，并且用户处在文件系统之中。任何时候，我们处在单个目录中，能够看到该目录中包含的文件、去往上一级目录(称为父级目录)的路径，以及下一级的各个子目录。</li><li>用户所处的目录叫做当前工作目录，使用 pwd(打印工作目录) 命令可以显示当前工作目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure></li><li>第一次登录系统时(或是启动终端仿真器会话时)，当前工作目录被设置成主目录。每一个用户账号都有一个主目录，作为普通用户操作时，这是唯一一个允许用户写文件的地方。</li></ol><h2 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h2><ol><li>使用 ls 命令可以列出当前工作目录的文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line">Desktop Documents Music Pictures Public Videos </span><br></pre></td></tr></table></figure></li><li>实际上，可以使用 ls 命令列出任何目录的内容，而不仅仅是当前工作目录。</li></ol><h2 id="更改当前工作目录"><a href="#更改当前工作目录" class="headerlink" title="更改当前工作目录"></a>更改当前工作目录</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>使用 cd 可以改变工作目录，只需要输入 cd 命令，然后再输入目标工作目录的路径名即可。</li><li>路径名指的是沿着分枝到达目标目录的路由。路径名分为两种：绝对路径名和相对路径名。</li></ol><h3 id="绝对路径名"><a href="#绝对路径名" class="headerlink" title="绝对路径名"></a>绝对路径名</h3><ol><li>绝对路径名从根目录开始，其后紧接着一个又一个文件树分支，直到到达目标目录或文件。</li><li>例如，系统里有一个目录，大多数系统程序都安装到这个目录里，该目录的路径名是 &#x2F;usr&#x2F;bin 。</li><li>这意味着根目录中有个目录是 usr ，该目录包含一个 bin 目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>可以看到，我们已经将当前工作目录改变成 &#x2F;usr&#x2F;bin ， bin 目录中包含很多文件。</li></ol><h3 id="相对路径名"><a href="#相对路径名" class="headerlink" title="相对路径名"></a>相对路径名</h3><ol><li>绝对路径名是从根目录开始，通向目标目录，而相对路径名则是从工作目录开始的。</li><li>为了实现这个目的，它通常使用一些特殊符号来表示文件系统树中的相对位置，这些符号是 . 和 .. 。</li><li>符号是 . 代表工作目录，符号 .. 代表工作目录的父目录。</li><li>下面演示它们是如何工作，让我们再次将工作目录改变成 &#x2F;usr&#x2F;bin 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>下面，我们希望将工作目录改变成 &#x2F;usr&#x2F;bin 的父目录，回到 &#x2F;usr 。有两种方法可以实现，一种是使用绝对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox bin]$ <span class="built_in">cd</span> /usr</span><br><span class="line">[me@linuxbox usr]$ <span class="built_in">pwd</span></span><br><span class="line">/usr</span><br></pre></td></tr></table></figure></li><li>另一种是使用相对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox bin]$ <span class="built_in">cd</span> ..</span><br><span class="line">[me@linuxbox usr]$ <span class="built_in">pwd</span></span><br><span class="line">/usr</span><br></pre></td></tr></table></figure></li><li>同样可以用两种方法将工作目录从 &#x2F;usr 变到 &#x2F;usr&#x2F;bin 。我们可以使用绝对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox usr]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>我们也可以用相对路径名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox usr]$ <span class="built_in">cd</span> ./bin</span><br><span class="line">[me@linuxbox bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure></li><li>必须在这里指出来的是，几乎所有的情况下都可以省略 .&#x2F; ，因为它是隐含的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox usr]$ <span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure></li><li>该代码与使用相对路径名的代码具有相同效果。一般而言，如果没有指定路径名，则默认为工作目录。</li></ol><h3 id="一些有用的快捷方式"><a href="#一些有用的快捷方式" class="headerlink" title="一些有用的快捷方式"></a>一些有用的快捷方式</h3><table><thead><tr><th align="center">快捷方式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">cd</td><td align="center">将工作目录改变成主目录</td></tr><tr><td align="center">cd-</td><td align="center">将工作目录改变成先前的工作目录</td></tr><tr><td align="center">cd~username</td><td align="center">将工作目录改变为 username 的主目录。例如， cd~bob 将目录改变成用户 bob 的主目录</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 Shell 是什么</title>
      <link href="/post/37c791b4.html"/>
      <url>/post/37c791b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-是什么"><a href="#Shell-是什么" class="headerlink" title="Shell 是什么"></a>Shell 是什么</h1><h2 id="终端仿真器"><a href="#终端仿真器" class="headerlink" title="终端仿真器"></a>终端仿真器</h2><ol><li>当谈到命令行时，我们实际上指的是 shell 。</li><li>shell 是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序。</li><li>几乎所有的 Linux 发行版都是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序。</li><li>几乎所有的 Linux 的发行版都提供 shell 程序，该程序来自于称之为 bash 的 GNU 项目。</li><li>bash 是 Bourne Again Shell 的首字母缩写， Bourne Again Shell 基于这样一个事实，即 bash 是 sh 的增强版本，而 sh 是最初的 UNIX shell 程序，由 Steve Bourne 编写。</li><li>当使用图形用户界面时，需要另一种叫做终端仿真器(terminal emulator)的程序与 shell 进行交互。</li><li>在 KDE 环境下使用的是 konsole ，而在 GNOME 环境下使用 gnome-terminal ，但是在桌面菜单上很可能将它们简单地统称为终端。</li><li>在 Linux 系统中，还有许多其他的终端仿真器可以使用，但是它们基本上都做同样的事情：让用户访问 shell 。</li><li>因为不同的终端仿真器所具有的功能特性不尽相同，因此，你可以根据自己的喜好进行选择。</li></ol><h2 id="第一次键盘输入"><a href="#第一次键盘输入" class="headerlink" title="第一次键盘输入"></a>第一次键盘输入</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>启动终端仿真器，运行后的终端仿真器如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li><li>这是 shell 提示符，只要 shell 准备接收外部输入，它就会出现。在不同的发行版中，提示符外观可能会有差异，但是，它通常包括 username@machinename ，其后是当前工作目录和一个 $ 符号。</li><li>如果 shell 提示符的最后一个字符是 # ，而不是一个 $ 符号，那么终端会话将享有超级用户特权。</li><li>假定一切工作都很顺利，接下来尝试输入一些内容。在提示符后输入一些乱码。如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ kaekfjaeifj</span><br></pre></td></tr></table></figure></li><li>由于这些命令没有任何意义，shell 会让我们重新输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash: kaekfjaeifj: <span class="built_in">command</span> not found</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></li></ol><h3 id="命令历史记录"><a href="#命令历史记录" class="headerlink" title="命令历史记录"></a>命令历史记录</h3><ol><li>如果按下向上方向的指示键，将会看到先前的命令 kaekfjaeifj 再一次出现提示符后面，这称为命令历史记录。</li><li>在默认情况下，大部分 Linux 发行版本能够存储最近输入的 500 个命令。</li><li>按下向下方向指示键，则先前的命令消失。</li></ol><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ol><li>再次按下向上方向指示键，重新调用先前的命令，然后分别按下向左向右方向的指示键，看看如何将光标定位到命令行的任意位置。这可以让我们很容易地编辑命令。</li></ol><h2 id="几个简单的命令"><a href="#几个简单的命令" class="headerlink" title="几个简单的命令"></a>几个简单的命令</h2><ol><li>在学习键盘输入之后，我们来尝试几个简单的命令。</li><li>首先是 date 命令，该命令显示当前系统的时间和日期：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ <span class="built_in">date</span></span><br><span class="line">Thu Oct 25 13:51:54 EDT 2012</span><br></pre></td></tr></table></figure></li><li>与之相关的一个命令是 cal ，在默认情况下， cal 显示当月的日历。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ cal</span><br><span class="line">    八月 2020</span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">                   1</span><br><span class="line"> 2  3  4  5  6  7  8</span><br><span class="line"> 9 10 11 12 13 14 15</span><br><span class="line">16 17 18 19 20 21 22</span><br><span class="line">23 24 25 26 27 28 29</span><br><span class="line">30 31</span><br></pre></td></tr></table></figure></li><li>如果想要查看磁盘驱动器当前可用的空间，可以使用 df 命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ <span class="built_in">df</span></span><br><span class="line">Filesystem    512-blocks      Used Available Capacity iused               ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s1   489620264 132645336 350371888    28% 1330866 9223372036853444941    0%   /</span><br><span class="line">devfs                383       383         0   100%     673                   0  100%   /dev</span><br><span class="line">/dev/disk1s4   489620264   4194344 350371888     2%       2 9223372036854775805    0%   /private/var/vm</span><br><span class="line">map -hosts             0         0         0   100%       0                   0  100%   /net</span><br><span class="line">map auto_home          0         0         0   100%       0                   0  100%   /home</span><br></pre></td></tr></table></figure></li></ol><h2 id="结束终端会话"><a href="#结束终端会话" class="headerlink" title="结束终端会话"></a>结束终端会话</h2><ol><li>直接关闭终端窗口或是在 shell 提示符下输入 exit 命令，即可结束终端会话。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@inuxbox ~]$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>转载：Linux 命令行大全</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十六讲 Git rebase</title>
      <link href="/post/4c946041.html"/>
      <url>/post/4c946041.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>rebase：变基，意即改变分支的根基</li><li>rebase 作用：从某种程度上来说，rebase 与 merge 可以完成类似的工作，不过两者的工作方式有着显著的差异</li><li>Git rebase 操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch_name</span><br><span class="line">git rebase branch_new_name</span><br></pre></td></tr></table></figure></li><li>Git merge 操作和 Git rebase 操作的区别: 两者结果内容一样，过程和操作方式完全不一样。</li><li>Git rebase 操作会修改提交历史，会让提交历史变成一条直线。</li><li>Git rebase 原理：实际上是将一个分支的修改内容应用到里另外一个分支上，不断的应用，所以提交历史变成一条直线。</li><li>Git rebase 注意事项</li></ol><ul><li>rebase 过程中也会出现冲突</li><li>解决冲突后，使用 git add 添加，然后执行如下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li><li>接下来 Git 会继续应用余下的补丁</li><li>任何时候都可以通过如下命令终止 rebase ，分支会恢复到 rebase 开始前的状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>Git rebase 最佳实践</li></ol><ul><li>不要对 master 分支执行 rebase ，否则会引起很多问题</li><li>一般来说，执行 rebase 的分支都是自己的本地分支，没有推送到远程的版本库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五讲 Git subtree 与 Git cherry-pick</title>
      <link href="/post/2b68b650.html"/>
      <url>/post/2b68b650.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-subtree-与-Git-cherry-pick"><a href="#Git-subtree-与-Git-cherry-pick" class="headerlink" title="Git subtree 与 Git cherry-pick"></a>Git subtree 与 Git cherry-pick</h1><h2 id="Git-subtree"><a href="#Git-subtree" class="headerlink" title="Git subtree"></a>Git subtree</h2><ol><li>Git submodule 如果在主项目修改依赖项目会造成很多问题，Git subtree 和 Git submodule 解决问题一样，Git subtree 可以解决针对双向修改。</li></ol><ul><li>新建 git_subtree_parent 和 git_subtree_children 两个工程(远程仓库)，其中 git_subtree_children 是子工程。</li><li>在本地创建仓库 git_subtree_parent 和 git_subtree_children</li><li>在本地创建的仓库 git_subtree_parent 新建文件 parent.txt ，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_subtree_parent 信息</li><li>将本地的 git_subtree_parent 提交推送到远程 git_subtree_parent 中</li><li>在本地创建的仓库 git_subtree_children 新建 children.txt，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_subtree_children 信息</li><li>将本地的 git_subtree_children 提交推送到远程 git_subtree_children</li><li>在本地创建的仓库 git_subtree_children 新建 hello.txt ，将修改纳入暂存区，并进行提交</li><li>将本地的 git_subtree_children 提交推送到远程 git_subtree_children</li><li>在主项目关联子项目的远程库</li><li>执行 git subtree 命令，将子依赖拉到主项目</li><li>如果 git_children 发生变化，git_parent 也随之变化</li><li>在主工程的 git_subtree_parent&#x2F;subtree 目录下修改文件 children.txt ，将修改纳入暂存区，并进行提交</li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_parent 中</li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_children</li></ul><ol start="2"><li>在主项目关联子项目的远程库命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add subtree-origin git@github.com:gitlecture/git_subtree_children.git</span><br></pre></td></tr></table></figure></li><li>执行 git subtree 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree add --prefix=subtree subtree-orign master --squash <span class="comment"># squash 参数表示子项目的多次提交被压缩成一次提交</span></span><br></pre></td></tr></table></figure></li><li>拉取 git_subtree_children 更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree pull --prefix=subtree subtree-origin --squash <span class="comment"># squash 也可以不用(注意：要是不用就所有 subtree 命令不用，要用就所有 subtree 命令都用)</span></span><br></pre></td></tr></table></figure></li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_parent 中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li><li>将本地的 git_subtree_parent&#x2F;subtree 目录下修改推送到远程 git_subtree_children<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=subtree subtree-origin master</span><br></pre></td></tr></table></figure></li><li>将远程的 git_subtree_children 拉到本地 git_subtree_children<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 在 git_subtree_children 目录下</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-cherry-pick"><a href="#Git-cherry-pick" class="headerlink" title="Git cherry-pick"></a>Git cherry-pick</h2><ol><li>作用：将在一个分支的修改应用到另一个分支上(主要用于本地分支)</li><li>将一个分支的修改应用到另一个分支上(例如将在 develop 分支的修改应用于 master 分支)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commit_id <span class="comment"># 将其他分支的一个提交所做的修改应用到当前分支</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四讲 Git 裸库与 Git submodule</title>
      <link href="/post/47e9a5ce.html"/>
      <url>/post/47e9a5ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-裸库与-Git-submodule"><a href="#Git-裸库与-Git-submodule" class="headerlink" title="Git 裸库与 Git submodule"></a>Git 裸库与 Git submodule</h1><h2 id="Git-裸库"><a href="#Git-裸库" class="headerlink" title="Git 裸库"></a>Git 裸库</h2><ol><li>没有工作区的 Git 仓库(一般在服务器端)</li><li>创建裸库命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare <span class="comment"># 没有工作区</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-submodule"><a href="#Git-submodule" class="headerlink" title="Git submodule"></a>Git submodule</h2><ol><li>项目的相互协作(多模块开发-项目的依赖)</li></ol><ul><li>准备工作<ul><li>在 GitHub 上创建仓库 git_parent 和 git_children</li><li>在本地创建仓库 git_parent 和 git_children</li><li>在本地创建的仓库 git_parent 新建文件 parent.txt ，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_parent 信息</li><li>将本地的 git_parent 提交推送到远程 git_parent</li><li>在本地创建的仓库 git_children 新建 submodule.txt ，将修改纳入暂存区，并进行提交</li><li>配置远程仓库 git_children 信息</li><li>将本地的 git_children 提交推送到远程 git_children</li><li>在本地创建的仓库 git_children 新建 hello.txt ，将修改纳入暂存区，并进行提交</li><li>将本地的 git_children 提交推送到远程 git_children</li><li>执行 git submodule 命令，将子依赖拉到主项目</li><li>将文件修改纳入暂存区，接着进行提交</li><li>如果 git_children 发生变化，git_parent 也随之变化</li></ul></li></ul><ol start="2"><li>git submodule 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule git@github.com:gitlecture/git_children.git my module</span><br></pre></td></tr></table></figure></li><li>拉取 <code>git_children</code> 更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 在 git_parent/myModule 目录下</span></span><br></pre></td></tr></table></figure></li><li>拉取所有依赖子模块的所有更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure></li><li>如果一个项目包含着 submodule ，进行 git clone 操作的时候，默认情况下是不会把 submodule 的代码克隆下来，需要手工的去执行一次<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gitlecture/git_parent.git parent2 <span class="comment"># 克隆</span></span><br><span class="line">git submodule init <span class="comment"># submodule 初始化</span></span><br><span class="line">git submodule update --recursive <span class="comment"># 进行子模块更新</span></span><br></pre></td></tr></table></figure></li><li>进行 git clone 操作时候，使用后面加参数将所有子模块的更新全部克隆下来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gitlecture/git_parent.git parent3 --recursive</span><br></pre></td></tr></table></figure></li><li>删除 submodule (命令组合)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.将 submodule 从缓存区删除</span></span><br><span class="line">git <span class="built_in">rm</span> --cached mymodule</span><br><span class="line"><span class="comment"># 2.将 submodule 的实体文件从工作区删除</span></span><br><span class="line"><span class="built_in">rm</span> -rf mymodule</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;remove submodule&#x27;</span></span><br><span class="line">git push</span><br><span class="line"><span class="comment"># 3.将 .gitmodules 目录删除</span></span><br><span class="line"><span class="built_in">rm</span> .gitmodules</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;remove submodules&#x27;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三讲 Git gc</title>
      <link href="/post/db6359d5.html"/>
      <url>/post/db6359d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-gc"><a href="#Git-gc" class="headerlink" title="Git gc"></a>Git gc</h1><h2 id="git-垃圾收集"><a href="#git-垃圾收集" class="headerlink" title="git 垃圾收集"></a>git 垃圾收集</h2><ol><li>git 垃圾收集主要用于做一些文件压缩，将分散在不同地方的文件给合并到一起，对一些对象通过一些手段将其所占体积减少。(git gc 实际开发中使用很少，因为很多时候 git 后台自动运行)</li><li>进入本地仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repository_name</span><br></pre></td></tr></table></figure></li><li>进入 refs 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> refs</span><br></pre></td></tr></table></figure></li><li>进入 heads 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> heads</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cat</span> branch_name <span class="comment"># 查看本地分支内容</span></span><br></pre></td></tr></table></figure></li><li>进入 remotes&#x2F;origin 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> remotes/origin</span><br><span class="line"><span class="built_in">cat</span> branch_name <span class="comment"># 查看远程分支内容</span></span><br></pre></td></tr></table></figure></li><li>进入 tags 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tags</span><br><span class="line"><span class="built_in">cat</span> v1.0 <span class="comment"># 查看标签内容</span></span><br></pre></td></tr></table></figure></li><li>运行 git gc 命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git gc <span class="comment"># 文件压缩(git gc 实际上把 refs 目录下的所有文件被打包到 pached-refs 目录下，增加新的提交信息，则该信息还是在 refs 的目录下)</span></span><br></pre></td></tr></table></figure></li><li>git 每次提交的对象保存到 .git&#x2F;objects&#x2F;info 的 packs 文件中(进行压缩后 .git&#x2F;objects&#x2F;info&#x2F;packs 文件会被压缩到 .git&#x2F;objects&#x2F;pack)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二讲 Git 远程标签</title>
      <link href="/post/ea965a0c.html"/>
      <url>/post/ea965a0c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-远程标签"><a href="#Git-远程标签" class="headerlink" title="Git 远程标签"></a>Git 远程标签</h1><h2 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h2><ol><li>列出本地的所有标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li>创建一个轻量级标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure></li><li>创建带注释的标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v2.0 -m <span class="string">&#x27;v2.0 released&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看标签内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v1.0</span><br></pre></td></tr></table></figure></li><li>搜索标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l <span class="string">&#x27;v&#x27;</span> <span class="comment"># 利用通配符</span></span><br></pre></td></tr></table></figure></li><li>推送标签到远程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br><span class="line">git push origin v1.0 v2.0 <span class="comment"># 少数标签</span></span><br><span class="line">git push origin --tags <span class="comment"># 将标签 批量推送到远程</span></span><br></pre></td></tr></table></figure></li><li>删除远程标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1.0</span><br><span class="line">git push origin --delete tag v1.0</span><br></pre></td></tr></table></figure></li><li>将本地标签推送到远程的完整语法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin refs/tags/v1.0:refs/tags/v1.0</span><br></pre></td></tr></table></figure></li><li>只从远程拉取标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin tag v1.0</span><br></pre></td></tr></table></figure></li><li>只从远程拉取标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin tag v1.0</span><br></pre></td></tr></table></figure></li><li>显示远程信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote origin show</span><br></pre></td></tr></table></figure></li><li>删除远程游离的分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin <span class="comment"># 通常删除分支后的操作</span></span><br></pre></td></tr></table></figure></li><li>如果远端上有一个 master 分支，本地就可以通过下面几种方式来访问它的历史记录：</li></ol><ul><li>查看远程分支的历史记录(3 种方式)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> origin/matser</span><br><span class="line">git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure></li></ul><ol start="14"><li>将远程的某个分支的内容拉取到本地的新远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:refs/origin/mymaster</span><br></pre></td></tr></table></figure></li><li>在本地创建新分支并追踪本地的远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin mymaster</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一讲 Git refspec</title>
      <link href="/post/d0933ad4.html"/>
      <url>/post/d0933ad4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-refspec"><a href="#Git-refspec" class="headerlink" title="Git refspec"></a>Git refspec</h1><h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><ol><li>配置别名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.br branch # 配置信息在 ~/.gitconfig 文件下</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD&#x27;</span><br><span class="line">git config --global alias.ui &#x27;!git&#x27;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-refspec-1"><a href="#Git-refspec-1" class="headerlink" title="Git refspec"></a>Git refspec</h2><h3 id="git-push-相关操作"><a href="#git-push-相关操作" class="headerlink" title="git push 相关操作"></a>git push 相关操作</h3><ol><li>git push 操作的完整命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin srcbranch:destbranch <span class="comment"># 建议的 git push 命令</span></span><br></pre></td></tr></table></figure></li><li>将本地分支推送到远程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin branch_name <span class="comment"># 将本地分支推送到远程(默认远程分支名与本地一样)</span></span><br><span class="line">git push -u origin branch_name <span class="comment"># 跟上一条命令一样效果</span></span><br><span class="line">git push --set-upstream origin branch_name:branch_new_name <span class="comment"># 将本地分支推送到远程并且远程分支名与本地所关联的分支不同名</span></span><br><span class="line"><span class="comment"># 如果不同名，则进行 git push 操作，则要执行以下命令</span></span><br><span class="line">git push origin HEAD:branch_new_name <span class="comment"># 尽可能同名(不同名无法简写 git push 命令)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="git-pull-相关操作"><a href="#git-pull-相关操作" class="headerlink" title="git pull 相关操作"></a>git pull 相关操作</h3><ol><li>git pull 操作的完整命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin srcbranch:destbranch</span><br></pre></td></tr></table></figure></li><li>将远程分支拉到本地<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 将远程所有分支改变都拉到本地</span></span><br><span class="line">git checkout -b branch_name origin/branch_name <span class="comment"># 创建跟远程分支同名的本地分支，并关联。</span></span><br><span class="line">git checkout --track origin/branch_name分支来追踪 <span class="comment"># 本地创建同名的 branch_name 分支来追踪 origin/branch_name (与上一条命令意思完全一样)</span></span><br></pre></td></tr></table></figure></li><li>删除远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branch_name <span class="comment"># 将本地的一个空分支推送到远程某个分支(意味着删除远程的该分支)</span></span><br><span class="line">git push origin --delete branch_name <span class="comment"># 与上一个命令一样效果</span></span><br></pre></td></tr></table></figure></li><li>重命名远程分支</li></ol><ul><li>删除远程分支</li><li>本地重命名分支</li><li>将本地重命名后的分支推送到远程</li></ul><h2 id="HEAD-文件相关内容"><a href="#HEAD-文件相关内容" class="headerlink" title="HEAD 文件相关内容"></a>HEAD 文件相关内容</h2><ol><li>HEAD 标记</li></ol><ul><li>HEAD 文件是一个指向你当前所在分支的引用标识符，该文件内部并不包含 SHA-1 值，而是包含一个指向另外一个引用的指针。</li><li>当执行 git commit 命令时，git 会创建一个 commit 对象，并且将这个 commit 对象的 parent 指针设置为 HEAD 所指向的引用的 SHA-1 值。</li><li>我们对于 HEAD 修改的任何操作都会被 git reflog 完整记录下来。</li><li>实际上，我们可以通过对 git 底层命令 symbolic-ref 来实现对 HEAD 文件内容的修改。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git symbolic-ref HEAD <span class="comment"># 读取</span></span><br><span class="line">git symbolic-ref HEAD refs/heads/branch_name <span class="comment"># 写入</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十讲 Git 远程操作与 Git 协作</title>
      <link href="/post/1624a6c0.html"/>
      <url>/post/1624a6c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-远程操作与-Git-协作"><a href="#Git-远程操作与-Git-协作" class="headerlink" title="Git 远程操作与 Git 协作"></a>Git 远程操作与 Git 协作</h1><h2 id="Git-远程操作"><a href="#Git-远程操作" class="headerlink" title="Git 远程操作"></a>Git 远程操作</h2><ol><li>建立 SSH 安全连接<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1.配置远程</span><br><span class="line">git remote add orgin git@github.com:repository_name/repository_name.git # 远程仓库 SSH 链接地址</span><br><span class="line">git remote show orgin</span><br><span class="line"># 2.把公钥放置远程</span><br><span class="line">cd .ssh</span><br><span class="line">ls</span><br><span class="line">vi known_hosts</span><br><span class="line">which ssh-keygen # 生成公钥</span><br><span class="line">ssh-keygen # 生成公钥(敲入命令回车，要求输入密码连续两次回车)</span><br><span class="line">ls id_rsa.pub # 进入公钥文件夹(把公钥粘贴放置 GitHub 中 settings 的 Deploy keys 上面)</span><br><span class="line"># 3.把本地分支推送到远程</span><br><span class="line">git push -u orgin master # 将本地的 master 分支推送到远程</span><br></pre></td></tr></table></figure></li><li>查看所有远程仓库的别名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show</span><br></pre></td></tr></table></figure></li><li>查看远程仓库所有信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show repository_name</span><br></pre></td></tr></table></figure></li><li>重命名远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin origin2</span><br></pre></td></tr></table></figure></li><li>删除远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure></li><li>删除之后再次创建<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add orgin git@github.com:repository_name/epository_name.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="更新-git"><a href="#更新-git" class="headerlink" title="更新 git"></a>更新 git</h2><ol><li>查看 git 版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li>查看 git 的位置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> git</span><br></pre></td></tr></table></figure></li><li>查看 mac 的系统环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li>修改环境目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi .zshrc</span><br></pre></td></tr></table></figure></li><li>安装新版 git<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 新增的 git 一般被安装在 usr/local/git 中 </span><br></pre></td></tr></table></figure></li></ol><h2 id="git-协作"><a href="#git-协作" class="headerlink" title="git 协作"></a>git 协作</h2><ol><li>查看所有远程仓库的名字<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show</span><br></pre></td></tr></table></figure></li><li>查看所有远程仓库的详细信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show remote_repository_name</span><br></pre></td></tr></table></figure></li><li>关联远程(过程理解)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 与远程关联之后，本地有一个 master 分支，还有一个 origin/master 分支(追踪着远程版本库的 mater 分支)</span><br><span class="line"># 进行 git pull 操作，git 会将远程的修改拉到本地，同时将 origin/master 分支的 commit_id 对应到远程 master 最新的那次提交,如果这种合并是可以直接合并，git 会将远程的 master 分支直接合并到本地的 master 分支上。</span><br><span class="line"># 进行 git push 操作，git 会将本地的 origin/master 分支最新的 commit_id 指向本地的 master 分支上，将本地的 master 的分支内容 push 到远程</span><br></pre></td></tr></table></figure></li><li>查看远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment"># 查看所有远程分支</span></span><br><span class="line">git branch -av <span class="comment"># 查看所有远程分支以及其最新的提交 commit_id</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="拉取代码操作"><a href="#拉取代码操作" class="headerlink" title="拉取代码操作"></a>拉取代码操作</h2><ol><li>拉取远程代码(克隆)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repository_url_ssh</span><br></pre></td></tr></table></figure></li><li>拉取远程代码并重命名仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repository_url_ssh repository_new_name</span><br></pre></td></tr></table></figure></li></ol><h2 id="git-pull-与-git-fetch-区别"><a href="#git-pull-与-git-fetch-区别" class="headerlink" title="git pull 与 git fetch 区别"></a>git pull 与 git fetch 区别</h2><ol><li>git fetch<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment"># 一定会成功的(不执行合并操作，仅仅是将远程的修改拉到本地，更新本地的 orgin/master)</span></span><br><span class="line">git merge orgin/master <span class="comment"># 将本地的 orgin/master 的修改 merge 到本地的 master 分支上</span></span><br></pre></td></tr></table></figure></li><li>git pull &#x3D;&#x3D; git fetch + git merge</li></ol><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><ol><li>Gitflow</li><li>关于 Git 分支的最佳实践(基于 Git 分支的开发模型)</li></ol><ul><li>master 分支(生产发布)–生产发布分支，变化非常不频繁的一个分支</li><li>test 分支(测试)–供测试与产品人员使用的一个分支，变化不是特别频繁</li><li>develop 分支(开发)–频繁变化的一个分支</li><li>hotfix 分支(修复 bug 分支)–生产系统当中出现了紧急 bug ，用于紧急修复的分支</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九讲 远程与 GitHub</title>
      <link href="/post/e986823a.html"/>
      <url>/post/e986823a.html</url>
      
        <content type="html"><![CDATA[<h1 id="远程与-GitHub"><a href="#远程与-GitHub" class="headerlink" title="远程与 GitHub"></a>远程与 GitHub</h1><h2 id="远程版本库-GitHub"><a href="#远程版本库-GitHub" class="headerlink" title="远程版本库(GitHub)"></a>远程版本库(GitHub)</h2><ol><li><a href="https://github.com/">Github 官网网址</a></li><li>注册账号: 利用邮箱注册账号(公共仓库)</li><li>将本地仓库推送到 GitHub 上</li></ol><ul><li>初始化仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init repository_name</span><br></pre></td></tr></table></figure></li><li>配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;name&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;email&#x27;</span></span><br></pre></td></tr></table></figure></li><li>修改配置的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure></li><li>修改文件</li><li>将修改纳入暂存区</li><li>进行提交</li><li>本地版本库推送<ul><li>对 GitHub 进行配置</li><li>新建 README.md 进行说明，并提交到本地版本库</li><li>现在网页上创建一个远程仓库</li><li>推送到远程命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/repository_name.git <span class="comment"># 远程仓库 url</span></span><br><span class="line">git push -u origin master <span class="comment"># 将本地的 master 分支推送到远程</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八讲 标签与 diff</title>
      <link href="/post/38d25409.html"/>
      <url>/post/38d25409.html</url>
      
        <content type="html"><![CDATA[<h1 id="标签与-diff"><a href="#标签与-diff" class="headerlink" title="标签与 diff"></a>标签与 diff</h1><h2 id="Git-标签"><a href="#Git-标签" class="headerlink" title="Git 标签"></a>Git 标签</h2><ol><li>新建标签，标签有两种：轻量级标签(lightweight)与带有附注标签(annotated)。</li><li>创建一个轻量级标签</li><li>创建一个带附注的标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.02 -m <span class="string">&#x27;release version&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看所有标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li>查找标签(模糊查找和精确查找)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l <span class="string">&#x27;v1.0&#x27;</span></span><br></pre></td></tr></table></figure></li><li>删除标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d tag_name</span><br></pre></td></tr></table></figure></li><li>git blame 命令(定位文件修改的信息)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame file <span class="comment"># 可以查看该文件所有修改者信息</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><h3 id="系统自带的-diff"><a href="#系统自带的-diff" class="headerlink" title="系统自带的 diff"></a>系统自带的 diff</h3><ol><li>系统自带 diff 对比文件差别<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file_1 file_2 </span><br></pre></td></tr></table></figure></li><li>详细系统自带 diff 对比文件差别<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -u file_1 file_2</span><br></pre></td></tr></table></figure></li></ol><h3 id="Git-中-diff"><a href="#Git-中-diff" class="headerlink" title="Git 中 diff"></a>Git 中 diff</h3><ol><li>进行工作区与暂存区之间的文件差别对比: 暂存区文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment"># 比较的是暂存区与工作区文件之间的差别(将工作区文件修改，暂存区不动，进行差异性比较。)</span></span><br></pre></td></tr></table></figure></li><li>进行工作区与特定 commit_id 之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff commit_id</span><br></pre></td></tr></table></figure></li><li>进行工作区与最新的提交之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD </span><br></pre></td></tr></table></figure></li><li>进行暂存区与某一特定 commit_id 之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached commit_id</span><br></pre></td></tr></table></figure></li><li>进行暂存区与最新的提交之间文件的差别比较: 版本库的文件作为原始文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七讲 checkout 进阶与 stash</title>
      <link href="/post/935be61e.html"/>
      <url>/post/935be61e.html</url>
      
        <content type="html"><![CDATA[<h1 id="checkout-进阶与-stash"><a href="#checkout-进阶与-stash" class="headerlink" title="checkout 进阶与 stash"></a>checkout 进阶与 stash</h1><h2 id="checkout-进阶"><a href="#checkout-进阶" class="headerlink" title="checkout 进阶"></a>checkout 进阶</h2><ol><li>丢弃工作目录的变更<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure></li><li>从暂存区取消暂存<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure></li><li>checkout 切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout new_branch <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b new_branch <span class="comment"># 创建分支并切换分支</span></span><br></pre></td></tr></table></figure></li><li>利用 checkout 回退版本(HEAD 处于游离状态)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout commit_id <span class="comment"># 此时指针处于游离状态</span></span><br></pre></td></tr></table></figure></li><li>接着利用下一命令可以将游离的指针，移到创建分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch </span><br></pre></td></tr></table></figure></li><li>分支改名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m branch_1 branch_2</span><br></pre></td></tr></table></figure></li></ol><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ol><li>将当前分支的所有修改临时保存起来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></li><li>查看所有保存状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></li><li>提交临时保存说明<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&#x27;message&#x27;</span></span><br></pre></td></tr></table></figure></li><li>将临时保存状态恢复出来，并把这个保存状态删除掉<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash poo</span><br></pre></td></tr></table></figure></li><li>将临时保存状态恢复出来，不把这个保存状态删除掉<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></li><li>手动删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;number&#125; </span><br></pre></td></tr></table></figure></li><li>从任意一个临时状态恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;number&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六讲 分支进阶与版本回退</title>
      <link href="/post/9551f68e.html"/>
      <url>/post/9551f68e.html</url>
      
        <content type="html"><![CDATA[<h1 id="分支进阶与版本回退"><a href="#分支进阶与版本回退" class="headerlink" title="分支进阶与版本回退"></a>分支进阶与版本回退</h1><h2 id="Fast-Forward"><a href="#Fast-Forward" class="headerlink" title="Fast-Forward"></a>Fast-Forward</h2><ol><li>如果可能，合并分支时 Git 会使用 fast-forward 模式。</li><li>在这种模式下，删除分支时会丢掉分支信息</li><li>合并时加上 –no-ff 参数会禁用 fast-forward ，这样会多出一个 commit id<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff new_branch</span><br></pre></td></tr></table></figure></li><li>查看 log<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph <span class="comment"># 以图形化的方式</span></span><br><span class="line">git <span class="built_in">log</span> --graph --abbrev-commit <span class="comment"># log 日志中 commit_id 信息简写</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol><li>把当前文件目录下的所有文件放入暂存区，然后提交<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">&#x27;add another line&#x27;</span> </span><br><span class="line"><span class="comment"># 上述命令等价于以下两命令之和</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;add another line&#x27;</span></span><br></pre></td></tr></table></figure></li><li>回退到上一版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard HEAD~1 </span><br></pre></td></tr></table></figure></li><li>返回到某一版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog <span class="comment"># 查看操作日志，查看版本的 commit_id</span></span><br><span class="line">git reset --hard commit_id <span class="comment"># 回退到特定版本</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五讲 .gitignore 与分支</title>
      <link href="/post/60c32a6b.html"/>
      <url>/post/60c32a6b.html</url>
      
        <content type="html"><![CDATA[<h1 id="gitignore-与分支"><a href="#gitignore-与分支" class="headerlink" title=".gitignore 与分支"></a>.gitignore 与分支</h1><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><ol><li>文件忽略: .gitignore<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，但不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt ，但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过网站生成常用的-gitignore-文件"><a href="#通过网站生成常用的-gitignore-文件" class="headerlink" title="通过网站生成常用的 .gitignore 文件"></a>通过网站生成常用的 .gitignore 文件</h2><ul><li><a href="!http://www.gitignore.io/">网站链接</a></li></ul><h2 id="一些重要的命令"><a href="#一些重要的命令" class="headerlink" title="一些重要的命令"></a>一些重要的命令</h2><ol><li>删除目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> mydir <span class="comment"># 不常用，要求目录是空目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf mydir</span><br></pre></td></tr></table></figure></li><li>拼接两条命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mydir &amp;&amp; <span class="built_in">cd</span> mydir <span class="comment"># 创建目录并进入该目录</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><ol><li>分支的一些概念</li></ol><ul><li>一个 commit 对象链：一条工作记录线(只有一个分支)</li><li>HEAD 指向的是当前分支</li><li>master(分支名)指向当前分支的最后一次提交</li><li>分支的合并形式：快进-fast forward</li><li>master 分支没有做修改，另一分支做修改，合并形式就是快进</li></ul><ol start="2"><li>查看当前版本库的所有分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li>创建新的分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch new_branch(此时新分支和当前分支同步)</span><br></pre></td></tr></table></figure></li><li>切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout new_branch <span class="comment"># 两分支文件是独立的</span></span><br><span class="line">git checkout - <span class="comment"># 切换到之前的分支</span></span><br></pre></td></tr></table></figure></li><li>删除分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d new_branch </span><br></pre></td></tr></table></figure></li><li>注意事项：</li></ol><ul><li>不能删除当前所在分支</li><li>如果分支没有完全合并，要强行删除分支需要采用以下命令(要被删除的分支上做出了文件修改)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D new_branch </span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>创建分支并同时切换到新的分支上<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch</span><br></pre></td></tr></table></figure></li><li>分支的合并<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge new_branch <span class="comment"># 将 new_branch 的内容修改合并到 master 分支上</span></span><br></pre></td></tr></table></figure></li><li>显示当前所处分支最新的提交信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></li><li>合并产生冲突(解决冲突)</li></ol><ul><li>原因：两个分支修改了同时修改同一个文件同一行(产生冲突)</li><li>无法自动解决冲突，手动利用工具解决</li><li>手动解决冲突后利用以下两个命令进行合并的提交</li><li>手动解决合并冲突后，当前分支如果和另一分支合并，则这次合并是 fast-forward<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add file <span class="comment"># 告诉 git 手动解决了冲突</span></span><br><span class="line">git commit -m <span class="string">&#x27;&#x27;</span> <span class="comment"># 提交这次合并的 commit message</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四讲 Git 添加、删除、修改与日志</title>
      <link href="/post/7df480e5.html"/>
      <url>/post/7df480e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-添加、删除、修改与日志"><a href="#Git-添加、删除、修改与日志" class="headerlink" title="Git 添加、删除、修改与日志"></a>Git 添加、删除、修改与日志</h1><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ol><li>创建文件(利用 echo)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span> &gt; file <span class="comment"># 文件重定向</span></span><br></pre></td></tr></table></figure></li><li>删除文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file <span class="comment"># 先删除文件并把这次修改纳入暂存区。</span></span><br></pre></td></tr></table></figure></li><li>利用 git rm 删除文件可以利用以下两次命令恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file <span class="comment"># 将文件从暂存区回退到工作区</span></span><br><span class="line">git checkout -- file <span class="comment"># 将工作区的文件修改全部丢弃(未纳入暂存区的文件修改)</span></span><br></pre></td></tr></table></figure></li><li>删除文件(系统命令 rm)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file <span class="comment"># 删除文件但并未把这次修改纳入暂存区</span></span><br></pre></td></tr></table></figure></li><li>利用系统命令 rm 删除文件可以利用以下一条命令恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file <span class="comment"># 将工作区的文件修改全部丢弃(未纳入暂存区的文件修改)</span></span><br></pre></td></tr></table></figure></li><li>利用 git mv 进行文件重命名: 将原文件删除并创建一个新的和原文件一样的文件并把这次修改纳入暂存区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> file file_1 <span class="comment"># 先将文件进行重命名并把这次修改纳入暂存区</span></span><br></pre></td></tr></table></figure></li><li>利用 git mv 进行文件重命名可以利用以下操作恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br><span class="line">git reset HEAD file_1</span><br><span class="line">git checkout -- file</span><br><span class="line"><span class="built_in">rm</span> file_1</span><br></pre></td></tr></table></figure></li><li>利用系统命令 mv 进行文件重命名: 将原文件删除并创建一个新的和原文件一样的文件并未把这次修改纳入暂存区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file file_1 <span class="comment"># 并未把这次修改纳入暂存区</span></span><br></pre></td></tr></table></figure></li><li>利用系统命令 mv 进行文件重命名可以利用以下操作恢复<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br><span class="line"><span class="built_in">rm</span> file_1</span><br></pre></td></tr></table></figure></li><li>将当前目录以及当前目录子目录的所有文件同时纳入暂存区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li>commit message 提交错误进行修正<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m <span class="string">&#x27;message_1&#x27;</span> <span class="comment"># 修正上一次的 commit message</span></span><br></pre></td></tr></table></figure></li><li>查看日志<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n <span class="comment"># 查看最近 n 条日志</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline 日志以一行的简单方式呈现</span><br></pre></td></tr></table></figure></li><li>获取帮助<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> config</span><br><span class="line">git config --<span class="built_in">help</span></span><br><span class="line">man git-config</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三讲 Git 重要命令操练</title>
      <link href="/post/46863b15.html"/>
      <url>/post/46863b15.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-重要命令操练"><a href="#Git-重要命令操练" class="headerlink" title="Git 重要命令操练"></a>Git 重要命令操练</h1><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ol><li>获得版本库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 版本库初始化(本地创建 git 版本库)</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment"># 克隆远程版本库</span></span><br></pre></td></tr></table></figure></li><li>版本管理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment"># 将已修改的文件从工作区纳入到暂存区</span></span><br><span class="line">git commit <span class="comment"># 将暂存区文件提交到 git 本地版本库</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="comment"># 删除文件</span></span><br></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> <span class="comment"># 查看 git 命令使用</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看日志</span></span><br><span class="line">git diff <span class="comment"># 查看文件不同状态的差异</span></span><br></pre></td></tr></table></figure></li><li>远程协作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 将远程版本库当中的文件拉到本地</span></span><br><span class="line">git push <span class="comment"># 将本地版本库当中的版本内容推送到远程</span></span><br></pre></td></tr></table></figure></li><li>查看工作区状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure></li><li>将文件从暂存区回退到工作区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached file</span><br></pre></td></tr></table></figure></li><li>将文件从暂存区提交到本地版本库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;提交消息&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看提交历史</li></ol><ul><li>Git 的提交(commit id)是一个在摘要值。这个摘要值实际是 sha1 计算出来的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>配置信息</li></ol><ul><li>对于 user.name 和 user.email 来说，有三个地方可以设置<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/etc/gitconfig(几乎不会使用)</span><br><span class="line">git config --system</span><br><span class="line"></span><br><span class="line">~/.gitconfig(很常用) # 针对用户(优先级其次)</span><br><span class="line">git config --global</span><br><span class="line"></span><br><span class="line">.git/config # 针对于特定项目的(优先级最高)</span><br><span class="line">git config --local</span><br></pre></td></tr></table></figure></li><li>查看配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li>删除配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --<span class="built_in">unset</span> user.name <span class="comment"># 针对特定项目的</span></span><br></pre></td></tr></table></figure></li><li>查看配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> config <span class="comment"># 查看针对特定项目的配置信息文件</span></span><br><span class="line"><span class="built_in">cat</span> ~/.gitconfig <span class="comment"># 查看针对用户的配置信息文件</span></span><br></pre></td></tr></table></figure></li><li>丢弃在工作区所做的修改<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure></li><li>完全修改文件内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;weclome&#x27;</span> &gt; file <span class="comment"># 文件重定向</span></span><br></pre></td></tr></table></figure></li><li>追加文件内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;weclome&#x27;</span> &gt;&gt; file</span><br></pre></td></tr></table></figure></li><li>从将文件从暂存区回退到工作区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二讲 Git 入门指引</title>
      <link href="/post/16f9fd9.html"/>
      <url>/post/16f9fd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-入门指引"><a href="#Git-入门指引" class="headerlink" title="Git 入门指引"></a>Git 入门指引</h1><h2 id="Git-简史"><a href="#Git-简史" class="headerlink" title="Git 简史"></a>Git 简史</h2><ol><li>Linux 内核开源项目有着位数众多的参与者。一开始整个项目组使用 BitKeeper 来管理和维护代码。2005 年，BitKeeper 不再能免费使用，这就迫使 Linux 开源社区开发一套属于自己的版本控制系统。</li><li>自诞生于 2005 年以来，Git 日臻成熟完善，它的速度飞快，极其适合管理大型项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。</li><li>众多的开源、非开源项目已经逐步由 SVN 迁移到 Git 。</li></ol><h2 id="CVS、SVN-与-Git"><a href="#CVS、SVN-与-Git" class="headerlink" title="CVS、SVN 与 Git"></a>CVS、SVN 与 Git</h2><ol><li>CVCS: 集中式版本控制系统</li><li>DVCS: 分布式版本控制系统</li><li>有了 Git ，编程真正成了一种乐趣。</li></ol><h2 id="Git、GitHub-与-GitLab"><a href="#Git、GitHub-与-GitLab" class="headerlink" title="Git、GitHub 与 GitLab"></a>Git、GitHub 与 GitLab</h2><ol><li>Git 是一个版本控制软件</li><li>GitHub 与 GitLab 都是用于管理版本的服务端软件</li><li>GitHub 提供免费服务(代码需公开)以及付费服务(代码私有)</li><li>GitLab 用于在企业内部管理 Git 版本库，功能上类似于 GitHub</li></ol><h2 id="Git-设计目标"><a href="#Git-设计目标" class="headerlink" title="Git 设计目标"></a>Git 设计目标</h2><ol><li>快速</li><li>简单(学习曲线陡峭)</li><li>高效存储</li><li>完全分布</li><li>满足大规模项目需要</li></ol><h2 id="Git-优点"><a href="#Git-优点" class="headerlink" title="Git 优点"></a>Git 优点</h2><ol><li>本地建立版本库</li><li>本地版本控制</li><li>多主机异地协同工作</li><li>重写提交说明</li><li>有后悔药可以吃</li><li>更好用的提交列表</li><li>更好的差异比较</li><li>更完善的分支系统</li><li>速度极快</li></ol><h2 id="Git-工作模式"><a href="#Git-工作模式" class="headerlink" title="Git 工作模式"></a>Git 工作模式</h2><ol><li>版本库初始化</li></ol><ul><li>个人计算机从版本服务器同步</li></ul><ol start="2"><li>操作</li></ol><ul><li>90% 以上的操作在个人计算机上</li><li>添加文件</li><li>修改文件</li><li>提交变更</li><li>查看版本历史等</li></ul><ol start="3"><li>版本库同步</li></ol><ul><li>将本地修改推送到版本服务器</li></ul><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><ol><li>直接记录快照，而非差异比较</li><li>近乎所有操作都在本地执行</li><li>时刻保持数据完整性</li><li>多数操作仅添加操作</li><li>文件的三种状态</li></ol><ul><li>modified: 已修改</li><li>staged: 已暂存</li><li>committed: 已提交</li></ul><h2 id="Git-文件状态"><a href="#Git-文件状态" class="headerlink" title="Git 文件状态"></a>Git 文件状态</h2><ol><li>Git 文件</li></ol><ul><li>已被版本库管理的文件</li></ul><ol start="2"><li>已修改</li></ol><ul><li>在工作目录修改 Git 文件</li></ul><ol start="3"><li>已暂存</li></ol><ul><li>对已修改的文件执行 Git 暂存操作，将文件存入暂存区</li></ul><ol start="4"><li>已提交</li></ol><ul><li>将已暂存的文件执行 Git 提交操作，将文件存入版本库</li></ul><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><ol><li>Linux: Ubuntu<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li><li>Mac</li></ol><ul><li>安装命令行工具：如已安装 Xcode ，命令行工具会在首次启动 Xcode 时提示安装</li><li>安装 Homebrew<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Windows</li></ol><ul><li>安装 <a href="https://gitforwindows.org/">msysGit</a></li><li>完成安装之后，就可以使用命令行的 git 工具了，另外还有一个图形界面的 Git 项目管理工具。</li><li>建议使用 Git 命令行，方便又快捷，GUI 反而繁琐。</li><li>如果需要使用 GUI ，推荐使用 SourceTree ，拥有 Mac 与 Windows 版本；此外，Windows 下还可以使用 TortoiseGit 。</li></ul><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ul><li>获得版本库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 版本库初始化(本地创建 git 版本库)</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment"># 克隆远程版本库</span></span><br></pre></td></tr></table></figure></li><li>版本管理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment"># 将已修改的文件从工作区纳入到暂存区</span></span><br><span class="line">git commit <span class="comment"># 将暂存区文件提交到 git 本地版本库</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="comment"># 删除文件</span></span><br></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> <span class="comment"># 查看 git 命令使用</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看日志</span></span><br><span class="line">git diff <span class="comment"># 查看文件不同状态的差异</span></span><br></pre></td></tr></table></figure></li><li>远程协作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 将远程版本库当中的文件拉到本地</span></span><br><span class="line">git push <span class="comment"># 将本地版本库当中的版本内容推送到远程</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲 课程内容概述与准备</title>
      <link href="/post/8f4877b8.html"/>
      <url>/post/8f4877b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="课程内容概述与准备"><a href="#课程内容概述与准备" class="headerlink" title="课程内容概述与准备"></a>课程内容概述与准备</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li><a href="http://www.git-scm.com/">Git 官网</a></li><li>常见 Linux 命令介绍</li><li>Git 在各种平台下的安装和配置</li><li>分布式与集中式版本控制系统的差别</li><li>缓存区、工作区与 Git 的提交</li><li>版本回退</li><li>修改与撤销修改、文件添加与删除</li><li>Git 对象类型与索引</li><li>Git 分支</li><li>如何创建、切换与删除分支</li><li>Git 分支在项目开发中的作用</li><li>Git 分支在工程化项目中的最佳实践</li><li>分支常见重要命令详解</li><li>Git merge</li><li>Git 冲突解决策略</li><li>HEAD 详解</li><li>Git commit 修改详情</li><li>远程版本库的介绍</li><li>如何使用远程版本库</li><li>Git push、pull、fetch 使用注意事项</li><li>Git 合并的基本原则</li><li>Git 别名、config 文件详情</li><li>Git tag 详情</li><li>如何创建与推送 tag</li><li>Git feature 分支详解</li><li>Git subtree 详解</li><li>Git subtree的使用方式详解</li><li>.gitignore 的正确使用方式</li><li>Git 私服 Gitlab 的搭建方法</li><li>在公司内部使用 Gitlab 作为版本控制服务器。</li><li>Gitlab 使用详情</li><li>如何使用 Gitlab 管理项目分组、用户角色</li><li>Git issue 与提交使用技巧</li><li>Github 使用方法介绍</li><li>.gitignore 最佳实践</li></ul><h2 id="课程准备"><a href="#课程准备" class="headerlink" title="课程准备"></a>课程准备</h2><h3 id="Mac-电脑开发环境"><a href="#Mac-电脑开发环境" class="headerlink" title="Mac 电脑开发环境"></a>Mac 电脑开发环境</h3><ul><li><p>Mac 自带了 Git</p></li><li><p>Mac 终端</p></li><li><p>查看 git 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>bash 功能过于单一，安装 oh-my-zsh</p></li><li><p>下载 iterm2</p><ul><li><a href="http://www.iterms.com/">官网下载</a></li><li>安装完成后，在 &#x2F;bin 目录下会多出一个 zsh 的文件</li><li>原生的 bash 环境配置文件 .bash_profile 迁移到 .zshrc 文件中，修改环境配置可以在 .zshrc 文件中修改</li></ul></li><li><p>Mac 系统默认使用 bash 作为终端，可以使用命令修改默认使用 zsh 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></li><li><p>如果想修改回默认 bash ，同样使用 chsh 命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>oh-my-zsh 的 curl 安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>oh-my-zsh 的 wget 安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="常见-Linux-命令"><a href="#常见-Linux-命令" class="headerlink" title="常见 Linux 命令"></a>常见 Linux 命令</h2><ol><li>创建文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdkir mygit</span><br></pre></td></tr></table></figure></li><li>进入桌面文件夹<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li><li>回到上一层目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></li><li>回到之前目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure></li><li>回退主目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></li><li>显示当前路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li><li>显示当前路径下的文件内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li>显示当前路径下的所有文件内容(包括隐藏文件)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure></li><li>将光标移到行头<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control a(键盘)</span><br></pre></td></tr></table></figure></li><li>将光标移到行尾<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control e(键盘)</span><br></pre></td></tr></table></figure></li><li>抛弃错误命令<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control c(键盘)</span><br></pre></td></tr></table></figure></li><li>新建文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test.txt</span><br></pre></td></tr></table></figure></li><li>vi 打开和修改文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt</span><br></pre></td></tr></table></figure></li><li>vi 下的一些常用命令</li></ol><ul><li>显示行号<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：set number</span><br></pre></td></tr></table></figure></li><li>进入插入模式<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i(键盘)</span><br></pre></td></tr></table></figure></li><li>退出插入模式<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Esc(键盘)</span><br></pre></td></tr></table></figure></li><li>保存并退出文件(插入模式)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Esc(键盘)</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure></li><li>往下滚屏<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control f(键盘)</span><br></pre></td></tr></table></figure></li><li>往上滚屏<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control b(键盘)</span><br></pre></td></tr></table></figure></li><li>定位到最后一行<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift g(键盘)</span><br></pre></td></tr></table></figure></li><li>定位到某一行<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: number(键盘)</span><br></pre></td></tr></table></figure></li><li>删除某一行<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: number d d (键盘)</span><br></pre></td></tr></table></figure></li><li>光标移到行尾并切换到插入模式<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift a(键盘)</span><br></pre></td></tr></table></figure></li></ul><ol start="15"><li>查看文件内容<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt</span><br></pre></td></tr></table></figure></li><li>复制文件、粘贴文件<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp test.txt test2.txt</span><br></pre></td></tr></table></figure></li><li>清屏(两种方式)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">control l(快捷键)</span><br></pre></td></tr></table></figure></li><li>文件重命名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> test2.txt text3.txt</span><br></pre></td></tr></table></figure></li><li>文件删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> test3.txt</span><br></pre></td></tr></table></figure></li><li>命令使用具体方法查询(查看帮助文档)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">rm</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 使用 iTerm2 进行远程服务器文件的上传下载</title>
      <link href="/post/67502ae4.html"/>
      <url>/post/67502ae4.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在 Windows 下面使用 xShell 时，经常使用 sz 命令进行文件的上传下载非常方便。</li><li>在 Mac 下面就不能直接使用了，需要进行配置才能使用这么方便的功能。</li></ol><h2 id="安装-lrzsz"><a href="#安装-lrzsz" class="headerlink" title="安装 lrzsz"></a>安装 lrzsz</h2><ul><li>安装 lrzsz<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure></li><li>安装完成后检查是否存在<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -alh /usr/local/bin/sz</span><br></pre></td></tr></table></figure></li><li>lrzsz 是对 zmodem 协议实现的软件包</li></ul><h2 id="配置-iTerm2-属性"><a href="#配置-iTerm2-属性" class="headerlink" title="配置 iTerm2 属性"></a>配置 iTerm2 属性</h2><ul><li><p>拉取<a href="https://gitcode.net/mirrors/mmastrac/iterm2-zmodem?utm_source=csdn_github_accelerator">相关仓库</a> </p></li><li><p>上面仓库主要文件如下： </p><ul><li>iterm2-recv-zmodem.sh </li><li>iterm2-send-zmodem.sh</li></ul></li><li><p>将两个脚本 copy 到 &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 文件夹下面 </p></li><li><p>设置一下两个脚本的权限，一般 chmod 777 就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure></li><li><p>设置 iterm2 的 Tirgger 特性， profiles -&gt; default -&gt; editProfiles -&gt; Advanced 中的 Tirgger</p></li><li><p>添加两条 trigger，分别设置 Regular expression，Action，Parameters，Instant 如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.第一条</span><br><span class="line">        Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">        Action: Run Silent Coprocess</span><br><span class="line">        Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line">        Instant: checked</span><br><span class="line">2.第二条</span><br><span class="line">        Regular expression: \*\*B00000000000000</span><br><span class="line">        Action: Run Silent Coprocess</span><br><span class="line">        Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br><span class="line">        Instant: checked</span><br></pre></td></tr></table></figure></li><li><p>添加过程如下：</p><p><img src="/img/loading.gif" data-original="../../img/posts/mac/lrzsz_01.png" width = 98% height = 100% /><p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/weixin_34067980/article/details/91773253">iTerm2 使用 zmodem 协议上传下载文件</a></li><li><a href="https://blog.csdn.net/weixin_34115824/article/details/88036529">在 Mac 上使用 iTerm2 进行 sz 和 rz 命令进行远程服务器文件的上传下载功能</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iTerm2 </tag>
            
            <tag> lrzsz </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 MySQL</title>
      <link href="/post/59e50a26.html"/>
      <url>/post/59e50a26.html</url>
      
        <content type="html"><![CDATA[<h2 id="下载-mysql"><a href="#下载-mysql" class="headerlink" title="下载 mysql"></a>下载 mysql</h2><ul><li><a href="https://dev.mysql.com/downloads/mysql/">官方网站</a></li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_01.png" width = 90% height = 100% /><p><ul><li>双击打开下载的 mysql-8.0.22-macos10.15-x86_64.dmg 安装包</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_02.png" width = 90% height = 100% /><p><ul><li>一路点击继续，直到以下画面</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_03.png" width = 90% height = 100% /><p><ul><li>选择 Use Legacy Password Encryption</li><li>此处需要你设置一个密码，记住这个密码是你日后登录 mysql 的密码</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/mysql_04.png" width = 90% height = 100% /><p><ul><li>完成之后，打开系统偏好设置，会发现下面多出了 mysql 的小图标 </li><li>双击打开 mysql 的小图标 </li><li>如果显示 Start MySQL Server，表示现在是停止运行的，点击按钮即可运行 mysql</li><li>如果显示显示 Stop MySQL Server，表示现在是正在运行的，点击按钮即可停止 mysql</li></ul><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul><li>修改 .zshrc 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>添加环境变量<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Path to your mysql installation.</span><br><span class="line">export PATH=$PATH:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure></li><li>使更改立即生效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="登录-mysql"><a href="#登录-mysql" class="headerlink" title="登录 mysql"></a>登录 mysql</h2><ul><li>登录 mysql<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></li><li>输入密码，即可进入 mysql 数据库操作</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/mirajay_yeah/article/details/110388507">转载: Mac 安装 mysql (极简)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 Anaconda 教程</title>
      <link href="/post/3bae1910.html"/>
      <url>/post/3bae1910.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>Anaconda 指的是一个开源的 Python 发行版本，其包含了 conda、Python 等 180 多个科学包及其依赖项。</li><li>因为包含了大量的科学包，Anaconda 的下载文件比较大(约 531 MB)，如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版(仅包含 conda 和 Python)。</li><li>Anaconda 包括 Conda、Python 以及一大堆安装好的工具包，比如：Numpy、Pandas 等。</li><li>Miniconda 包括 Conda、Python。</li><li>conda 是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。</li></ol><h2 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h2><ul><li><a href="https://docs.anaconda.com/anaconda/install/">Anaconda 官方下载网址</a></li><li>选择 mac 版本，下载好软件包后一路默认安装，dmg 安装会自动添加环境变量</li></ul><h2 id="Anaconda-换源"><a href="#Anaconda-换源" class="headerlink" title="Anaconda 换源"></a>Anaconda 换源</h2><ul><li>打开 Anaconda 软件，初始化后，会在用户目录下生成 .condarc 文件</li><li>修改 .condarc 文件，更换清华镜像源<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure></li><li>安装完 Anaconda，终端默认进入 Anaconda 中的 base 环境，这里取消默认设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Anaconda-基本命令"><a href="#Anaconda-基本命令" class="headerlink" title="Anaconda 基本命令"></a>Anaconda 基本命令</h2><ul><li>查看当前的 conda 版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></li><li>常看当前所有的环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure></li><li>创建新的 Python 环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name python=3.6.2</span><br></pre></td></tr></table></figure></li><li>切换环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure></li><li>退出环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate env_name</span><br></pre></td></tr></table></figure></li><li>移除环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n env_name --all</span><br></pre></td></tr></table></figure></li></ul><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><ul><li>查看当前环境的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li>查看指定 xxx 环境下的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n xxx</span><br></pre></td></tr></table></figure></li><li>查找包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search xxx</span><br></pre></td></tr></table></figure></li><li>更新包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure></li><li>更新所有库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure></li><li>更新 conda 自身<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></li><li>更新 anaconda 自身<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure></li><li>安装包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xxx</span><br></pre></td></tr></table></figure></li><li>也可指定安装的环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name xxx</span><br></pre></td></tr></table></figure></li><li>卸载包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove xxx</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/qq_31573519/article/details/82845515">Mac 安装 anaconda 及其基本命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 Go 环境</title>
      <link href="/post/67a9606f.html"/>
      <url>/post/67a9606f.html</url>
      
        <content type="html"><![CDATA[<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><ul><li><a href="https://go.dev/dl/">官方源下载</a> </li><li><a href="https://studygolang.com/dl">国内源下载</a></li><li>直接下一步安装即可</li></ul><h2 id="GO111MODULE-设置"><a href="#GO111MODULE-设置" class="headerlink" title="GO111MODULE 设置"></a>GO111MODULE 设置</h2><ul><li>设置 GO111MODULE<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置-GOPATH"><a href="#配置-GOPATH" class="headerlink" title="配置 GOPATH"></a>配置 GOPATH</h2><ul><li>查看具体信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span></span><br></pre></td></tr></table></figure></li><li>在用户目录(&#x2F;Users&#x2F;mac)下，新建 go 目录，再在下面建立 bin pkg src 文件夹</li><li>修改 .zshrc 文件，添加环境变量<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) vim ~/.zshrc</span><br><span class="line">(2) 添加</span><br><span class="line">export GOPATH=/Users/用户名/go</span><br><span class="line">(3) 使更改立即生效</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/082549479701">Mac 安装 go 语言</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台 java 开发环境搭建教程</title>
      <link href="/post/87aba1ef.html"/>
      <url>/post/87aba1ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h2><ul><li>在安装 JDK 之前，先查看下自己电脑是否已经安装了 JDK</li><li>打开终端，输入 java –version 并回车<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java 17.0.1 2021-10-19 LTS</span><br><span class="line">Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)</span><br></pre></td></tr></table></figure></li><li>从上图中可以看出我们已安装了 JDK 17</li><li>如果这个版本是你需要的版本，可直接看如何配置 Java 开发环境</li></ul><h2 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h2><ul><li><a href="https://www.oracle.com/java/technologies/downloads/">官网下载</a></li><li>JDK 安装</li><li>MAC 系统 JDK 安装是很简单的，一路下一步就 ok 了</li></ul><h2 id="配置-Java-开发环境"><a href="#配置-Java-开发环境" class="headerlink" title="配置 Java 开发环境"></a>配置 Java 开发环境</h2><ul><li>MAC 默认安装目录为 &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;</li><li>编辑 ～&#x2F;.zshrc 文件，添加环境变量(前提：事先装了 oh-my-zsh)</li></ul><p><img src="/img/loading.gif" data-original="../../img/posts/mac/java_01.png" width = 100% height = 100% /><p><ul><li>使更改立即生效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><ul><li>可以用文本编辑器写程序，保存为后缀为 Test.java 的 Java 文件，进行程序测试<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/wyaokai/p/12520494.html">MAC 系统 java 开发环境搭建教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台给 Github 配置 SSH</title>
      <link href="/post/ff91de0c.html"/>
      <url>/post/ff91de0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="配置本地-Git"><a href="#配置本地-Git" class="headerlink" title="配置本地 Git"></a>配置本地 Git</h2><ul><li>打开终端 </li><li>Git 全局设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;github 账户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;注册 github 所用邮箱&quot;</span></span><br></pre></td></tr></table></figure></li><li>查看配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><ul><li><p>主目录下(&#x2F;Users&#x2F;用户名)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure></li><li><p>如果不存在 .ssh 文件夹，新建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .ssh</span><br></pre></td></tr></table></figure></li><li><p>切换文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br></pre></td></tr></table></figure></li><li><p>生成公私钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;注册 github 所用邮箱&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>一路回车，出现如下画面表示成功</p><p><img src="/img/loading.gif" data-original="../../img/posts/mac/ssh_01.png" width = 30% height = 30% /><p></li><li><p>查看公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>复制密钥，进入 github ，然后点击 Setting -&gt; SSh and GPG keys -&gt; New SSH key ，将复制 id_rsa.pub 内容粘贴上去即可</p></li><li><p>验证是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Github </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/post/d98ef1d2.html"/>
      <url>/post/d98ef1d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><ul><li><a href="https://leetcode-cn.com/problems/two-sum/">题目传送门</a></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一：暴力破解"><a href="#方法一：暴力破解" class="headerlink" title="方法一：暴力破解"></a>方法一：暴力破解</h4><h5 id="个人解"><a href="#个人解" class="headerlink" title="个人解"></a>个人解</h5><ul><li><p>关键点：用两层循环进行解题</p></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        loop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> j, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> num + v == target:</span><br><span class="line">                        result.append(i)</span><br><span class="line">                        result.append(j)</span><br><span class="line">                        loop = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> loop:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    resultSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    Loop:</span><br><span class="line">    <span class="comment">// 1. 循环遍历 nums</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 2. 循环遍历 nums</span></span><br><span class="line">        <span class="keyword">for</span> j, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 3. 判断元素是否重复</span></span><br><span class="line">            <span class="keyword">if</span> i != j &#123;</span><br><span class="line">                <span class="comment">// 4. 两数之和等于目标值</span></span><br><span class="line">                <span class="keyword">if</span> num + v == target &#123;</span><br><span class="line">                    resultSlice = <span class="built_in">append</span>(resultSlice, i)</span><br><span class="line">                    resultSlice = <span class="built_in">append</span>(resultSlice, j)</span><br><span class="line">                    <span class="keyword">break</span> Loop</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>个人总结： </p><ul><li>Python3 版本提交结果 ✅ ，执行用时 6524 ms，内存消耗 15.5 MB。</li><li>Golang 版本提交结果 ✅ ，执行用时 48 ms，内存消耗 3.4 MB。</li><li>可改进点：第二次遍历的时候，应该从 i + 1 元素开始。</li></ul></li></ul><h5 id="官方解"><a href="#官方解" class="headerlink" title="官方解"></a><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">官方解</a></h5><ul><li><p>关键点：</p><ul><li>最容易想到的方法是枚举数组中的每一个数 x ，寻找数组中是否存在 target - x 。 </li><li>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。 </li><li>而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x 。</li></ul></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> x+nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</li><li>空间复杂度：O(1)。</li></ul></li></ul><h4 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h4><h5 id="个人解-1"><a href="#个人解-1" class="headerlink" title="个人解"></a>个人解</h5><ul><li><p>关键点：用哈希表进行解题</p></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        records = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 用枚举更方便，就不需要通过索引再去取当前位置的值</span></span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - val <span class="keyword">not</span> <span class="keyword">in</span> records:</span><br><span class="line">                records[val] = idx</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [records[target - val], idx] <span class="comment"># 如果存在就返回字典记录索引和当前索引</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    resultSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    sliceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sliceMap[num] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := sliceMap[target - v]; ok &#123;</span><br><span class="line">            <span class="keyword">if</span> j == sliceMap[target - v] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            resultSlice = <span class="built_in">append</span>(resultSlice, j)</span><br><span class="line">            resultSlice = <span class="built_in">append</span>(resultSlice, sliceMap[target - v])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>个人总结：</p><ul><li>Python3 版本提交结果 ✅ ，执行用时 28 ms，内存消耗 16 MB。 </li><li>Golang 版本提交结果 ✅ ，执行用时 8 ms，内存消耗 5.4 MB。 </li><li>可改进点：哈希表添加元素和匹配可以同时进行。</li></ul></li></ul><h5 id="官方解-1"><a href="#官方解-1" class="headerlink" title="官方解"></a><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">官方解</a></h5><ul><li><p>关键点：</p><ul><li>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。 </li><li>因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。 </li><li>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N^2) 降低到 O(1)。 </li><li>这样我们创建一个哈希表，对于每一个 x ，我们首先查询哈希表中是否存在 target - x ，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</li></ul></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target-x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x ，我们可以 O(1) 地寻找 target - x 。 </li><li>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台配置 iTerm2 + oh-my-zsh</title>
      <link href="/post/9ca5bb98.html"/>
      <url>/post/9ca5bb98.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mac-安装-iTerm2"><a href="#Mac-安装-iTerm2" class="headerlink" title="Mac 安装 iTerm2"></a>Mac 安装 iTerm2</h2><ul><li>下载 iTerm2</li><li><a href="https://www.iterm2.com/index.html">官方链接</a></li></ul><h2 id="Mac-安装-oh-my-zsh"><a href="#Mac-安装-oh-my-zsh" class="headerlink" title="Mac 安装 oh-my-zsh"></a>Mac 安装 oh-my-zsh</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>Mac 系统一般预置安装了 zsh，如果当前默认 shell 是 bash，则修改默认 shell，如果默认的 shell 是 zsh，则不改变<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></li><li>你的 Mac 上需要安装 git</li></ul><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ul><li>克隆代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure></li><li>备份已有的 .zshrc 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/.zshrc ~/.zshrc.bak</span><br></pre></td></tr></table></figure></li><li>新建一个 zsh 的配置文件，可以拷贝一份已有的模板文件来创建 zsh 的配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>重新打开一个终端窗口，它将自动开启加载 oh-my-zsh 配置的 zsh</li><li>以上四步结束后，可能会存在 zsh 目录权限问题，解决问题如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 /usr/local/share/zsh</span><br><span class="line"><span class="built_in">chmod</span> 755 /usr/local/share/zsh/site-functions</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><h4 id="命令高亮插件"><a href="#命令高亮插件" class="headerlink" title="命令高亮插件"></a>命令高亮插件</h4><ul><li>下载高亮插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting ~/.zsh/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></li><li>编辑配置文件，使用插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>在 .zshrc 文件的 plugins 后面加入 zsh-syntax-highlighting 插件名</li><li>重启终端</li></ul><h4 id="命令提示插件"><a href="#命令提示插件" class="headerlink" title="命令提示插件"></a>命令提示插件</h4><ul><li>下载命令提示插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li><li>编辑配置文件，使用插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>在 .zshrc 文件的 plugins 后面加入 zsh-autosuggestions 插件名</li><li>重启终端</li></ul><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="更换-zsh-主题为-Dracula"><a href="#更换-zsh-主题为-Dracula" class="headerlink" title="更换 zsh 主题为 Dracula"></a>更换 zsh 主题为 Dracula</h3><ul><li>下载主题文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dracula/zsh.git</span><br></pre></td></tr></table></figure></li><li>创建一个指向 oh-my-zsh 主题文件夹的符号链接，DRACULA_THEME 是刚才下载主题的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s <span class="variable">$DRACULA_THEME</span>/dracula.zsh-theme ~/.oh-my-zsh/themes/dracula.zsh-theme</span><br></pre></td></tr></table></figure></li><li>修改 zsh 主题，编辑 .zshrc 文件，修改 ZSH_THEME 为 “dracula” <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line">ZSH_THEME=<span class="string">&quot;dracula&quot;</span> </span><br></pre></td></tr></table></figure></li></ul><h3 id="更换-iterm2-主题为-Dracula"><a href="#更换-iterm2-主题为-Dracula" class="headerlink" title="更换 iterm2 主题为 Dracula"></a>更换 iterm2 主题为 Dracula</h3><ul><li><p>下载 iterm2 的 Dracula 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dracula/iterm.git</span><br></pre></td></tr></table></figure></li><li><p>设置主题</p><ul><li>iTerm2 &gt; Preferences &gt; Profiles &gt; Colors Tab</li><li>Open the Color Presets…</li><li>从列表中选择 import</li><li>选择刚才下载主题中 Dracula.itermcolors 文件，确定</li></ul></li><li><p>再次打开 Color Presets… ，选择 Dracula</p></li><li><p>重启终端</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/daiyuhe/article/details/88667875">利用 iTerm2+oh-my-zsh+Dracula 主题打造我的 Mac 终端利器</a></li><li><a href="https://blog.csdn.net/qq_43656353/article/details/106444661">关于 zsh 目录权限问题的解决</a></li><li><a href="https://blog.csdn.net/weixin_43376075/article/details/110840009">mac 入门-安装 oh my zsh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iTerm2 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> Dracula </tag>
            
            <tag> oh-my-zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 MongoDB</title>
      <link href="/post/d6049e8.html"/>
      <url>/post/d6049e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB-下载"><a href="#MongoDB-下载" class="headerlink" title="MongoDB 下载"></a>MongoDB 下载</h2><ul><li>MongoDB 提供了 Mac 平台上 64 位的安装包，你可以在官网下载安装包</li><li><a href="https://www.mongodb.com/try/download/community">官方下载链接</a></li></ul><h2 id="MongoDB-安装步骤"><a href="#MongoDB-安装步骤" class="headerlink" title="MongoDB 安装步骤"></a>MongoDB 安装步骤</h2><ul><li>找到下载的 MongoDB 压缩文件 mongodb-macos-x86_64-5.0.5.tgz</li><li>移动文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> mongodb-macos-x86_64-5.0.5.tgz /usr/local/</span><br></pre></td></tr></table></figure></li><li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf mongodb-macos-x86_64-5.0.5.tgz</span><br></pre></td></tr></table></figure></li><li>重命名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> mongodb-macos-x86_64-5.0.5/ mongodb</span><br></pre></td></tr></table></figure></li><li>删除压缩文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> mongodb-macos-x86_64-5.0.5.tgz</span><br></pre></td></tr></table></figure></li><li>添加环境变量(安装过 oh-my-zsh)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) vim ~/.zshrc</span><br><span class="line">(2) 添加 PATH</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/mongodb/bin</span><br><span class="line">(3) 使修改立即生效</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>创建日志及数据存放的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 切换到 /usr/local/var/db 目录</span><br><span class="line"><span class="built_in">mkdir</span> mongodb</span><br><span class="line">(2) 切换到 /usr/local/var/log 目录</span><br><span class="line"><span class="built_in">touch</span> mongodb.log</span><br></pre></td></tr></table></figure></li><li>添加配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(1) 切换到 /usr/local/etc 目录下</span><br><span class="line">(2) vim mongodb.conf</span><br><span class="line">(3) 添加内容</span><br><span class="line"><span class="comment"># 数据库路径</span></span><br><span class="line">dbpath=/usr/local/var/db/mongodb</span><br><span class="line"><span class="comment"># 日志输出文件路径</span></span><br><span class="line">logpath=/usr/local/var/log/mongodb.log</span><br><span class="line"><span class="comment"># 错误日志采用追加模式</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 启用日志文件，默认启用</span></span><br><span class="line">journal=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span></span><br><span class="line">quiet=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 端口号 默认为27017</span></span><br><span class="line">port=27017</span><br><span class="line"><span class="comment"># 允许远程访问</span></span><br><span class="line"><span class="comment"># bind_ip=0.0.0.0</span></span><br><span class="line"><span class="comment"># 开启子进程</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 开启认证，必选先添加用户，先不开启（不用验证账号密码）</span></span><br><span class="line"><span class="comment"># auth=true</span></span><br></pre></td></tr></table></figure></li><li>直接设置配置文件启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongodb.conf</span><br></pre></td></tr></table></figure></li><li>另外开启新的终端，输入 mongo 命令进入 MongoDB 数据库</li><li>正常退出数据库(mongo 执行命令的终端窗口)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) use admin</span><br><span class="line">(2) db.shutdownServer()</span><br><span class="line">(3) control + c</span><br></pre></td></tr></table></figure><h2 id="MongoDB-常用命令"><a href="#MongoDB-常用命令" class="headerlink" title="MongoDB 常用命令"></a>MongoDB 常用命令</h2></li></ul><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">db.help()</td><td align="center">查看命令提示</td></tr><tr><td align="center">db</td><td align="center">查看当前所在数据库的名字</td></tr><tr><td align="center">use 数据库名</td><td align="center">表示切换或是创建数据库</td></tr><tr><td align="center">show dbs</td><td align="center">显示有数据的库</td></tr><tr><td align="center">db.stats()</td><td align="center">查看当前数据的状态</td></tr><tr><td align="center">db.version()</td><td align="center">查看 MongoDB 版本</td></tr><tr><td align="center">db.[数据库名].insert()</td><td align="center">插入数据</td></tr><tr><td align="center">db.[数据库名].find()</td><td align="center">查找数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 平台安装 Homebrew</title>
      <link href="/post/48976.html"/>
      <url>/post/48976.html</url>
      
        <content type="html"><![CDATA[<h2 id="brew-安装脚本"><a href="#brew-安装脚本" class="headerlink" title="brew 安装脚本"></a>brew 安装脚本</h2><ul><li>brew 安装脚本(国内源)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span> </span><br></pre></td></tr></table></figure></li><li>傻瓜式安装(建议选择中科大源)</li></ul><h2 id="brew-卸载脚本"><a href="#brew-卸载脚本" class="headerlink" title="brew 卸载脚本"></a>brew 卸载脚本</h2><ul><li>brew 卸载脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>brew 常用命令</li></ul><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">安装软件</td><td align="center">brew install xxx</td></tr><tr><td align="center">卸载软件</td><td align="center">brew uninstall xxx</td></tr><tr><td align="center">搜索软件</td><td align="center">brew search xxx</td></tr><tr><td align="center">更新软件</td><td align="center">brew upgrade xxx</td></tr><tr><td align="center">查看列表</td><td align="center">list</td></tr><tr><td align="center">更新 brew</td><td align="center">brew update</td></tr><tr><td align="center">清理所有包的旧版本</td><td align="center">brew cleanup</td></tr><tr><td align="center">清理指定包的旧版本</td><td align="center">brew cleanup $FORMULA</td></tr><tr><td align="center">查看可清理的旧版本包，不执行实际操作</td><td align="center">brew cleanup -n</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/032ce92e4c7b?utm_campaign=shakespeare">转载: homebrew 安装、卸载、基本操作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
